{"version":3,"file":"index-jqD5FmsT.js","sources":["../../src/agents/built-in/hitl/hitl-agent.ts"],"sourcesContent":["/**\n * HITL Agent - Human-in-the-Loop Workflows\n *\n * Features:\n * - Suspend workflow execution for manual approval\n * - Resume execution after approval/rejection\n * - Notification system (Slack, email, webhook)\n * - Timeout handling with auto-expiry\n * - State persistence via Durable Objects\n */\n\nimport { BaseAgent, type AgentExecutionContext } from '../../base-agent.js'\nimport type { AgentConfig } from '../../../runtime/parser.js'\nimport { createLogger } from '../../../observability/index.js'\nimport type {\n  HITLConfig,\n  HITLSuspendInput,\n  HITLResumeInput,\n  HITLResult,\n  HITLSuspendResult,\n  HITLResumeResult,\n} from './types.js'\nimport type { ConductorEnv } from '../../../types/env.js'\n\nconst logger = createLogger({ serviceName: 'hitl-agent' })\n\nexport class HITLMember extends BaseAgent {\n  private hitlConfig: HITLConfig\n\n  constructor(\n    config: AgentConfig,\n    private readonly env: ConductorEnv\n  ) {\n    super(config)\n\n    const cfg = config.config as HITLConfig | undefined\n\n    this.hitlConfig = {\n      action: cfg?.action || 'suspend',\n      timeout: cfg?.timeout || 86400000, // 24 hours\n      notificationChannel: cfg?.notificationChannel,\n      notificationConfig: cfg?.notificationConfig,\n    }\n  }\n\n  protected async run(context: AgentExecutionContext): Promise<HITLResult> {\n    const action = this.hitlConfig.action!\n\n    switch (action) {\n      case 'suspend':\n        return await this.suspendForApproval(context)\n      case 'resume':\n        return await this.resumeExecution(context)\n      case 'approve':\n        return await this.approveExecution(context)\n      case 'reject':\n        return await this.rejectExecution(context)\n      default:\n        throw new Error(`Unknown HITL action: ${action}`)\n    }\n  }\n\n  /**\n   * Suspend execution and wait for approval\n   */\n  private async suspendForApproval(context: AgentExecutionContext): Promise<HITLSuspendResult> {\n    const input = context.input as HITLSuspendInput\n\n    if (!input.approvalData) {\n      throw new Error('Suspend action requires \"approvalData\" in input')\n    }\n\n    // Check for HITL_STATE Durable Object binding\n    if (!this.env.HITL_STATE) {\n      throw new Error(\n        'HITL agent requires HITL_STATE binding. Add [[durable_objects]] binding = \"HITL_STATE\" to wrangler.toml'\n      )\n    }\n\n    // Generate execution ID/token\n    const token = this.generateExecutionId()\n    const ttlSeconds = Math.floor(this.hitlConfig.timeout! / 1000)\n    const expiresAt = Date.now() + this.hitlConfig.timeout!\n\n    // Build simplified state for storage\n    // Note: Full SuspendedExecutionState is managed by the caller\n    // executionId is a branded type, need to unwrap it for storage\n    const execId = context.executionId\n      ? typeof context.executionId === 'string'\n        ? context.executionId\n        : (context.executionId as { value: string }).value\n      : token\n\n    const suspendedState = {\n      executionId: execId,\n      input: context.input,\n      suspendedAt: Date.now(),\n      resumeToken: token,\n    }\n\n    // Get Durable Object and suspend execution\n    const doId = this.env.HITL_STATE.idFromName(token)\n    const stub = this.env.HITL_STATE.get(doId)\n\n    const response = await stub.fetch(\n      new Request('https://hitl/suspend', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          token,\n          suspendedState,\n          ttl: ttlSeconds,\n        }),\n      })\n    )\n\n    if (!response.ok) {\n      const error = await response.text()\n      throw new Error(`Failed to suspend execution: ${error}`)\n    }\n\n    logger.info('Execution suspended for approval', {\n      token,\n      expiresAt,\n      ttlSeconds,\n    })\n\n    // Send notification\n    if (this.hitlConfig.notificationChannel) {\n      await this.sendNotification(token, input.approvalData)\n    }\n\n    // Build callback URL - user should configure their base URL via notificationConfig.baseUrl\n    const baseUrl =\n      (this.hitlConfig.notificationConfig?.baseUrl as string) || 'https://your-worker.workers.dev'\n    const approvalUrl = `${baseUrl}/callback/${token}`\n\n    return {\n      status: 'suspended',\n      executionId: token,\n      approvalUrl,\n      expiresAt,\n    }\n  }\n\n  /**\n   * Resume execution after approval/rejection\n   */\n  private async resumeExecution(context: AgentExecutionContext): Promise<HITLResumeResult> {\n    const input = context.input as HITLResumeInput\n\n    if (!input.executionId) {\n      throw new Error('Resume action requires \"executionId\" in input')\n    }\n\n    // Check for HITL_STATE Durable Object binding\n    if (!this.env.HITL_STATE) {\n      throw new Error(\n        'HITL agent requires HITL_STATE binding. Add [[durable_objects]] binding = \"HITL_STATE\" to wrangler.toml'\n      )\n    }\n\n    // Get Durable Object\n    const doId = this.env.HITL_STATE.idFromName(input.executionId)\n    const stub = this.env.HITL_STATE.get(doId)\n\n    // First, get current status\n    const statusResponse = await stub.fetch(\n      new Request('https://hitl/status', {\n        method: 'GET',\n      })\n    )\n\n    if (!statusResponse.ok) {\n      if (statusResponse.status === 404) {\n        return {\n          status: 'expired',\n          executionId: input.executionId,\n          comments: 'Execution not found or expired',\n        }\n      }\n      const error = await statusResponse.text()\n      throw new Error(`Failed to get HITL status: ${error}`)\n    }\n\n    const currentState = (await statusResponse.json()) as {\n      status: string\n      expiresAt: number\n      approvalData?: unknown\n      rejectionReason?: string\n    }\n\n    // Check if already processed\n    if (currentState.status !== 'pending') {\n      return {\n        status: currentState.status as HITLResumeResult['status'],\n        executionId: input.executionId,\n        comments: currentState.rejectionReason,\n      }\n    }\n\n    // Check if expired\n    if (Date.now() > currentState.expiresAt) {\n      return {\n        status: 'expired',\n        executionId: input.executionId,\n        comments: 'Approval request expired',\n      }\n    }\n\n    // Process approval or rejection\n    if (input.approved) {\n      const approveResponse = await stub.fetch(\n        new Request('https://hitl/approve', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({\n            actor: input.actor || 'system',\n            approvalData: input.approvalData,\n          }),\n        })\n      )\n\n      if (!approveResponse.ok) {\n        const error = await approveResponse.text()\n        throw new Error(`Failed to approve: ${error}`)\n      }\n\n      const result = (await approveResponse.json()) as {\n        suspendedState: Record<string, unknown>\n        approvalData?: unknown\n      }\n\n      logger.info('Execution approved', { executionId: input.executionId })\n\n      return {\n        status: 'approved',\n        executionId: input.executionId,\n        state: result.suspendedState,\n        comments: input.comments,\n      }\n    } else {\n      const rejectResponse = await stub.fetch(\n        new Request('https://hitl/reject', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({\n            actor: input.actor || 'system',\n            reason: input.comments,\n          }),\n        })\n      )\n\n      if (!rejectResponse.ok) {\n        const error = await rejectResponse.text()\n        throw new Error(`Failed to reject: ${error}`)\n      }\n\n      logger.info('Execution rejected', { executionId: input.executionId })\n\n      return {\n        status: 'rejected',\n        executionId: input.executionId,\n        comments: input.comments,\n      }\n    }\n  }\n\n  /**\n   * Approve execution (shorthand for resume with approved=true)\n   */\n  private async approveExecution(context: AgentExecutionContext): Promise<HITLResumeResult> {\n    const input = context.input as HITLResumeInput\n    return await this.resumeExecution({\n      ...context,\n      input: { ...input, approved: true },\n    })\n  }\n\n  /**\n   * Reject execution (shorthand for resume with approved=false)\n   */\n  private async rejectExecution(context: AgentExecutionContext): Promise<HITLResumeResult> {\n    const input = context.input as HITLResumeInput\n    return await this.resumeExecution({\n      ...context,\n      input: { ...input, approved: false },\n    })\n  }\n\n  /**\n   * Send notification to configured channel\n   */\n  private async sendNotification(\n    executionId: string,\n    approvalData: Record<string, unknown>\n  ): Promise<void> {\n    const channel = this.hitlConfig.notificationChannel\n    const config = this.hitlConfig.notificationConfig || {}\n\n    switch (channel) {\n      case 'slack':\n        await this.sendSlackNotification(executionId, approvalData, config)\n        break\n      case 'email':\n        await this.sendEmailNotification(executionId, approvalData, config)\n        break\n      case 'webhook':\n        await this.sendWebhookNotification(executionId, approvalData, config)\n        break\n    }\n  }\n\n  /**\n   * Send Slack notification\n   */\n  private async sendSlackNotification(\n    executionId: string,\n    approvalData: Record<string, unknown>,\n    config: Record<string, unknown>\n  ): Promise<void> {\n    const webhookUrl = config.webhookUrl\n\n    if (!webhookUrl || typeof webhookUrl !== 'string') {\n      throw new Error('Slack notification requires webhookUrl in notificationConfig')\n    }\n\n    const baseUrl = (config.baseUrl as string) || 'https://your-worker.workers.dev'\n    const approveUrl = `${baseUrl}/callback/${executionId}?action=approve`\n    const rejectUrl = `${baseUrl}/callback/${executionId}?action=reject`\n\n    const message = {\n      text: `üîî Approval Required`,\n      blocks: [\n        {\n          type: 'header',\n          text: {\n            type: 'plain_text',\n            text: 'üîî Approval Required',\n          },\n        },\n        {\n          type: 'section',\n          text: {\n            type: 'mrkdwn',\n            text: `*Execution ID:* \\`${executionId}\\`\\n*Data:*\\n\\`\\`\\`${JSON.stringify(approvalData, null, 2)}\\`\\`\\``,\n          },\n        },\n        {\n          type: 'actions',\n          elements: [\n            {\n              type: 'button',\n              text: {\n                type: 'plain_text',\n                text: '‚úì Approve',\n              },\n              style: 'primary',\n              url: approveUrl,\n            },\n            {\n              type: 'button',\n              text: {\n                type: 'plain_text',\n                text: '‚úó Reject',\n              },\n              style: 'danger',\n              url: rejectUrl,\n            },\n          ],\n        },\n        {\n          type: 'context',\n          elements: [\n            {\n              type: 'mrkdwn',\n              text: `‚è±Ô∏è Expires in ${Math.round(this.hitlConfig.timeout! / 3600000)} hours`,\n            },\n          ],\n        },\n      ],\n    }\n\n    await fetch(webhookUrl, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(message),\n    })\n\n    logger.info('Slack notification sent', { executionId })\n  }\n\n  /**\n   * Send email notification\n   *\n   * Requires notificationConfig to include:\n   * - to: Recipient email address\n   * - from: Sender email address (must be verified in Cloudflare)\n   * - subject: (optional) Custom subject line\n   * - baseUrl: Base URL for callback links\n   */\n  private async sendEmailNotification(\n    executionId: string,\n    approvalData: Record<string, unknown>,\n    config: Record<string, unknown>\n  ): Promise<void> {\n    const to = config.to as string\n    const from = config.from as string\n    const baseUrl = (config.baseUrl as string) || 'https://your-worker.workers.dev'\n    const subject = (config.subject as string) || 'üîî Approval Required'\n\n    if (!to || !from) {\n      logger.warn('Email notification skipped: missing to or from in notificationConfig', {\n        executionId,\n      })\n      return\n    }\n\n    // Build approval/rejection URLs\n    const approveUrl = `${baseUrl}/callback/${executionId}?action=approve`\n    const rejectUrl = `${baseUrl}/callback/${executionId}?action=reject`\n\n    // Build email body\n    const htmlBody = `\n<!DOCTYPE html>\n<html>\n<head>\n  <style>\n    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; padding: 20px; }\n    .container { max-width: 600px; margin: 0 auto; }\n    .header { background: #f5f5f5; padding: 20px; border-radius: 8px 8px 0 0; }\n    .content { padding: 20px; border: 1px solid #e0e0e0; border-top: none; }\n    .data { background: #fafafa; padding: 15px; border-radius: 4px; font-family: monospace; font-size: 12px; }\n    .buttons { margin-top: 20px; }\n    .btn { display: inline-block; padding: 12px 24px; margin-right: 10px; border-radius: 6px; text-decoration: none; font-weight: 500; }\n    .btn-approve { background: #22c55e; color: white; }\n    .btn-reject { background: #ef4444; color: white; }\n    .footer { margin-top: 20px; font-size: 12px; color: #666; }\n  </style>\n</head>\n<body>\n  <div class=\"container\">\n    <div class=\"header\">\n      <h2>${subject}</h2>\n    </div>\n    <div class=\"content\">\n      <p><strong>Execution ID:</strong> ${executionId}</p>\n      <p><strong>Approval Data:</strong></p>\n      <div class=\"data\">\n        <pre>${JSON.stringify(approvalData, null, 2)}</pre>\n      </div>\n      <div class=\"buttons\">\n        <a href=\"${approveUrl}\" class=\"btn btn-approve\">‚úì Approve</a>\n        <a href=\"${rejectUrl}\" class=\"btn btn-reject\">‚úó Reject</a>\n      </div>\n      <div class=\"footer\">\n        <p>This request will expire in ${Math.round(this.hitlConfig.timeout! / 3600000)} hours.</p>\n      </div>\n    </div>\n  </div>\n</body>\n</html>\n`\n\n    const textBody = `\nApproval Required\n=================\n\nExecution ID: ${executionId}\n\nApproval Data:\n${JSON.stringify(approvalData, null, 2)}\n\nActions:\n- Approve: ${approveUrl}\n- Reject: ${rejectUrl}\n\nThis request will expire in ${Math.round(this.hitlConfig.timeout! / 3600000)} hours.\n`\n\n    // Use MailChannels API (free for Cloudflare Workers)\n    // Or the configured email service\n    try {\n      const emailResponse = await fetch('https://api.mailchannels.net/tx/v1/send', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          personalizations: [{ to: [{ email: to }] }],\n          from: { email: from },\n          subject,\n          content: [\n            { type: 'text/plain', value: textBody },\n            { type: 'text/html', value: htmlBody },\n          ],\n        }),\n      })\n\n      if (!emailResponse.ok) {\n        const error = await emailResponse.text()\n        logger.error('Failed to send email notification', new Error(error), { executionId })\n      } else {\n        logger.info('Email notification sent', { executionId, to })\n      }\n    } catch (error) {\n      logger.error('Email notification failed', error instanceof Error ? error : undefined, {\n        executionId,\n      })\n    }\n  }\n\n  /**\n   * Send webhook notification\n   */\n  private async sendWebhookNotification(\n    executionId: string,\n    approvalData: Record<string, unknown>,\n    config: Record<string, unknown>\n  ): Promise<void> {\n    const webhookUrl = config.webhookUrl\n\n    if (!webhookUrl || typeof webhookUrl !== 'string') {\n      throw new Error('Webhook notification requires webhookUrl in notificationConfig')\n    }\n\n    const baseUrl = (config.baseUrl as string) || 'https://your-worker.workers.dev'\n\n    await fetch(webhookUrl, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        executionId,\n        approvalData,\n        callbackUrl: `${baseUrl}/callback/${executionId}`,\n        approveUrl: `${baseUrl}/callback/${executionId}?action=approve`,\n        rejectUrl: `${baseUrl}/callback/${executionId}?action=reject`,\n        expiresAt: Date.now() + this.hitlConfig.timeout!,\n      }),\n    })\n\n    logger.info('Webhook notification sent', { executionId, webhookUrl })\n  }\n\n  /**\n   * Generate a cryptographically secure unique execution ID\n   */\n  private generateExecutionId(): string {\n    return `hitl_${crypto.randomUUID()}`\n  }\n}\n"],"names":[],"mappings":";AAwBA,MAAM,SAAS,aAAa,EAAE,aAAa,cAAc;AAElD,MAAM,mBAAmB,UAAU;AAAA,EAGxC,YACE,QACiB,KACjB;AACA,UAAM,MAAM;AAFK,SAAA,MAAA;AAIjB,UAAM,MAAM,OAAO;AAEnB,SAAK,aAAa;AAAA,MAChB,QAAQ,KAAK,UAAU;AAAA,MACvB,SAAS,KAAK,WAAW;AAAA;AAAA,MACzB,qBAAqB,KAAK;AAAA,MAC1B,oBAAoB,KAAK;AAAA,IAAA;AAAA,EAE7B;AAAA,EAEA,MAAgB,IAAI,SAAqD;AACvE,UAAM,SAAS,KAAK,WAAW;AAE/B,YAAQ,QAAA;AAAA,MACN,KAAK;AACH,eAAO,MAAM,KAAK,mBAAmB,OAAO;AAAA,MAC9C,KAAK;AACH,eAAO,MAAM,KAAK,gBAAgB,OAAO;AAAA,MAC3C,KAAK;AACH,eAAO,MAAM,KAAK,iBAAiB,OAAO;AAAA,MAC5C,KAAK;AACH,eAAO,MAAM,KAAK,gBAAgB,OAAO;AAAA,MAC3C;AACE,cAAM,IAAI,MAAM,wBAAwB,MAAM,EAAE;AAAA,IAAA;AAAA,EAEtD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,mBAAmB,SAA4D;AAC3F,UAAM,QAAQ,QAAQ;AAEtB,QAAI,CAAC,MAAM,cAAc;AACvB,YAAM,IAAI,MAAM,iDAAiD;AAAA,IACnE;AAGA,QAAI,CAAC,KAAK,IAAI,YAAY;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MAAA;AAAA,IAEJ;AAGA,UAAM,QAAQ,KAAK,oBAAA;AACnB,UAAM,aAAa,KAAK,MAAM,KAAK,WAAW,UAAW,GAAI;AAC7D,UAAM,YAAY,KAAK,IAAA,IAAQ,KAAK,WAAW;AAK/C,UAAM,SAAS,QAAQ,cACnB,OAAO,QAAQ,gBAAgB,WAC7B,QAAQ,cACP,QAAQ,YAAkC,QAC7C;AAEJ,UAAM,iBAAiB;AAAA,MACrB,aAAa;AAAA,MACb,OAAO,QAAQ;AAAA,MACf,aAAa,KAAK,IAAA;AAAA,MAClB,aAAa;AAAA,IAAA;AAIf,UAAM,OAAO,KAAK,IAAI,WAAW,WAAW,KAAK;AACjD,UAAM,OAAO,KAAK,IAAI,WAAW,IAAI,IAAI;AAEzC,UAAM,WAAW,MAAM,KAAK;AAAA,MAC1B,IAAI,QAAQ,wBAAwB;AAAA,QAClC,QAAQ;AAAA,QACR,SAAS,EAAE,gBAAgB,mBAAA;AAAA,QAC3B,MAAM,KAAK,UAAU;AAAA,UACnB;AAAA,UACA;AAAA,UACA,KAAK;AAAA,QAAA,CACN;AAAA,MAAA,CACF;AAAA,IAAA;AAGH,QAAI,CAAC,SAAS,IAAI;AAChB,YAAM,QAAQ,MAAM,SAAS,KAAA;AAC7B,YAAM,IAAI,MAAM,gCAAgC,KAAK,EAAE;AAAA,IACzD;AAEA,WAAO,KAAK,oCAAoC;AAAA,MAC9C;AAAA,MACA;AAAA,MACA;AAAA,IAAA,CACD;AAGD,QAAI,KAAK,WAAW,qBAAqB;AACvC,YAAM,KAAK,iBAAiB,OAAO,MAAM,YAAY;AAAA,IACvD;AAGA,UAAM,UACH,KAAK,WAAW,oBAAoB,WAAsB;AAC7D,UAAM,cAAc,GAAG,OAAO,aAAa,KAAK;AAEhD,WAAO;AAAA,MACL,QAAQ;AAAA,MACR,aAAa;AAAA,MACb;AAAA,MACA;AAAA,IAAA;AAAA,EAEJ;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,gBAAgB,SAA2D;AACvF,UAAM,QAAQ,QAAQ;AAEtB,QAAI,CAAC,MAAM,aAAa;AACtB,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACjE;AAGA,QAAI,CAAC,KAAK,IAAI,YAAY;AACxB,YAAM,IAAI;AAAA,QACR;AAAA,MAAA;AAAA,IAEJ;AAGA,UAAM,OAAO,KAAK,IAAI,WAAW,WAAW,MAAM,WAAW;AAC7D,UAAM,OAAO,KAAK,IAAI,WAAW,IAAI,IAAI;AAGzC,UAAM,iBAAiB,MAAM,KAAK;AAAA,MAChC,IAAI,QAAQ,uBAAuB;AAAA,QACjC,QAAQ;AAAA,MAAA,CACT;AAAA,IAAA;AAGH,QAAI,CAAC,eAAe,IAAI;AACtB,UAAI,eAAe,WAAW,KAAK;AACjC,eAAO;AAAA,UACL,QAAQ;AAAA,UACR,aAAa,MAAM;AAAA,UACnB,UAAU;AAAA,QAAA;AAAA,MAEd;AACA,YAAM,QAAQ,MAAM,eAAe,KAAA;AACnC,YAAM,IAAI,MAAM,8BAA8B,KAAK,EAAE;AAAA,IACvD;AAEA,UAAM,eAAgB,MAAM,eAAe,KAAA;AAQ3C,QAAI,aAAa,WAAW,WAAW;AACrC,aAAO;AAAA,QACL,QAAQ,aAAa;AAAA,QACrB,aAAa,MAAM;AAAA,QACnB,UAAU,aAAa;AAAA,MAAA;AAAA,IAE3B;AAGA,QAAI,KAAK,QAAQ,aAAa,WAAW;AACvC,aAAO;AAAA,QACL,QAAQ;AAAA,QACR,aAAa,MAAM;AAAA,QACnB,UAAU;AAAA,MAAA;AAAA,IAEd;AAGA,QAAI,MAAM,UAAU;AAClB,YAAM,kBAAkB,MAAM,KAAK;AAAA,QACjC,IAAI,QAAQ,wBAAwB;AAAA,UAClC,QAAQ;AAAA,UACR,SAAS,EAAE,gBAAgB,mBAAA;AAAA,UAC3B,MAAM,KAAK,UAAU;AAAA,YACnB,OAAO,MAAM,SAAS;AAAA,YACtB,cAAc,MAAM;AAAA,UAAA,CACrB;AAAA,QAAA,CACF;AAAA,MAAA;AAGH,UAAI,CAAC,gBAAgB,IAAI;AACvB,cAAM,QAAQ,MAAM,gBAAgB,KAAA;AACpC,cAAM,IAAI,MAAM,sBAAsB,KAAK,EAAE;AAAA,MAC/C;AAEA,YAAM,SAAU,MAAM,gBAAgB,KAAA;AAKtC,aAAO,KAAK,sBAAsB,EAAE,aAAa,MAAM,aAAa;AAEpE,aAAO;AAAA,QACL,QAAQ;AAAA,QACR,aAAa,MAAM;AAAA,QACnB,OAAO,OAAO;AAAA,QACd,UAAU,MAAM;AAAA,MAAA;AAAA,IAEpB,OAAO;AACL,YAAM,iBAAiB,MAAM,KAAK;AAAA,QAChC,IAAI,QAAQ,uBAAuB;AAAA,UACjC,QAAQ;AAAA,UACR,SAAS,EAAE,gBAAgB,mBAAA;AAAA,UAC3B,MAAM,KAAK,UAAU;AAAA,YACnB,OAAO,MAAM,SAAS;AAAA,YACtB,QAAQ,MAAM;AAAA,UAAA,CACf;AAAA,QAAA,CACF;AAAA,MAAA;AAGH,UAAI,CAAC,eAAe,IAAI;AACtB,cAAM,QAAQ,MAAM,eAAe,KAAA;AACnC,cAAM,IAAI,MAAM,qBAAqB,KAAK,EAAE;AAAA,MAC9C;AAEA,aAAO,KAAK,sBAAsB,EAAE,aAAa,MAAM,aAAa;AAEpE,aAAO;AAAA,QACL,QAAQ;AAAA,QACR,aAAa,MAAM;AAAA,QACnB,UAAU,MAAM;AAAA,MAAA;AAAA,IAEpB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,iBAAiB,SAA2D;AACxF,UAAM,QAAQ,QAAQ;AACtB,WAAO,MAAM,KAAK,gBAAgB;AAAA,MAChC,GAAG;AAAA,MACH,OAAO,EAAE,GAAG,OAAO,UAAU,KAAA;AAAA,IAAK,CACnC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,gBAAgB,SAA2D;AACvF,UAAM,QAAQ,QAAQ;AACtB,WAAO,MAAM,KAAK,gBAAgB;AAAA,MAChC,GAAG;AAAA,MACH,OAAO,EAAE,GAAG,OAAO,UAAU,MAAA;AAAA,IAAM,CACpC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,iBACZ,aACA,cACe;AACf,UAAM,UAAU,KAAK,WAAW;AAChC,UAAM,SAAS,KAAK,WAAW,sBAAsB,CAAA;AAErD,YAAQ,SAAA;AAAA,MACN,KAAK;AACH,cAAM,KAAK,sBAAsB,aAAa,cAAc,MAAM;AAClE;AAAA,MACF,KAAK;AACH,cAAM,KAAK,sBAAsB,aAAa,cAAc,MAAM;AAClE;AAAA,MACF,KAAK;AACH,cAAM,KAAK,wBAAwB,aAAa,cAAc,MAAM;AACpE;AAAA,IAAA;AAAA,EAEN;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,sBACZ,aACA,cACA,QACe;AACf,UAAM,aAAa,OAAO;AAE1B,QAAI,CAAC,cAAc,OAAO,eAAe,UAAU;AACjD,YAAM,IAAI,MAAM,8DAA8D;AAAA,IAChF;AAEA,UAAM,UAAW,OAAO,WAAsB;AAC9C,UAAM,aAAa,GAAG,OAAO,aAAa,WAAW;AACrD,UAAM,YAAY,GAAG,OAAO,aAAa,WAAW;AAEpD,UAAM,UAAU;AAAA,MACd,MAAM;AAAA,MACN,QAAQ;AAAA,QACN;AAAA,UACE,MAAM;AAAA,UACN,MAAM;AAAA,YACJ,MAAM;AAAA,YACN,MAAM;AAAA,UAAA;AAAA,QACR;AAAA,QAEF;AAAA,UACE,MAAM;AAAA,UACN,MAAM;AAAA,YACJ,MAAM;AAAA,YACN,MAAM,qBAAqB,WAAW;AAAA;AAAA,QAAsB,KAAK,UAAU,cAAc,MAAM,CAAC,CAAC;AAAA,UAAA;AAAA,QACnG;AAAA,QAEF;AAAA,UACE,MAAM;AAAA,UACN,UAAU;AAAA,YACR;AAAA,cACE,MAAM;AAAA,cACN,MAAM;AAAA,gBACJ,MAAM;AAAA,gBACN,MAAM;AAAA,cAAA;AAAA,cAER,OAAO;AAAA,cACP,KAAK;AAAA,YAAA;AAAA,YAEP;AAAA,cACE,MAAM;AAAA,cACN,MAAM;AAAA,gBACJ,MAAM;AAAA,gBACN,MAAM;AAAA,cAAA;AAAA,cAER,OAAO;AAAA,cACP,KAAK;AAAA,YAAA;AAAA,UACP;AAAA,QACF;AAAA,QAEF;AAAA,UACE,MAAM;AAAA,UACN,UAAU;AAAA,YACR;AAAA,cACE,MAAM;AAAA,cACN,MAAM,iBAAiB,KAAK,MAAM,KAAK,WAAW,UAAW,IAAO,CAAC;AAAA,YAAA;AAAA,UACvE;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAGF,UAAM,MAAM,YAAY;AAAA,MACtB,QAAQ;AAAA,MACR,SAAS,EAAE,gBAAgB,mBAAA;AAAA,MAC3B,MAAM,KAAK,UAAU,OAAO;AAAA,IAAA,CAC7B;AAED,WAAO,KAAK,2BAA2B,EAAE,YAAA,CAAa;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,MAAc,sBACZ,aACA,cACA,QACe;AACf,UAAM,KAAK,OAAO;AAClB,UAAM,OAAO,OAAO;AACpB,UAAM,UAAW,OAAO,WAAsB;AAC9C,UAAM,UAAW,OAAO,WAAsB;AAE9C,QAAI,CAAC,MAAM,CAAC,MAAM;AAChB,aAAO,KAAK,wEAAwE;AAAA,QAClF;AAAA,MAAA,CACD;AACD;AAAA,IACF;AAGA,UAAM,aAAa,GAAG,OAAO,aAAa,WAAW;AACrD,UAAM,YAAY,GAAG,OAAO,aAAa,WAAW;AAGpD,UAAM,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAoBT,OAAO;AAAA;AAAA;AAAA,0CAGuB,WAAW;AAAA;AAAA;AAAA,eAGtC,KAAK,UAAU,cAAc,MAAM,CAAC,CAAC;AAAA;AAAA;AAAA,mBAGjC,UAAU;AAAA,mBACV,SAAS;AAAA;AAAA;AAAA,yCAGa,KAAK,MAAM,KAAK,WAAW,UAAW,IAAO,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQnF,UAAM,WAAW;AAAA;AAAA;AAAA;AAAA,gBAIL,WAAW;AAAA;AAAA;AAAA,EAGzB,KAAK,UAAU,cAAc,MAAM,CAAC,CAAC;AAAA;AAAA;AAAA,aAG1B,UAAU;AAAA,YACX,SAAS;AAAA;AAAA,8BAES,KAAK,MAAM,KAAK,WAAW,UAAW,IAAO,CAAC;AAAA;AAKxE,QAAI;AACF,YAAM,gBAAgB,MAAM,MAAM,2CAA2C;AAAA,QAC3E,QAAQ;AAAA,QACR,SAAS,EAAE,gBAAgB,mBAAA;AAAA,QAC3B,MAAM,KAAK,UAAU;AAAA,UACnB,kBAAkB,CAAC,EAAE,IAAI,CAAC,EAAE,OAAO,GAAA,CAAI,GAAG;AAAA,UAC1C,MAAM,EAAE,OAAO,KAAA;AAAA,UACf;AAAA,UACA,SAAS;AAAA,YACP,EAAE,MAAM,cAAc,OAAO,SAAA;AAAA,YAC7B,EAAE,MAAM,aAAa,OAAO,SAAA;AAAA,UAAS;AAAA,QACvC,CACD;AAAA,MAAA,CACF;AAED,UAAI,CAAC,cAAc,IAAI;AACrB,cAAM,QAAQ,MAAM,cAAc,KAAA;AAClC,eAAO,MAAM,qCAAqC,IAAI,MAAM,KAAK,GAAG,EAAE,aAAa;AAAA,MACrF,OAAO;AACL,eAAO,KAAK,2BAA2B,EAAE,aAAa,IAAI;AAAA,MAC5D;AAAA,IACF,SAAS,OAAO;AACd,aAAO,MAAM,6BAA6B,iBAAiB,QAAQ,QAAQ,QAAW;AAAA,QACpF;AAAA,MAAA,CACD;AAAA,IACH;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,wBACZ,aACA,cACA,QACe;AACf,UAAM,aAAa,OAAO;AAE1B,QAAI,CAAC,cAAc,OAAO,eAAe,UAAU;AACjD,YAAM,IAAI,MAAM,gEAAgE;AAAA,IAClF;AAEA,UAAM,UAAW,OAAO,WAAsB;AAE9C,UAAM,MAAM,YAAY;AAAA,MACtB,QAAQ;AAAA,MACR,SAAS,EAAE,gBAAgB,mBAAA;AAAA,MAC3B,MAAM,KAAK,UAAU;AAAA,QACnB;AAAA,QACA;AAAA,QACA,aAAa,GAAG,OAAO,aAAa,WAAW;AAAA,QAC/C,YAAY,GAAG,OAAO,aAAa,WAAW;AAAA,QAC9C,WAAW,GAAG,OAAO,aAAa,WAAW;AAAA,QAC7C,WAAW,KAAK,QAAQ,KAAK,WAAW;AAAA,MAAA,CACzC;AAAA,IAAA,CACF;AAED,WAAO,KAAK,6BAA6B,EAAE,aAAa,YAAY;AAAA,EACtE;AAAA;AAAA;AAAA;AAAA,EAKQ,sBAA8B;AACpC,WAAO,QAAQ,OAAO,WAAA,CAAY;AAAA,EACpC;AACF;"}