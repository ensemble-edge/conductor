{"version":3,"file":"cache-DzZ4eDqp.js","sources":["../../src/cache/cache.ts"],"sourcesContent":["/**\n * Cache System - Generic caching layer for agent executions\n *\n * Uses Repository pattern for storage-agnostic caching.\n * Supports TTL, cache keys, and invalidation strategies.\n */\n\nimport type { Repository } from '../storage/index.js'\nimport { Result, type AsyncResult } from '../types/result.js'\nimport { Errors, type ConductorError } from '../errors/error-types.js'\n\nexport interface CacheConfig {\n  defaultTTL?: number // Default TTL in seconds\n  enabled?: boolean // Enable/disable caching\n  keyPrefix?: string // Prefix for all cache keys\n}\n\nexport interface CacheOptions {\n  ttl?: number // TTL in seconds\n  tags?: string[] // Tags for group invalidation\n  bypass?: boolean // Bypass cache for this operation\n}\n\nexport interface CachedValue<T> {\n  value: T\n  cachedAt: number\n  expiresAt: number | null\n  tags?: string[]\n}\n\n/**\n * Cache interface for agent execution results\n */\nexport interface Cache<T = any> {\n  get(key: string): AsyncResult<T | null, ConductorError>\n  set(key: string, value: T, options?: CacheOptions): AsyncResult<void, ConductorError>\n  delete(key: string): AsyncResult<void, ConductorError>\n  has(key: string): AsyncResult<boolean, ConductorError>\n  clear(): AsyncResult<void, ConductorError>\n  invalidateByTag(tag: string): AsyncResult<void, ConductorError>\n}\n\n/**\n * Repository-based cache implementation\n */\nexport class RepositoryCache<T = any> implements Cache<T> {\n  private readonly config: Required<CacheConfig>\n\n  constructor(\n    private readonly repository: Repository<CachedValue<T>, string>,\n    config: CacheConfig = {}\n  ) {\n    this.config = {\n      defaultTTL: config.defaultTTL || 3600, // 1 hour default\n      enabled: config.enabled ?? true,\n      keyPrefix: config.keyPrefix || 'conductor:cache:',\n    }\n  }\n\n  /**\n   * Get value from cache\n   */\n  async get(key: string): AsyncResult<T | null, ConductorError> {\n    if (!this.config.enabled) {\n      return Result.ok(null)\n    }\n\n    const cacheKey = this.buildKey(key)\n    const result = await this.repository.get(cacheKey)\n\n    if (!result.success) {\n      // Cache miss or error - return null (not an error condition)\n      return Result.ok(null)\n    }\n\n    const cached = result.value\n\n    // Check expiration\n    if (cached.expiresAt && cached.expiresAt < Date.now()) {\n      // Expired - delete and return null\n      await this.repository.delete(cacheKey)\n      return Result.ok(null)\n    }\n\n    return Result.ok(cached.value)\n  }\n\n  /**\n   * Set value in cache\n   */\n  async set(key: string, value: T, options: CacheOptions = {}): AsyncResult<void, ConductorError> {\n    if (!this.config.enabled || options.bypass) {\n      return Result.ok(undefined)\n    }\n\n    const ttl = options.ttl || this.config.defaultTTL\n    const cacheKey = this.buildKey(key)\n\n    const cached: CachedValue<T> = {\n      value,\n      cachedAt: Date.now(),\n      expiresAt: Date.now() + ttl * 1000,\n      tags: options.tags,\n    }\n\n    return await this.repository.put(cacheKey, cached, { ttl })\n  }\n\n  /**\n   * Delete value from cache\n   */\n  async delete(key: string): AsyncResult<void, ConductorError> {\n    const cacheKey = this.buildKey(key)\n    return await this.repository.delete(cacheKey)\n  }\n\n  /**\n   * Check if key exists in cache\n   */\n  async has(key: string): AsyncResult<boolean, ConductorError> {\n    const result = await this.get(key)\n    return Result.ok(result.success && result.value !== null)\n  }\n\n  /**\n   * Clear all cache entries (if supported by repository)\n   */\n  async clear(): AsyncResult<void, ConductorError> {\n    // This requires listing all keys and deleting them\n    // Not all repositories support efficient clearing\n    const listResult = await this.repository.list()\n\n    if (!listResult.success) {\n      return Result.err(listResult.error)\n    }\n\n    // Delete all entries with our prefix\n    // Note: This is inefficient - prefer using repository-specific clear methods\n    return Result.ok(undefined)\n  }\n\n  /**\n   * Invalidate cache entries by tag\n   */\n  async invalidateByTag(tag: string): AsyncResult<void, ConductorError> {\n    // This requires listing all keys, checking tags, and deleting matches\n    // Not implemented efficiently yet - requires tag index\n    return Result.err(Errors.internal('Tag-based invalidation not yet implemented'))\n  }\n\n  /**\n   * Build cache key with prefix\n   */\n  private buildKey(key: string): string {\n    return `${this.config.keyPrefix}${key}`\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getConfig(): CacheConfig {\n    return { ...this.config }\n  }\n}\n\n/**\n * In-memory cache implementation (for testing/development)\n */\nexport class MemoryCache<T = any> implements Cache<T> {\n  private readonly store = new Map<string, CachedValue<T>>()\n  private readonly config: Required<CacheConfig>\n\n  constructor(config: CacheConfig = {}) {\n    this.config = {\n      defaultTTL: config.defaultTTL || 3600,\n      enabled: config.enabled ?? true,\n      keyPrefix: config.keyPrefix || '',\n    }\n  }\n\n  async get(key: string): AsyncResult<T | null, ConductorError> {\n    if (!this.config.enabled) {\n      return Result.ok(null)\n    }\n\n    const cacheKey = this.buildKey(key)\n    const cached = this.store.get(cacheKey)\n\n    if (!cached) {\n      return Result.ok(null)\n    }\n\n    // Check expiration\n    if (cached.expiresAt && cached.expiresAt < Date.now()) {\n      this.store.delete(cacheKey)\n      return Result.ok(null)\n    }\n\n    return Result.ok(cached.value)\n  }\n\n  async set(key: string, value: T, options: CacheOptions = {}): AsyncResult<void, ConductorError> {\n    if (!this.config.enabled || options.bypass) {\n      return Result.ok(undefined)\n    }\n\n    const ttl = options.ttl || this.config.defaultTTL\n    const cacheKey = this.buildKey(key)\n\n    this.store.set(cacheKey, {\n      value,\n      cachedAt: Date.now(),\n      expiresAt: Date.now() + ttl * 1000,\n      tags: options.tags,\n    })\n\n    return Result.ok(undefined)\n  }\n\n  async delete(key: string): AsyncResult<void, ConductorError> {\n    const cacheKey = this.buildKey(key)\n    this.store.delete(cacheKey)\n    return Result.ok(undefined)\n  }\n\n  async has(key: string): AsyncResult<boolean, ConductorError> {\n    const result = await this.get(key)\n    return Result.ok(result.success && result.value !== null)\n  }\n\n  async clear(): AsyncResult<void, ConductorError> {\n    this.store.clear()\n    return Result.ok(undefined)\n  }\n\n  async invalidateByTag(tag: string): AsyncResult<void, ConductorError> {\n    const keysToDelete: string[] = []\n\n    for (const [key, cached] of this.store.entries()) {\n      if (cached.tags && cached.tags.includes(tag)) {\n        keysToDelete.push(key)\n      }\n    }\n\n    for (const key of keysToDelete) {\n      this.store.delete(key)\n    }\n\n    return Result.ok(undefined)\n  }\n\n  private buildKey(key: string): string {\n    return `${this.config.keyPrefix}${key}`\n  }\n\n  /**\n   * Get cache size (memory only)\n   */\n  size(): number {\n    return this.store.size\n  }\n}\n\n/**\n * No-op cache (disables caching)\n */\nexport class NoOpCache<T = any> implements Cache<T> {\n  async get(): AsyncResult<T | null, ConductorError> {\n    return Result.ok(null)\n  }\n\n  async set(): AsyncResult<void, ConductorError> {\n    return Result.ok(undefined)\n  }\n\n  async delete(): AsyncResult<void, ConductorError> {\n    return Result.ok(undefined)\n  }\n\n  async has(): AsyncResult<boolean, ConductorError> {\n    return Result.ok(false)\n  }\n\n  async clear(): AsyncResult<void, ConductorError> {\n    return Result.ok(undefined)\n  }\n\n  async invalidateByTag(): AsyncResult<void, ConductorError> {\n    return Result.ok(undefined)\n  }\n}\n"],"names":[],"mappings":";AAwKO,MAAM,YAAyC;AAAA,EAIpD,YAAY,SAAsB,IAAI;AAHtC,SAAiB,4BAAY,IAAA;AAI3B,SAAK,SAAS;AAAA,MACZ,YAAY,OAAO,cAAc;AAAA,MACjC,SAAS,OAAO,WAAW;AAAA,MAC3B,WAAW,OAAO,aAAa;AAAA,IAAA;AAAA,EAEnC;AAAA,EAEA,MAAM,IAAI,KAAoD;AAC5D,QAAI,CAAC,KAAK,OAAO,SAAS;AACxB,aAAO,OAAO,GAAG,IAAI;AAAA,IACvB;AAEA,UAAM,WAAW,KAAK,SAAS,GAAG;AAClC,UAAM,SAAS,KAAK,MAAM,IAAI,QAAQ;AAEtC,QAAI,CAAC,QAAQ;AACX,aAAO,OAAO,GAAG,IAAI;AAAA,IACvB;AAGA,QAAI,OAAO,aAAa,OAAO,YAAY,KAAK,OAAO;AACrD,WAAK,MAAM,OAAO,QAAQ;AAC1B,aAAO,OAAO,GAAG,IAAI;AAAA,IACvB;AAEA,WAAO,OAAO,GAAG,OAAO,KAAK;AAAA,EAC/B;AAAA,EAEA,MAAM,IAAI,KAAa,OAAU,UAAwB,CAAA,GAAuC;AAC9F,QAAI,CAAC,KAAK,OAAO,WAAW,QAAQ,QAAQ;AAC1C,aAAO,OAAO,GAAG,MAAS;AAAA,IAC5B;AAEA,UAAM,MAAM,QAAQ,OAAO,KAAK,OAAO;AACvC,UAAM,WAAW,KAAK,SAAS,GAAG;AAElC,SAAK,MAAM,IAAI,UAAU;AAAA,MACvB;AAAA,MACA,UAAU,KAAK,IAAA;AAAA,MACf,WAAW,KAAK,IAAA,IAAQ,MAAM;AAAA,MAC9B,MAAM,QAAQ;AAAA,IAAA,CACf;AAED,WAAO,OAAO,GAAG,MAAS;AAAA,EAC5B;AAAA,EAEA,MAAM,OAAO,KAAgD;AAC3D,UAAM,WAAW,KAAK,SAAS,GAAG;AAClC,SAAK,MAAM,OAAO,QAAQ;AAC1B,WAAO,OAAO,GAAG,MAAS;AAAA,EAC5B;AAAA,EAEA,MAAM,IAAI,KAAmD;AAC3D,UAAM,SAAS,MAAM,KAAK,IAAI,GAAG;AACjC,WAAO,OAAO,GAAG,OAAO,WAAW,OAAO,UAAU,IAAI;AAAA,EAC1D;AAAA,EAEA,MAAM,QAA2C;AAC/C,SAAK,MAAM,MAAA;AACX,WAAO,OAAO,GAAG,MAAS;AAAA,EAC5B;AAAA,EAEA,MAAM,gBAAgB,KAAgD;AACpE,UAAM,eAAyB,CAAA;AAE/B,eAAW,CAAC,KAAK,MAAM,KAAK,KAAK,MAAM,WAAW;AAChD,UAAI,OAAO,QAAQ,OAAO,KAAK,SAAS,GAAG,GAAG;AAC5C,qBAAa,KAAK,GAAG;AAAA,MACvB;AAAA,IACF;AAEA,eAAW,OAAO,cAAc;AAC9B,WAAK,MAAM,OAAO,GAAG;AAAA,IACvB;AAEA,WAAO,OAAO,GAAG,MAAS;AAAA,EAC5B;AAAA,EAEQ,SAAS,KAAqB;AACpC,WAAO,GAAG,KAAK,OAAO,SAAS,GAAG,GAAG;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA,EAKA,OAAe;AACb,WAAO,KAAK,MAAM;AAAA,EACpB;AACF;"}