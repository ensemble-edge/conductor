import "cloudflare:workers";
const ALIAS = Symbol.for("yaml.alias");
const DOC = Symbol.for("yaml.document");
const MAP = Symbol.for("yaml.map");
const PAIR = Symbol.for("yaml.pair");
const SCALAR$1 = Symbol.for("yaml.scalar");
const SEQ = Symbol.for("yaml.seq");
const NODE_TYPE = Symbol.for("yaml.node.type");
const isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
const isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
const isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
const isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
const isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR$1;
const isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
function isCollection(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case MAP:
      case SEQ:
        return true;
    }
  return false;
}
function isNode(node) {
  if (node && typeof node === "object")
    switch (node[NODE_TYPE]) {
      case ALIAS:
      case MAP:
      case SCALAR$1:
      case SEQ:
        return true;
    }
  return false;
}
const hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
const BREAK = Symbol("break visit");
const SKIP = Symbol("skip children");
const REMOVE = Symbol("remove node");
function visit(node, visitor) {
  const visitor_ = initVisitor(visitor);
  if (isDocument(node)) {
    const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
    if (cd === REMOVE)
      node.contents = null;
  } else
    visit_(null, node, visitor_, Object.freeze([]));
}
visit.BREAK = BREAK;
visit.SKIP = SKIP;
visit.REMOVE = REMOVE;
function visit_(key, node, visitor, path) {
  const ctrl = callVisitor(key, node, visitor, path);
  if (isNode(ctrl) || isPair(ctrl)) {
    replaceNode(key, path, ctrl);
    return visit_(key, ctrl, visitor, path);
  }
  if (typeof ctrl !== "symbol") {
    if (isCollection(node)) {
      path = Object.freeze(path.concat(node));
      for (let i = 0; i < node.items.length; ++i) {
        const ci = visit_(i, node.items[i], visitor, path);
        if (typeof ci === "number")
          i = ci - 1;
        else if (ci === BREAK)
          return BREAK;
        else if (ci === REMOVE) {
          node.items.splice(i, 1);
          i -= 1;
        }
      }
    } else if (isPair(node)) {
      path = Object.freeze(path.concat(node));
      const ck = visit_("key", node.key, visitor, path);
      if (ck === BREAK)
        return BREAK;
      else if (ck === REMOVE)
        node.key = null;
      const cv = visit_("value", node.value, visitor, path);
      if (cv === BREAK)
        return BREAK;
      else if (cv === REMOVE)
        node.value = null;
    }
  }
  return ctrl;
}
function initVisitor(visitor) {
  if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
    return Object.assign({
      Alias: visitor.Node,
      Map: visitor.Node,
      Scalar: visitor.Node,
      Seq: visitor.Node
    }, visitor.Value && {
      Map: visitor.Value,
      Scalar: visitor.Value,
      Seq: visitor.Value
    }, visitor.Collection && {
      Map: visitor.Collection,
      Seq: visitor.Collection
    }, visitor);
  }
  return visitor;
}
function callVisitor(key, node, visitor, path) {
  if (typeof visitor === "function")
    return visitor(key, node, path);
  if (isMap(node))
    return visitor.Map?.(key, node, path);
  if (isSeq(node))
    return visitor.Seq?.(key, node, path);
  if (isPair(node))
    return visitor.Pair?.(key, node, path);
  if (isScalar(node))
    return visitor.Scalar?.(key, node, path);
  if (isAlias(node))
    return visitor.Alias?.(key, node, path);
  return void 0;
}
function replaceNode(key, path, node) {
  const parent = path[path.length - 1];
  if (isCollection(parent)) {
    parent.items[key] = node;
  } else if (isPair(parent)) {
    if (key === "key")
      parent.key = node;
    else
      parent.value = node;
  } else if (isDocument(parent)) {
    parent.contents = node;
  } else {
    const pt = isAlias(parent) ? "alias" : "scalar";
    throw new Error(`Cannot replace node with ${pt} parent`);
  }
}
const escapeChars = {
  "!": "%21",
  ",": "%2C",
  "[": "%5B",
  "]": "%5D",
  "{": "%7B",
  "}": "%7D"
};
const escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
class Directives {
  constructor(yaml, tags2) {
    this.docStart = null;
    this.docEnd = false;
    this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
    this.tags = Object.assign({}, Directives.defaultTags, tags2);
  }
  clone() {
    const copy = new Directives(this.yaml, this.tags);
    copy.docStart = this.docStart;
    return copy;
  }
  /**
   * During parsing, get a Directives instance for the current document and
   * update the stream state according to the current version's spec.
   */
  atDocument() {
    const res = new Directives(this.yaml, this.tags);
    switch (this.yaml.version) {
      case "1.1":
        this.atNextDocument = true;
        break;
      case "1.2":
        this.atNextDocument = false;
        this.yaml = {
          explicit: Directives.defaultYaml.explicit,
          version: "1.2"
        };
        this.tags = Object.assign({}, Directives.defaultTags);
        break;
    }
    return res;
  }
  /**
   * @param onError - May be called even if the action was successful
   * @returns `true` on success
   */
  add(line, onError) {
    if (this.atNextDocument) {
      this.yaml = { explicit: Directives.defaultYaml.explicit, version: "1.1" };
      this.tags = Object.assign({}, Directives.defaultTags);
      this.atNextDocument = false;
    }
    const parts = line.trim().split(/[ \t]+/);
    const name = parts.shift();
    switch (name) {
      case "%TAG": {
        if (parts.length !== 2) {
          onError(0, "%TAG directive should contain exactly two parts");
          if (parts.length < 2)
            return false;
        }
        const [handle, prefix] = parts;
        this.tags[handle] = prefix;
        return true;
      }
      case "%YAML": {
        this.yaml.explicit = true;
        if (parts.length !== 1) {
          onError(0, "%YAML directive should contain exactly one part");
          return false;
        }
        const [version] = parts;
        if (version === "1.1" || version === "1.2") {
          this.yaml.version = version;
          return true;
        } else {
          const isValid2 = /^\d+\.\d+$/.test(version);
          onError(6, `Unsupported YAML version ${version}`, isValid2);
          return false;
        }
      }
      default:
        onError(0, `Unknown directive ${name}`, true);
        return false;
    }
  }
  /**
   * Resolves a tag, matching handles to those defined in %TAG directives.
   *
   * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
   *   `'!local'` tag, or `null` if unresolvable.
   */
  tagName(source, onError) {
    if (source === "!")
      return "!";
    if (source[0] !== "!") {
      onError(`Not a valid tag: ${source}`);
      return null;
    }
    if (source[1] === "<") {
      const verbatim = source.slice(2, -1);
      if (verbatim === "!" || verbatim === "!!") {
        onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
        return null;
      }
      if (source[source.length - 1] !== ">")
        onError("Verbatim tags must end with a >");
      return verbatim;
    }
    const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
    if (!suffix)
      onError(`The ${source} tag has no suffix`);
    const prefix = this.tags[handle];
    if (prefix) {
      try {
        return prefix + decodeURIComponent(suffix);
      } catch (error) {
        onError(String(error));
        return null;
      }
    }
    if (handle === "!")
      return source;
    onError(`Could not resolve tag: ${source}`);
    return null;
  }
  /**
   * Given a fully resolved tag, returns its printable string form,
   * taking into account current tag prefixes and defaults.
   */
  tagString(tag2) {
    for (const [handle, prefix] of Object.entries(this.tags)) {
      if (tag2.startsWith(prefix))
        return handle + escapeTagName(tag2.substring(prefix.length));
    }
    return tag2[0] === "!" ? tag2 : `!<${tag2}>`;
  }
  toString(doc) {
    const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
    const tagEntries = Object.entries(this.tags);
    let tagNames;
    if (doc && tagEntries.length > 0 && isNode(doc.contents)) {
      const tags2 = {};
      visit(doc.contents, (_key, node) => {
        if (isNode(node) && node.tag)
          tags2[node.tag] = true;
      });
      tagNames = Object.keys(tags2);
    } else
      tagNames = [];
    for (const [handle, prefix] of tagEntries) {
      if (handle === "!!" && prefix === "tag:yaml.org,2002:")
        continue;
      if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
        lines.push(`%TAG ${handle} ${prefix}`);
    }
    return lines.join("\n");
  }
}
Directives.defaultYaml = { explicit: false, version: "1.2" };
Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
function anchorIsValid(anchor) {
  if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
    const sa = JSON.stringify(anchor);
    const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
    throw new Error(msg);
  }
  return true;
}
function anchorNames(root) {
  const anchors = /* @__PURE__ */ new Set();
  visit(root, {
    Value(_key, node) {
      if (node.anchor)
        anchors.add(node.anchor);
    }
  });
  return anchors;
}
function findNewAnchor(prefix, exclude) {
  for (let i = 1; true; ++i) {
    const name = `${prefix}${i}`;
    if (!exclude.has(name))
      return name;
  }
}
function createNodeAnchors(doc, prefix) {
  const aliasObjects = [];
  const sourceObjects = /* @__PURE__ */ new Map();
  let prevAnchors = null;
  return {
    onAnchor: (source) => {
      aliasObjects.push(source);
      prevAnchors ?? (prevAnchors = anchorNames(doc));
      const anchor = findNewAnchor(prefix, prevAnchors);
      prevAnchors.add(anchor);
      return anchor;
    },
    /**
     * With circular references, the source node is only resolved after all
     * of its child nodes are. This is why anchors are set only after all of
     * the nodes have been created.
     */
    setAnchors: () => {
      for (const source of aliasObjects) {
        const ref2 = sourceObjects.get(source);
        if (typeof ref2 === "object" && ref2.anchor && (isScalar(ref2.node) || isCollection(ref2.node))) {
          ref2.node.anchor = ref2.anchor;
        } else {
          const error = new Error("Failed to resolve repeated object (this should not happen)");
          error.source = source;
          throw error;
        }
      }
    },
    sourceObjects
  };
}
function applyReviver(reviver, obj, key, val) {
  if (val && typeof val === "object") {
    if (Array.isArray(val)) {
      for (let i = 0, len = val.length; i < len; ++i) {
        const v0 = val[i];
        const v1 = applyReviver(reviver, val, String(i), v0);
        if (v1 === void 0)
          delete val[i];
        else if (v1 !== v0)
          val[i] = v1;
      }
    } else if (val instanceof Map) {
      for (const k of Array.from(val.keys())) {
        const v0 = val.get(k);
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          val.delete(k);
        else if (v1 !== v0)
          val.set(k, v1);
      }
    } else if (val instanceof Set) {
      for (const v0 of Array.from(val)) {
        const v1 = applyReviver(reviver, val, v0, v0);
        if (v1 === void 0)
          val.delete(v0);
        else if (v1 !== v0) {
          val.delete(v0);
          val.add(v1);
        }
      }
    } else {
      for (const [k, v0] of Object.entries(val)) {
        const v1 = applyReviver(reviver, val, k, v0);
        if (v1 === void 0)
          delete val[k];
        else if (v1 !== v0)
          val[k] = v1;
      }
    }
  }
  return reviver.call(obj, key, val);
}
function toJS(value, arg, ctx) {
  if (Array.isArray(value))
    return value.map((v, i) => toJS(v, String(i), ctx));
  if (value && typeof value.toJSON === "function") {
    if (!ctx || !hasAnchor(value))
      return value.toJSON(arg, ctx);
    const data = { aliasCount: 0, count: 1, res: void 0 };
    ctx.anchors.set(value, data);
    ctx.onCreate = (res2) => {
      data.res = res2;
      delete ctx.onCreate;
    };
    const res = value.toJSON(arg, ctx);
    if (ctx.onCreate)
      ctx.onCreate(res);
    return res;
  }
  if (typeof value === "bigint" && !ctx?.keep)
    return Number(value);
  return value;
}
class NodeBase {
  constructor(type) {
    Object.defineProperty(this, NODE_TYPE, { value: type });
  }
  /** Create a copy of this node.  */
  clone() {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /** A plain JavaScript representation of this node. */
  toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    if (!isDocument(doc))
      throw new TypeError("A document argument is required");
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc,
      keep: true,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
    };
    const res = toJS(this, "", ctx);
    if (typeof onAnchor === "function")
      for (const { count, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
}
class Alias extends NodeBase {
  constructor(source) {
    super(ALIAS);
    this.source = source;
    Object.defineProperty(this, "tag", {
      set() {
        throw new Error("Alias nodes cannot have tags");
      }
    });
  }
  /**
   * Resolve the value of this alias within `doc`, finding the last
   * instance of the `source` anchor before this node.
   */
  resolve(doc, ctx) {
    let nodes;
    if (ctx?.aliasResolveCache) {
      nodes = ctx.aliasResolveCache;
    } else {
      nodes = [];
      visit(doc, {
        Node: (_key, node) => {
          if (isAlias(node) || hasAnchor(node))
            nodes.push(node);
        }
      });
      if (ctx)
        ctx.aliasResolveCache = nodes;
    }
    let found = void 0;
    for (const node of nodes) {
      if (node === this)
        break;
      if (node.anchor === this.source)
        found = node;
    }
    return found;
  }
  toJSON(_arg, ctx) {
    if (!ctx)
      return { source: this.source };
    const { anchors, doc, maxAliasCount } = ctx;
    const source = this.resolve(doc, ctx);
    if (!source) {
      const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
      throw new ReferenceError(msg);
    }
    let data = anchors.get(source);
    if (!data) {
      toJS(source, null, ctx);
      data = anchors.get(source);
    }
    if (!data || data.res === void 0) {
      const msg = "This should not happen: Alias anchor was not resolved?";
      throw new ReferenceError(msg);
    }
    if (maxAliasCount >= 0) {
      data.count += 1;
      if (data.aliasCount === 0)
        data.aliasCount = getAliasCount(doc, source, anchors);
      if (data.count * data.aliasCount > maxAliasCount) {
        const msg = "Excessive alias count indicates a resource exhaustion attack";
        throw new ReferenceError(msg);
      }
    }
    return data.res;
  }
  toString(ctx, _onComment, _onChompKeep) {
    const src = `*${this.source}`;
    if (ctx) {
      anchorIsValid(this.source);
      if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
        const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
        throw new Error(msg);
      }
      if (ctx.implicitKey)
        return `${src} `;
    }
    return src;
  }
}
function getAliasCount(doc, node, anchors) {
  if (isAlias(node)) {
    const source = node.resolve(doc);
    const anchor = anchors && source && anchors.get(source);
    return anchor ? anchor.count * anchor.aliasCount : 0;
  } else if (isCollection(node)) {
    let count = 0;
    for (const item of node.items) {
      const c = getAliasCount(doc, item, anchors);
      if (c > count)
        count = c;
    }
    return count;
  } else if (isPair(node)) {
    const kc = getAliasCount(doc, node.key, anchors);
    const vc = getAliasCount(doc, node.value, anchors);
    return Math.max(kc, vc);
  }
  return 1;
}
const isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
class Scalar extends NodeBase {
  constructor(value) {
    super(SCALAR$1);
    this.value = value;
  }
  toJSON(arg, ctx) {
    return ctx?.keep ? this.value : toJS(this.value, arg, ctx);
  }
  toString() {
    return String(this.value);
  }
}
Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
Scalar.PLAIN = "PLAIN";
Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
const defaultTagPrefix = "tag:yaml.org,2002:";
function findTagObject(value, tagName, tags2) {
  if (tagName) {
    const match = tags2.filter((t) => t.tag === tagName);
    const tagObj = match.find((t) => !t.format) ?? match[0];
    if (!tagObj)
      throw new Error(`Tag ${tagName} not found`);
    return tagObj;
  }
  return tags2.find((t) => t.identify?.(value) && !t.format);
}
function createNode(value, tagName, ctx) {
  if (isDocument(value))
    value = value.contents;
  if (isNode(value))
    return value;
  if (isPair(value)) {
    const map2 = ctx.schema[MAP].createNode?.(ctx.schema, null, ctx);
    map2.items.push(value);
    return map2;
  }
  if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
    value = value.valueOf();
  }
  const { aliasDuplicateObjects, onAnchor, onTagObj, schema: schema2, sourceObjects } = ctx;
  let ref2 = void 0;
  if (aliasDuplicateObjects && value && typeof value === "object") {
    ref2 = sourceObjects.get(value);
    if (ref2) {
      ref2.anchor ?? (ref2.anchor = onAnchor(value));
      return new Alias(ref2.anchor);
    } else {
      ref2 = { anchor: null, node: null };
      sourceObjects.set(value, ref2);
    }
  }
  if (tagName?.startsWith("!!"))
    tagName = defaultTagPrefix + tagName.slice(2);
  let tagObj = findTagObject(value, tagName, schema2.tags);
  if (!tagObj) {
    if (value && typeof value.toJSON === "function") {
      value = value.toJSON();
    }
    if (!value || typeof value !== "object") {
      const node2 = new Scalar(value);
      if (ref2)
        ref2.node = node2;
      return node2;
    }
    tagObj = value instanceof Map ? schema2[MAP] : Symbol.iterator in Object(value) ? schema2[SEQ] : schema2[MAP];
  }
  if (onTagObj) {
    onTagObj(tagObj);
    delete ctx.onTagObj;
  }
  const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar(value);
  if (tagName)
    node.tag = tagName;
  else if (!tagObj.default)
    node.tag = tagObj.tag;
  if (ref2)
    ref2.node = node;
  return node;
}
function collectionFromPath(schema2, path, value) {
  let v = value;
  for (let i = path.length - 1; i >= 0; --i) {
    const k = path[i];
    if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
      const a = [];
      a[k] = v;
      v = a;
    } else {
      v = /* @__PURE__ */ new Map([[k, v]]);
    }
  }
  return createNode(v, void 0, {
    aliasDuplicateObjects: false,
    keepUndefined: false,
    onAnchor: () => {
      throw new Error("This should not happen, please report a bug.");
    },
    schema: schema2,
    sourceObjects: /* @__PURE__ */ new Map()
  });
}
const isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;
class Collection extends NodeBase {
  constructor(type, schema2) {
    super(type);
    Object.defineProperty(this, "schema", {
      value: schema2,
      configurable: true,
      enumerable: false,
      writable: true
    });
  }
  /**
   * Create a copy of this collection.
   *
   * @param schema - If defined, overwrites the original's schema
   */
  clone(schema2) {
    const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
    if (schema2)
      copy.schema = schema2;
    copy.items = copy.items.map((it) => isNode(it) || isPair(it) ? it.clone(schema2) : it);
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /**
   * Adds a value to the collection. For `!!map` and `!!omap` the value must
   * be a Pair instance or a `{ key, value }` object, which may not have a key
   * that already exists in the map.
   */
  addIn(path, value) {
    if (isEmptyPath(path))
      this.add(value);
    else {
      const [key, ...rest] = path;
      const node = this.get(key, true);
      if (isCollection(node))
        node.addIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
  /**
   * Removes a value from the collection.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path) {
    const [key, ...rest] = path;
    if (rest.length === 0)
      return this.delete(key);
    const node = this.get(key, true);
    if (isCollection(node))
      return node.deleteIn(rest);
    else
      throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path, keepScalar) {
    const [key, ...rest] = path;
    const node = this.get(key, true);
    if (rest.length === 0)
      return !keepScalar && isScalar(node) ? node.value : node;
    else
      return isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
  }
  hasAllNullValues(allowScalar) {
    return this.items.every((node) => {
      if (!isPair(node))
        return false;
      const n = node.value;
      return n == null || allowScalar && isScalar(n) && n.value == null && !n.commentBefore && !n.comment && !n.tag;
    });
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   */
  hasIn(path) {
    const [key, ...rest] = path;
    if (rest.length === 0)
      return this.has(key);
    const node = this.get(key, true);
    return isCollection(node) ? node.hasIn(rest) : false;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path, value) {
    const [key, ...rest] = path;
    if (rest.length === 0) {
      this.set(key, value);
    } else {
      const node = this.get(key, true);
      if (isCollection(node))
        node.setIn(rest, value);
      else if (node === void 0 && this.schema)
        this.set(key, collectionFromPath(this.schema, rest, value));
      else
        throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
  }
}
const stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
function indentComment(comment, indent) {
  if (/^\n+$/.test(comment))
    return comment.substring(1);
  return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
const lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
const FOLD_FLOW = "flow";
const FOLD_BLOCK = "block";
const FOLD_QUOTED = "quoted";
function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
  if (!lineWidth || lineWidth < 0)
    return text;
  if (lineWidth < minContentWidth)
    minContentWidth = 0;
  const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
  if (text.length <= endStep)
    return text;
  const folds = [];
  const escapedFolds = {};
  let end = lineWidth - indent.length;
  if (typeof indentAtStart === "number") {
    if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
      folds.push(0);
    else
      end = lineWidth - indentAtStart;
  }
  let split2 = void 0;
  let prev = void 0;
  let overflow = false;
  let i = -1;
  let escStart = -1;
  let escEnd = -1;
  if (mode === FOLD_BLOCK) {
    i = consumeMoreIndentedLines(text, i, indent.length);
    if (i !== -1)
      end = i + endStep;
  }
  for (let ch; ch = text[i += 1]; ) {
    if (mode === FOLD_QUOTED && ch === "\\") {
      escStart = i;
      switch (text[i + 1]) {
        case "x":
          i += 3;
          break;
        case "u":
          i += 5;
          break;
        case "U":
          i += 9;
          break;
        default:
          i += 1;
      }
      escEnd = i;
    }
    if (ch === "\n") {
      if (mode === FOLD_BLOCK)
        i = consumeMoreIndentedLines(text, i, indent.length);
      end = i + indent.length + endStep;
      split2 = void 0;
    } else {
      if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
        const next = text[i + 1];
        if (next && next !== " " && next !== "\n" && next !== "	")
          split2 = i;
      }
      if (i >= end) {
        if (split2) {
          folds.push(split2);
          end = split2 + endStep;
          split2 = void 0;
        } else if (mode === FOLD_QUOTED) {
          while (prev === " " || prev === "	") {
            prev = ch;
            ch = text[i += 1];
            overflow = true;
          }
          const j = i > escEnd + 1 ? i - 2 : escStart - 1;
          if (escapedFolds[j])
            return text;
          folds.push(j);
          escapedFolds[j] = true;
          end = j + endStep;
          split2 = void 0;
        } else {
          overflow = true;
        }
      }
    }
    prev = ch;
  }
  if (overflow && onOverflow)
    onOverflow();
  if (folds.length === 0)
    return text;
  if (onFold)
    onFold();
  let res = text.slice(0, folds[0]);
  for (let i2 = 0; i2 < folds.length; ++i2) {
    const fold = folds[i2];
    const end2 = folds[i2 + 1] || text.length;
    if (fold === 0)
      res = `
${indent}${text.slice(0, end2)}`;
    else {
      if (mode === FOLD_QUOTED && escapedFolds[fold])
        res += `${text[fold]}\\`;
      res += `
${indent}${text.slice(fold + 1, end2)}`;
    }
  }
  return res;
}
function consumeMoreIndentedLines(text, i, indent) {
  let end = i;
  let start = i + 1;
  let ch = text[start];
  while (ch === " " || ch === "	") {
    if (i < start + indent) {
      ch = text[++i];
    } else {
      do {
        ch = text[++i];
      } while (ch && ch !== "\n");
      end = i;
      start = i + 1;
      ch = text[start];
    }
  }
  return end;
}
const getFoldOptions = (ctx, isBlock2) => ({
  indentAtStart: isBlock2 ? ctx.indent.length : ctx.indentAtStart,
  lineWidth: ctx.options.lineWidth,
  minContentWidth: ctx.options.minContentWidth
});
const containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
  if (!lineWidth || lineWidth < 0)
    return false;
  const limit2 = lineWidth - indentLength;
  const strLen = str.length;
  if (strLen <= limit2)
    return false;
  for (let i = 0, start = 0; i < strLen; ++i) {
    if (str[i] === "\n") {
      if (i - start > limit2)
        return true;
      start = i + 1;
      if (strLen - start <= limit2)
        return false;
    }
  }
  return true;
}
function doubleQuotedString(value, ctx) {
  const json2 = JSON.stringify(value);
  if (ctx.options.doubleQuotedAsJSON)
    return json2;
  const { implicitKey } = ctx;
  const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  let str = "";
  let start = 0;
  for (let i = 0, ch = json2[i]; ch; ch = json2[++i]) {
    if (ch === " " && json2[i + 1] === "\\" && json2[i + 2] === "n") {
      str += json2.slice(start, i) + "\\ ";
      i += 1;
      start = i;
      ch = "\\";
    }
    if (ch === "\\")
      switch (json2[i + 1]) {
        case "u":
          {
            str += json2.slice(start, i);
            const code = json2.substr(i + 2, 4);
            switch (code) {
              case "0000":
                str += "\\0";
                break;
              case "0007":
                str += "\\a";
                break;
              case "000b":
                str += "\\v";
                break;
              case "001b":
                str += "\\e";
                break;
              case "0085":
                str += "\\N";
                break;
              case "00a0":
                str += "\\_";
                break;
              case "2028":
                str += "\\L";
                break;
              case "2029":
                str += "\\P";
                break;
              default:
                if (code.substr(0, 2) === "00")
                  str += "\\x" + code.substr(2);
                else
                  str += json2.substr(i, 6);
            }
            i += 5;
            start = i + 1;
          }
          break;
        case "n":
          if (implicitKey || json2[i + 2] === '"' || json2.length < minMultiLineLength) {
            i += 1;
          } else {
            str += json2.slice(start, i) + "\n\n";
            while (json2[i + 2] === "\\" && json2[i + 3] === "n" && json2[i + 4] !== '"') {
              str += "\n";
              i += 2;
            }
            str += indent;
            if (json2[i + 2] === " ")
              str += "\\";
            i += 1;
            start = i + 1;
          }
          break;
        default:
          i += 1;
      }
  }
  str = start ? str + json2.slice(start) : json2;
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_QUOTED, getFoldOptions(ctx, false));
}
function singleQuotedString(value, ctx) {
  if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
    return doubleQuotedString(value, ctx);
  const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
  const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
  return ctx.implicitKey ? res : foldFlowLines(res, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function quotedString(value, ctx) {
  const { singleQuote } = ctx.options;
  let qs;
  if (singleQuote === false)
    qs = doubleQuotedString;
  else {
    const hasDouble = value.includes('"');
    const hasSingle = value.includes("'");
    if (hasDouble && !hasSingle)
      qs = singleQuotedString;
    else if (hasSingle && !hasDouble)
      qs = doubleQuotedString;
    else
      qs = singleQuote ? singleQuotedString : doubleQuotedString;
  }
  return qs(value, ctx);
}
let blockEndNewlines;
try {
  blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
} catch {
  blockEndNewlines = /\n+(?!\n|$)/g;
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
  const { blockQuote, commentString, lineWidth } = ctx.options;
  if (!blockQuote || /\n[\t ]+$/.test(value)) {
    return quotedString(value, ctx);
  }
  const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
  const literal = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.BLOCK_FOLDED ? false : type === Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
  if (!value)
    return literal ? "|\n" : ">\n";
  let chomp;
  let endStart;
  for (endStart = value.length; endStart > 0; --endStart) {
    const ch = value[endStart - 1];
    if (ch !== "\n" && ch !== "	" && ch !== " ")
      break;
  }
  let end = value.substring(endStart);
  const endNlPos = end.indexOf("\n");
  if (endNlPos === -1) {
    chomp = "-";
  } else if (value === end || endNlPos !== end.length - 1) {
    chomp = "+";
    if (onChompKeep)
      onChompKeep();
  } else {
    chomp = "";
  }
  if (end) {
    value = value.slice(0, -end.length);
    if (end[end.length - 1] === "\n")
      end = end.slice(0, -1);
    end = end.replace(blockEndNewlines, `$&${indent}`);
  }
  let startWithSpace = false;
  let startEnd;
  let startNlPos = -1;
  for (startEnd = 0; startEnd < value.length; ++startEnd) {
    const ch = value[startEnd];
    if (ch === " ")
      startWithSpace = true;
    else if (ch === "\n")
      startNlPos = startEnd;
    else
      break;
  }
  let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
  if (start) {
    value = value.substring(start.length);
    start = start.replace(/\n+/g, `$&${indent}`);
  }
  const indentSize = indent ? "2" : "1";
  let header = (startWithSpace ? indentSize : "") + chomp;
  if (comment) {
    header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
    if (onComment)
      onComment();
  }
  if (!literal) {
    const foldedValue = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
    let literalFallback = false;
    const foldOptions = getFoldOptions(ctx, true);
    if (blockQuote !== "folded" && type !== Scalar.BLOCK_FOLDED) {
      foldOptions.onOverflow = () => {
        literalFallback = true;
      };
    }
    const body = foldFlowLines(`${start}${foldedValue}${end}`, indent, FOLD_BLOCK, foldOptions);
    if (!literalFallback)
      return `>${header}
${indent}${body}`;
  }
  value = value.replace(/\n+/g, `$&${indent}`);
  return `|${header}
${indent}${start}${value}${end}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
  const { type, value } = item;
  const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
  if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) {
    return quotedString(value, ctx);
  }
  if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
    return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
  }
  if (!implicitKey && !inFlow && type !== Scalar.PLAIN && value.includes("\n")) {
    return blockString(item, ctx, onComment, onChompKeep);
  }
  if (containsDocumentMarker(value)) {
    if (indent === "") {
      ctx.forceBlockIndent = true;
      return blockString(item, ctx, onComment, onChompKeep);
    } else if (implicitKey && indent === indentStep) {
      return quotedString(value, ctx);
    }
  }
  const str = value.replace(/\n+/g, `$&
${indent}`);
  if (actualString) {
    const test = (tag2) => tag2.default && tag2.tag !== "tag:yaml.org,2002:str" && tag2.test?.test(str);
    const { compat, tags: tags2 } = ctx.doc.schema;
    if (tags2.some(test) || compat?.some(test))
      return quotedString(value, ctx);
  }
  return implicitKey ? str : foldFlowLines(str, indent, FOLD_FLOW, getFoldOptions(ctx, false));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
  const { implicitKey, inFlow } = ctx;
  const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
  let { type } = item;
  if (type !== Scalar.QUOTE_DOUBLE) {
    if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
      type = Scalar.QUOTE_DOUBLE;
  }
  const _stringify = (_type) => {
    switch (_type) {
      case Scalar.BLOCK_FOLDED:
      case Scalar.BLOCK_LITERAL:
        return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
      case Scalar.QUOTE_DOUBLE:
        return doubleQuotedString(ss.value, ctx);
      case Scalar.QUOTE_SINGLE:
        return singleQuotedString(ss.value, ctx);
      case Scalar.PLAIN:
        return plainString(ss, ctx, onComment, onChompKeep);
      default:
        return null;
    }
  };
  let res = _stringify(type);
  if (res === null) {
    const { defaultKeyType, defaultStringType } = ctx.options;
    const t = implicitKey && defaultKeyType || defaultStringType;
    res = _stringify(t);
    if (res === null)
      throw new Error(`Unsupported default string type ${t}`);
  }
  return res;
}
function createStringifyContext(doc, options) {
  const opt = Object.assign({
    blockQuote: true,
    commentString: stringifyComment,
    defaultKeyType: null,
    defaultStringType: "PLAIN",
    directives: null,
    doubleQuotedAsJSON: false,
    doubleQuotedMinMultiLineLength: 40,
    falseStr: "false",
    flowCollectionPadding: true,
    indentSeq: true,
    lineWidth: 80,
    minContentWidth: 20,
    nullStr: "null",
    simpleKeys: false,
    singleQuote: null,
    trueStr: "true",
    verifyAliasOrder: true
  }, doc.schema.toStringOptions, options);
  let inFlow;
  switch (opt.collectionStyle) {
    case "block":
      inFlow = false;
      break;
    case "flow":
      inFlow = true;
      break;
    default:
      inFlow = null;
  }
  return {
    anchors: /* @__PURE__ */ new Set(),
    doc,
    flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
    indent: "",
    indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
    inFlow,
    options: opt
  };
}
function getTagObject(tags2, item) {
  if (item.tag) {
    const match = tags2.filter((t) => t.tag === item.tag);
    if (match.length > 0)
      return match.find((t) => t.format === item.format) ?? match[0];
  }
  let tagObj = void 0;
  let obj;
  if (isScalar(item)) {
    obj = item.value;
    let match = tags2.filter((t) => t.identify?.(obj));
    if (match.length > 1) {
      const testMatch = match.filter((t) => t.test);
      if (testMatch.length > 0)
        match = testMatch;
    }
    tagObj = match.find((t) => t.format === item.format) ?? match.find((t) => !t.format);
  } else {
    obj = item;
    tagObj = tags2.find((t) => t.nodeClass && obj instanceof t.nodeClass);
  }
  if (!tagObj) {
    const name = obj?.constructor?.name ?? (obj === null ? "null" : typeof obj);
    throw new Error(`Tag not resolved for ${name} value`);
  }
  return tagObj;
}
function stringifyProps(node, tagObj, { anchors, doc }) {
  if (!doc.directives)
    return "";
  const props = [];
  const anchor = (isScalar(node) || isCollection(node)) && node.anchor;
  if (anchor && anchorIsValid(anchor)) {
    anchors.add(anchor);
    props.push(`&${anchor}`);
  }
  const tag2 = node.tag ?? (tagObj.default ? null : tagObj.tag);
  if (tag2)
    props.push(doc.directives.tagString(tag2));
  return props.join(" ");
}
function stringify$1(item, ctx, onComment, onChompKeep) {
  if (isPair(item))
    return item.toString(ctx, onComment, onChompKeep);
  if (isAlias(item)) {
    if (ctx.doc.directives)
      return item.toString(ctx);
    if (ctx.resolvedAliases?.has(item)) {
      throw new TypeError(`Cannot stringify circular structure without alias nodes`);
    } else {
      if (ctx.resolvedAliases)
        ctx.resolvedAliases.add(item);
      else
        ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
      item = item.resolve(ctx.doc);
    }
  }
  let tagObj = void 0;
  const node = isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
  tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));
  const props = stringifyProps(node, tagObj, ctx);
  if (props.length > 0)
    ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
  const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : isScalar(node) ? stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
  if (!props)
    return str;
  return isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
}
function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
  const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
  let keyComment = isNode(key) && key.comment || null;
  if (simpleKeys) {
    if (keyComment) {
      throw new Error("With simple keys, key nodes cannot have comments");
    }
    if (isCollection(key) || !isNode(key) && typeof key === "object") {
      const msg = "With simple keys, collection cannot be used as a key value";
      throw new Error(msg);
    }
  }
  let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || isCollection(key) || (isScalar(key) ? key.type === Scalar.BLOCK_FOLDED || key.type === Scalar.BLOCK_LITERAL : typeof key === "object"));
  ctx = Object.assign({}, ctx, {
    allNullValues: false,
    implicitKey: !explicitKey && (simpleKeys || !allNullValues),
    indent: indent + indentStep
  });
  let keyCommentDone = false;
  let chompKeep = false;
  let str = stringify$1(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
  if (!explicitKey && !ctx.inFlow && str.length > 1024) {
    if (simpleKeys)
      throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
    explicitKey = true;
  }
  if (ctx.inFlow) {
    if (allNullValues || value == null) {
      if (keyCommentDone && onComment)
        onComment();
      return str === "" ? "?" : explicitKey ? `? ${str}` : str;
    }
  } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
    str = `? ${str}`;
    if (keyComment && !keyCommentDone) {
      str += lineComment(str, ctx.indent, commentString(keyComment));
    } else if (chompKeep && onChompKeep)
      onChompKeep();
    return str;
  }
  if (keyCommentDone)
    keyComment = null;
  if (explicitKey) {
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
    str = `? ${str}
${indent}:`;
  } else {
    str = `${str}:`;
    if (keyComment)
      str += lineComment(str, ctx.indent, commentString(keyComment));
  }
  let vsb, vcb, valueComment;
  if (isNode(value)) {
    vsb = !!value.spaceBefore;
    vcb = value.commentBefore;
    valueComment = value.comment;
  } else {
    vsb = false;
    vcb = null;
    valueComment = null;
    if (value && typeof value === "object")
      value = doc.createNode(value);
  }
  ctx.implicitKey = false;
  if (!explicitKey && !keyComment && isScalar(value))
    ctx.indentAtStart = str.length + 1;
  chompKeep = false;
  if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && isSeq(value) && !value.flow && !value.tag && !value.anchor) {
    ctx.indent = ctx.indent.substring(2);
  }
  let valueCommentDone = false;
  const valueStr = stringify$1(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
  let ws = " ";
  if (keyComment || vsb || vcb) {
    ws = vsb ? "\n" : "";
    if (vcb) {
      const cs = commentString(vcb);
      ws += `
${indentComment(cs, ctx.indent)}`;
    }
    if (valueStr === "" && !ctx.inFlow) {
      if (ws === "\n")
        ws = "\n\n";
    } else {
      ws += `
${ctx.indent}`;
    }
  } else if (!explicitKey && isCollection(value)) {
    const vs0 = valueStr[0];
    const nl0 = valueStr.indexOf("\n");
    const hasNewline = nl0 !== -1;
    const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
    if (hasNewline || !flow) {
      let hasPropsLine = false;
      if (hasNewline && (vs0 === "&" || vs0 === "!")) {
        let sp0 = valueStr.indexOf(" ");
        if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
          sp0 = valueStr.indexOf(" ", sp0 + 1);
        }
        if (sp0 === -1 || nl0 < sp0)
          hasPropsLine = true;
      }
      if (!hasPropsLine)
        ws = `
${ctx.indent}`;
    }
  } else if (valueStr === "" || valueStr[0] === "\n") {
    ws = "";
  }
  str += ws + valueStr;
  if (ctx.inFlow) {
    if (valueCommentDone && onComment)
      onComment();
  } else if (valueComment && !valueCommentDone) {
    str += lineComment(str, ctx.indent, commentString(valueComment));
  } else if (chompKeep && onChompKeep) {
    onChompKeep();
  }
  return str;
}
function warn(logLevel, warning) {
  if (logLevel === "debug" || logLevel === "warn") {
    console.warn(warning);
  }
}
const MERGE_KEY = "<<";
const merge = {
  identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
  default: "key",
  tag: "tag:yaml.org,2002:merge",
  test: /^<<$/,
  resolve: () => Object.assign(new Scalar(Symbol(MERGE_KEY)), {
    addToJSMap: addMergeToJSMap
  }),
  stringify: () => MERGE_KEY
};
const isMergeKey = (ctx, key) => (merge.identify(key) || isScalar(key) && (!key.type || key.type === Scalar.PLAIN) && merge.identify(key.value)) && ctx?.doc.schema.tags.some((tag2) => tag2.tag === merge.tag && tag2.default);
function addMergeToJSMap(ctx, map2, value) {
  value = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (isSeq(value))
    for (const it of value.items)
      mergeValue(ctx, map2, it);
  else if (Array.isArray(value))
    for (const it of value)
      mergeValue(ctx, map2, it);
  else
    mergeValue(ctx, map2, value);
}
function mergeValue(ctx, map2, value) {
  const source = ctx && isAlias(value) ? value.resolve(ctx.doc) : value;
  if (!isMap(source))
    throw new Error("Merge sources must be maps or map aliases");
  const srcMap = source.toJSON(null, ctx, Map);
  for (const [key, value2] of srcMap) {
    if (map2 instanceof Map) {
      if (!map2.has(key))
        map2.set(key, value2);
    } else if (map2 instanceof Set) {
      map2.add(key);
    } else if (!Object.prototype.hasOwnProperty.call(map2, key)) {
      Object.defineProperty(map2, key, {
        value: value2,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }
  return map2;
}
function addPairToJSMap(ctx, map2, { key, value }) {
  if (isNode(key) && key.addToJSMap)
    key.addToJSMap(ctx, map2, value);
  else if (isMergeKey(ctx, key))
    addMergeToJSMap(ctx, map2, value);
  else {
    const jsKey = toJS(key, "", ctx);
    if (map2 instanceof Map) {
      map2.set(jsKey, toJS(value, jsKey, ctx));
    } else if (map2 instanceof Set) {
      map2.add(jsKey);
    } else {
      const stringKey = stringifyKey(key, jsKey, ctx);
      const jsValue = toJS(value, stringKey, ctx);
      if (stringKey in map2)
        Object.defineProperty(map2, stringKey, {
          value: jsValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      else
        map2[stringKey] = jsValue;
    }
  }
  return map2;
}
function stringifyKey(key, jsKey, ctx) {
  if (jsKey === null)
    return "";
  if (typeof jsKey !== "object")
    return String(jsKey);
  if (isNode(key) && ctx?.doc) {
    const strCtx = createStringifyContext(ctx.doc, {});
    strCtx.anchors = /* @__PURE__ */ new Set();
    for (const node of ctx.anchors.keys())
      strCtx.anchors.add(node.anchor);
    strCtx.inFlow = true;
    strCtx.inStringifyKey = true;
    const strKey = key.toString(strCtx);
    if (!ctx.mapKeyWarned) {
      let jsonStr = JSON.stringify(strKey);
      if (jsonStr.length > 40)
        jsonStr = jsonStr.substring(0, 36) + '..."';
      warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
      ctx.mapKeyWarned = true;
    }
    return strKey;
  }
  return JSON.stringify(jsKey);
}
function createPair(key, value, ctx) {
  const k = createNode(key, void 0, ctx);
  const v = createNode(value, void 0, ctx);
  return new Pair(k, v);
}
class Pair {
  constructor(key, value = null) {
    Object.defineProperty(this, NODE_TYPE, { value: PAIR });
    this.key = key;
    this.value = value;
  }
  clone(schema2) {
    let { key, value } = this;
    if (isNode(key))
      key = key.clone(schema2);
    if (isNode(value))
      value = value.clone(schema2);
    return new Pair(key, value);
  }
  toJSON(_, ctx) {
    const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
    return addPairToJSMap(ctx, pair, this);
  }
  toString(ctx, onComment, onChompKeep) {
    return ctx?.doc ? stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
  }
}
function stringifyCollection(collection, ctx, options) {
  const flow = ctx.inFlow ?? collection.flow;
  const stringify2 = flow ? stringifyFlowCollection : stringifyBlockCollection;
  return stringify2(collection, ctx, options);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
  const { indent, options: { commentString } } = ctx;
  const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
  let chompKeep = false;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment2 = null;
    if (isNode(item)) {
      if (!chompKeep && item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
      if (item.comment)
        comment2 = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (!chompKeep && ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
      }
    }
    chompKeep = false;
    let str2 = stringify$1(item, itemCtx, () => comment2 = null, () => chompKeep = true);
    if (comment2)
      str2 += lineComment(str2, itemIndent, commentString(comment2));
    if (chompKeep && comment2)
      chompKeep = false;
    lines.push(blockItemPrefix + str2);
  }
  let str;
  if (lines.length === 0) {
    str = flowChars.start + flowChars.end;
  } else {
    str = lines[0];
    for (let i = 1; i < lines.length; ++i) {
      const line = lines[i];
      str += line ? `
${indent}${line}` : "\n";
    }
  }
  if (comment) {
    str += "\n" + indentComment(commentString(comment), indent);
    if (onComment)
      onComment();
  } else if (chompKeep && onChompKeep)
    onChompKeep();
  return str;
}
function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
  const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
  itemIndent += indentStep;
  const itemCtx = Object.assign({}, ctx, {
    indent: itemIndent,
    inFlow: true,
    type: null
  });
  let reqNewline = false;
  let linesAtValue = 0;
  const lines = [];
  for (let i = 0; i < items.length; ++i) {
    const item = items[i];
    let comment = null;
    if (isNode(item)) {
      if (item.spaceBefore)
        lines.push("");
      addCommentBefore(ctx, lines, item.commentBefore, false);
      if (item.comment)
        comment = item.comment;
    } else if (isPair(item)) {
      const ik = isNode(item.key) ? item.key : null;
      if (ik) {
        if (ik.spaceBefore)
          lines.push("");
        addCommentBefore(ctx, lines, ik.commentBefore, false);
        if (ik.comment)
          reqNewline = true;
      }
      const iv = isNode(item.value) ? item.value : null;
      if (iv) {
        if (iv.comment)
          comment = iv.comment;
        if (iv.commentBefore)
          reqNewline = true;
      } else if (item.value == null && ik?.comment) {
        comment = ik.comment;
      }
    }
    if (comment)
      reqNewline = true;
    let str = stringify$1(item, itemCtx, () => comment = null);
    if (i < items.length - 1)
      str += ",";
    if (comment)
      str += lineComment(str, itemIndent, commentString(comment));
    if (!reqNewline && (lines.length > linesAtValue || str.includes("\n")))
      reqNewline = true;
    lines.push(str);
    linesAtValue = lines.length;
  }
  const { start, end } = flowChars;
  if (lines.length === 0) {
    return start + end;
  } else {
    if (!reqNewline) {
      const len = lines.reduce((sum2, line) => sum2 + line.length + 2, 2);
      reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
    }
    if (reqNewline) {
      let str = start;
      for (const line of lines)
        str += line ? `
${indentStep}${indent}${line}` : "\n";
      return `${str}
${indent}${end}`;
    } else {
      return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
    }
  }
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
  if (comment && chompKeep)
    comment = comment.replace(/^\n+/, "");
  if (comment) {
    const ic = indentComment(commentString(comment), indent);
    lines.push(ic.trimStart());
  }
}
function findPair(items, key) {
  const k = isScalar(key) ? key.value : key;
  for (const it of items) {
    if (isPair(it)) {
      if (it.key === key || it.key === k)
        return it;
      if (isScalar(it.key) && it.key.value === k)
        return it;
    }
  }
  return void 0;
}
class YAMLMap extends Collection {
  static get tagName() {
    return "tag:yaml.org,2002:map";
  }
  constructor(schema2) {
    super(MAP, schema2);
    this.items = [];
  }
  /**
   * A generic collection parsing method that can be extended
   * to other node classes that inherit from YAMLMap
   */
  static from(schema2, obj, ctx) {
    const { keepUndefined, replacer } = ctx;
    const map2 = new this(schema2);
    const add = (key, value) => {
      if (typeof replacer === "function")
        value = replacer.call(obj, key, value);
      else if (Array.isArray(replacer) && !replacer.includes(key))
        return;
      if (value !== void 0 || keepUndefined)
        map2.items.push(createPair(key, value, ctx));
    };
    if (obj instanceof Map) {
      for (const [key, value] of obj)
        add(key, value);
    } else if (obj && typeof obj === "object") {
      for (const key of Object.keys(obj))
        add(key, obj[key]);
    }
    if (typeof schema2.sortMapEntries === "function") {
      map2.items.sort(schema2.sortMapEntries);
    }
    return map2;
  }
  /**
   * Adds a value to the collection.
   *
   * @param overwrite - If not set `true`, using a key that is already in the
   *   collection will throw. Otherwise, overwrites the previous value.
   */
  add(pair, overwrite) {
    let _pair;
    if (isPair(pair))
      _pair = pair;
    else if (!pair || typeof pair !== "object" || !("key" in pair)) {
      _pair = new Pair(pair, pair?.value);
    } else
      _pair = new Pair(pair.key, pair.value);
    const prev = findPair(this.items, _pair.key);
    const sortEntries = this.schema?.sortMapEntries;
    if (prev) {
      if (!overwrite)
        throw new Error(`Key ${_pair.key} already set`);
      if (isScalar(prev.value) && isScalarValue(_pair.value))
        prev.value.value = _pair.value;
      else
        prev.value = _pair.value;
    } else if (sortEntries) {
      const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
      if (i === -1)
        this.items.push(_pair);
      else
        this.items.splice(i, 0, _pair);
    } else {
      this.items.push(_pair);
    }
  }
  delete(key) {
    const it = findPair(this.items, key);
    if (!it)
      return false;
    const del = this.items.splice(this.items.indexOf(it), 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    const it = findPair(this.items, key);
    const node = it?.value;
    return (!keepScalar && isScalar(node) ? node.value : node) ?? void 0;
  }
  has(key) {
    return !!findPair(this.items, key);
  }
  set(key, value) {
    this.add(new Pair(key, value), true);
  }
  /**
   * @param ctx - Conversion context, originally set in Document#toJS()
   * @param {Class} Type - If set, forces the returned collection type
   * @returns Instance of Type, Map, or Object
   */
  toJSON(_, ctx, Type) {
    const map2 = Type ? new Type() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
    if (ctx?.onCreate)
      ctx.onCreate(map2);
    for (const item of this.items)
      addPairToJSMap(ctx, map2, item);
    return map2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    for (const item of this.items) {
      if (!isPair(item))
        throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
    }
    if (!ctx.allNullValues && this.hasAllNullValues(false))
      ctx = Object.assign({}, ctx, { allNullValues: true });
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "",
      flowChars: { start: "{", end: "}" },
      itemIndent: ctx.indent || "",
      onChompKeep,
      onComment
    });
  }
}
const map$2 = {
  collection: "map",
  default: true,
  nodeClass: YAMLMap,
  tag: "tag:yaml.org,2002:map",
  resolve(map2, onError) {
    if (!isMap(map2))
      onError("Expected a mapping for this tag");
    return map2;
  },
  createNode: (schema2, obj, ctx) => YAMLMap.from(schema2, obj, ctx)
};
class YAMLSeq extends Collection {
  static get tagName() {
    return "tag:yaml.org,2002:seq";
  }
  constructor(schema2) {
    super(SEQ, schema2);
    this.items = [];
  }
  add(value) {
    this.items.push(value);
  }
  /**
   * Removes a value from the collection.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   *
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return false;
    const del = this.items.splice(idx, 1);
    return del.length > 0;
  }
  get(key, keepScalar) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      return void 0;
    const it = this.items[idx];
    return !keepScalar && isScalar(it) ? it.value : it;
  }
  /**
   * Checks if the collection includes a value with the key `key`.
   *
   * `key` must contain a representation of an integer for this to succeed.
   * It may be wrapped in a `Scalar`.
   */
  has(key) {
    const idx = asItemIndex(key);
    return typeof idx === "number" && idx < this.items.length;
  }
  /**
   * Sets a value in this collection. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   *
   * If `key` does not contain a representation of an integer, this will throw.
   * It may be wrapped in a `Scalar`.
   */
  set(key, value) {
    const idx = asItemIndex(key);
    if (typeof idx !== "number")
      throw new Error(`Expected a valid index, not ${key}.`);
    const prev = this.items[idx];
    if (isScalar(prev) && isScalarValue(value))
      prev.value = value;
    else
      this.items[idx] = value;
  }
  toJSON(_, ctx) {
    const seq2 = [];
    if (ctx?.onCreate)
      ctx.onCreate(seq2);
    let i = 0;
    for (const item of this.items)
      seq2.push(toJS(item, String(i++), ctx));
    return seq2;
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    return stringifyCollection(this, ctx, {
      blockItemPrefix: "- ",
      flowChars: { start: "[", end: "]" },
      itemIndent: (ctx.indent || "") + "  ",
      onChompKeep,
      onComment
    });
  }
  static from(schema2, obj, ctx) {
    const { replacer } = ctx;
    const seq2 = new this(schema2);
    if (obj && Symbol.iterator in Object(obj)) {
      let i = 0;
      for (let it of obj) {
        if (typeof replacer === "function") {
          const key = obj instanceof Set ? it : String(i++);
          it = replacer.call(obj, key, it);
        }
        seq2.items.push(createNode(it, void 0, ctx));
      }
    }
    return seq2;
  }
}
function asItemIndex(key) {
  let idx = isScalar(key) ? key.value : key;
  if (idx && typeof idx === "string")
    idx = Number(idx);
  return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
}
const seq = {
  collection: "seq",
  default: true,
  nodeClass: YAMLSeq,
  tag: "tag:yaml.org,2002:seq",
  resolve(seq2, onError) {
    if (!isSeq(seq2))
      onError("Expected a sequence for this tag");
    return seq2;
  },
  createNode: (schema2, obj, ctx) => YAMLSeq.from(schema2, obj, ctx)
};
const string = {
  identify: (value) => typeof value === "string",
  default: true,
  tag: "tag:yaml.org,2002:str",
  resolve: (str) => str,
  stringify(item, ctx, onComment, onChompKeep) {
    ctx = Object.assign({ actualString: true }, ctx);
    return stringifyString(item, ctx, onComment, onChompKeep);
  }
};
const nullTag = {
  identify: (value) => value == null,
  createNode: () => new Scalar(null),
  default: true,
  tag: "tag:yaml.org,2002:null",
  test: /^(?:~|[Nn]ull|NULL)?$/,
  resolve: () => new Scalar(null),
  stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
};
const boolTag = {
  identify: (value) => typeof value === "boolean",
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
  resolve: (str) => new Scalar(str[0] === "t" || str[0] === "T"),
  stringify({ source, value }, ctx) {
    if (source && boolTag.test.test(source)) {
      const sv = source[0] === "t" || source[0] === "T";
      if (value === sv)
        return source;
    }
    return value ? ctx.options.trueStr : ctx.options.falseStr;
  }
};
function stringifyNumber({ format: format2, minFractionDigits, tag: tag2, value }) {
  if (typeof value === "bigint")
    return String(value);
  const num = typeof value === "number" ? value : Number(value);
  if (!isFinite(num))
    return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
  let n = JSON.stringify(value);
  if (!format2 && minFractionDigits && (!tag2 || tag2 === "tag:yaml.org,2002:float") && /^\d/.test(n)) {
    let i = n.indexOf(".");
    if (i < 0) {
      i = n.length;
      n += ".";
    }
    let d = minFractionDigits - (n.length - i - 1);
    while (d-- > 0)
      n += "0";
  }
  return n;
}
const floatNaN$1 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
const floatExp$1 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
const float$1 = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str));
    const dot = str.indexOf(".");
    if (dot !== -1 && str[str.length - 1] === "0")
      node.minFractionDigits = str.length - dot - 1;
    return node;
  },
  stringify: stringifyNumber
};
const intIdentify$2 = (value) => typeof value === "bigint" || Number.isInteger(value);
const intResolve$1 = (str, offset2, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset2), radix);
function intStringify$1(node, radix, prefix) {
  const { value } = node;
  if (intIdentify$2(value) && value >= 0)
    return prefix + value.toString(radix);
  return stringifyNumber(node);
}
const intOct$1 = {
  identify: (value) => intIdentify$2(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^0o[0-7]+$/,
  resolve: (str, _onError, opt) => intResolve$1(str, 2, 8, opt),
  stringify: (node) => intStringify$1(node, 8, "0o")
};
const int$1 = {
  identify: intIdentify$2,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9]+$/,
  resolve: (str, _onError, opt) => intResolve$1(str, 0, 10, opt),
  stringify: stringifyNumber
};
const intHex$1 = {
  identify: (value) => intIdentify$2(value) && value >= 0,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^0x[0-9a-fA-F]+$/,
  resolve: (str, _onError, opt) => intResolve$1(str, 2, 16, opt),
  stringify: (node) => intStringify$1(node, 16, "0x")
};
const schema$2 = [
  map$2,
  seq,
  string,
  nullTag,
  boolTag,
  intOct$1,
  int$1,
  intHex$1,
  floatNaN$1,
  floatExp$1,
  float$1
];
function intIdentify$1(value) {
  return typeof value === "bigint" || Number.isInteger(value);
}
const stringifyJSON = ({ value }) => JSON.stringify(value);
const jsonScalars = [
  {
    identify: (value) => typeof value === "string",
    default: true,
    tag: "tag:yaml.org,2002:str",
    resolve: (str) => str,
    stringify: stringifyJSON
  },
  {
    identify: (value) => value == null,
    createNode: () => new Scalar(null),
    default: true,
    tag: "tag:yaml.org,2002:null",
    test: /^null$/,
    resolve: () => null,
    stringify: stringifyJSON
  },
  {
    identify: (value) => typeof value === "boolean",
    default: true,
    tag: "tag:yaml.org,2002:bool",
    test: /^true$|^false$/,
    resolve: (str) => str === "true",
    stringify: stringifyJSON
  },
  {
    identify: intIdentify$1,
    default: true,
    tag: "tag:yaml.org,2002:int",
    test: /^-?(?:0|[1-9][0-9]*)$/,
    resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
    stringify: ({ value }) => intIdentify$1(value) ? value.toString() : JSON.stringify(value)
  },
  {
    identify: (value) => typeof value === "number",
    default: true,
    tag: "tag:yaml.org,2002:float",
    test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
    resolve: (str) => parseFloat(str),
    stringify: stringifyJSON
  }
];
const jsonError = {
  default: true,
  tag: "",
  test: /^/,
  resolve(str, onError) {
    onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
    return str;
  }
};
const schema$1 = [map$2, seq].concat(jsonScalars, jsonError);
const binary = {
  identify: (value) => value instanceof Uint8Array,
  // Buffer inherits from Uint8Array
  default: false,
  tag: "tag:yaml.org,2002:binary",
  /**
   * Returns a Buffer in node and an Uint8Array in browsers
   *
   * To use the resulting buffer as an image, you'll want to do something like:
   *
   *   const blob = new Blob([buffer], { type: 'image/jpeg' })
   *   document.querySelector('#photo').src = URL.createObjectURL(blob)
   */
  resolve(src, onError) {
    if (typeof atob === "function") {
      const str = atob(src.replace(/[\n\r]/g, ""));
      const buffer = new Uint8Array(str.length);
      for (let i = 0; i < str.length; ++i)
        buffer[i] = str.charCodeAt(i);
      return buffer;
    } else {
      onError("This environment does not support reading binary tags; either Buffer or atob is required");
      return src;
    }
  },
  stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
    if (!value)
      return "";
    const buf = value;
    let str;
    if (typeof btoa === "function") {
      let s = "";
      for (let i = 0; i < buf.length; ++i)
        s += String.fromCharCode(buf[i]);
      str = btoa(s);
    } else {
      throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
    }
    type ?? (type = Scalar.BLOCK_LITERAL);
    if (type !== Scalar.QUOTE_DOUBLE) {
      const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
      const n = Math.ceil(str.length / lineWidth);
      const lines = new Array(n);
      for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
        lines[i] = str.substr(o, lineWidth);
      }
      str = lines.join(type === Scalar.BLOCK_LITERAL ? "\n" : " ");
    }
    return stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
  }
};
function resolvePairs(seq2, onError) {
  if (isSeq(seq2)) {
    for (let i = 0; i < seq2.items.length; ++i) {
      let item = seq2.items[i];
      if (isPair(item))
        continue;
      else if (isMap(item)) {
        if (item.items.length > 1)
          onError("Each pair must have its own sequence indicator");
        const pair = item.items[0] || new Pair(new Scalar(null));
        if (item.commentBefore)
          pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
        if (item.comment) {
          const cn = pair.value ?? pair.key;
          cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
        }
        item = pair;
      }
      seq2.items[i] = isPair(item) ? item : new Pair(item);
    }
  } else
    onError("Expected a sequence for this tag");
  return seq2;
}
function createPairs(schema2, iterable, ctx) {
  const { replacer } = ctx;
  const pairs2 = new YAMLSeq(schema2);
  pairs2.tag = "tag:yaml.org,2002:pairs";
  let i = 0;
  if (iterable && Symbol.iterator in Object(iterable))
    for (let it of iterable) {
      if (typeof replacer === "function")
        it = replacer.call(iterable, String(i++), it);
      let key, value;
      if (Array.isArray(it)) {
        if (it.length === 2) {
          key = it[0];
          value = it[1];
        } else
          throw new TypeError(`Expected [key, value] tuple: ${it}`);
      } else if (it && it instanceof Object) {
        const keys = Object.keys(it);
        if (keys.length === 1) {
          key = keys[0];
          value = it[key];
        } else {
          throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
        }
      } else {
        key = it;
      }
      pairs2.items.push(createPair(key, value, ctx));
    }
  return pairs2;
}
const pairs = {
  collection: "seq",
  default: false,
  tag: "tag:yaml.org,2002:pairs",
  resolve: resolvePairs,
  createNode: createPairs
};
class YAMLOMap extends YAMLSeq {
  constructor() {
    super();
    this.add = YAMLMap.prototype.add.bind(this);
    this.delete = YAMLMap.prototype.delete.bind(this);
    this.get = YAMLMap.prototype.get.bind(this);
    this.has = YAMLMap.prototype.has.bind(this);
    this.set = YAMLMap.prototype.set.bind(this);
    this.tag = YAMLOMap.tag;
  }
  /**
   * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
   * but TypeScript won't allow widening the signature of a child method.
   */
  toJSON(_, ctx) {
    if (!ctx)
      return super.toJSON(_);
    const map2 = /* @__PURE__ */ new Map();
    if (ctx?.onCreate)
      ctx.onCreate(map2);
    for (const pair of this.items) {
      let key, value;
      if (isPair(pair)) {
        key = toJS(pair.key, "", ctx);
        value = toJS(pair.value, key, ctx);
      } else {
        key = toJS(pair, "", ctx);
      }
      if (map2.has(key))
        throw new Error("Ordered maps must not include duplicate keys");
      map2.set(key, value);
    }
    return map2;
  }
  static from(schema2, iterable, ctx) {
    const pairs2 = createPairs(schema2, iterable, ctx);
    const omap2 = new this();
    omap2.items = pairs2.items;
    return omap2;
  }
}
YAMLOMap.tag = "tag:yaml.org,2002:omap";
const omap = {
  collection: "seq",
  identify: (value) => value instanceof Map,
  nodeClass: YAMLOMap,
  default: false,
  tag: "tag:yaml.org,2002:omap",
  resolve(seq2, onError) {
    const pairs2 = resolvePairs(seq2, onError);
    const seenKeys = [];
    for (const { key } of pairs2.items) {
      if (isScalar(key)) {
        if (seenKeys.includes(key.value)) {
          onError(`Ordered maps must not include duplicate keys: ${key.value}`);
        } else {
          seenKeys.push(key.value);
        }
      }
    }
    return Object.assign(new YAMLOMap(), pairs2);
  },
  createNode: (schema2, iterable, ctx) => YAMLOMap.from(schema2, iterable, ctx)
};
function boolStringify({ value, source }, ctx) {
  const boolObj = value ? trueTag : falseTag;
  if (source && boolObj.test.test(source))
    return source;
  return value ? ctx.options.trueStr : ctx.options.falseStr;
}
const trueTag = {
  identify: (value) => value === true,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
  resolve: () => new Scalar(true),
  stringify: boolStringify
};
const falseTag = {
  identify: (value) => value === false,
  default: true,
  tag: "tag:yaml.org,2002:bool",
  test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
  resolve: () => new Scalar(false),
  stringify: boolStringify
};
const floatNaN = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
  resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
  stringify: stringifyNumber
};
const floatExp = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "EXP",
  test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
  resolve: (str) => parseFloat(str.replace(/_/g, "")),
  stringify(node) {
    const num = Number(node.value);
    return isFinite(num) ? num.toExponential() : stringifyNumber(node);
  }
};
const float = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
  resolve(str) {
    const node = new Scalar(parseFloat(str.replace(/_/g, "")));
    const dot = str.indexOf(".");
    if (dot !== -1) {
      const f = str.substring(dot + 1).replace(/_/g, "");
      if (f[f.length - 1] === "0")
        node.minFractionDigits = f.length;
    }
    return node;
  },
  stringify: stringifyNumber
};
const intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
function intResolve(str, offset2, radix, { intAsBigInt }) {
  const sign = str[0];
  if (sign === "-" || sign === "+")
    offset2 += 1;
  str = str.substring(offset2).replace(/_/g, "");
  if (intAsBigInt) {
    switch (radix) {
      case 2:
        str = `0b${str}`;
        break;
      case 8:
        str = `0o${str}`;
        break;
      case 16:
        str = `0x${str}`;
        break;
    }
    const n2 = BigInt(str);
    return sign === "-" ? BigInt(-1) * n2 : n2;
  }
  const n = parseInt(str, radix);
  return sign === "-" ? -1 * n : n;
}
function intStringify(node, radix, prefix) {
  const { value } = node;
  if (intIdentify(value)) {
    const str = value.toString(radix);
    return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
  }
  return stringifyNumber(node);
}
const intBin = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "BIN",
  test: /^[-+]?0b[0-1_]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
  stringify: (node) => intStringify(node, 2, "0b")
};
const intOct = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "OCT",
  test: /^[-+]?0[0-7_]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
  stringify: (node) => intStringify(node, 8, "0")
};
const int = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  test: /^[-+]?[0-9][0-9_]*$/,
  resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
  stringify: stringifyNumber
};
const intHex = {
  identify: intIdentify,
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "HEX",
  test: /^[-+]?0x[0-9a-fA-F_]+$/,
  resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
  stringify: (node) => intStringify(node, 16, "0x")
};
class YAMLSet extends YAMLMap {
  constructor(schema2) {
    super(schema2);
    this.tag = YAMLSet.tag;
  }
  add(key) {
    let pair;
    if (isPair(key))
      pair = key;
    else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
      pair = new Pair(key.key, null);
    else
      pair = new Pair(key, null);
    const prev = findPair(this.items, pair.key);
    if (!prev)
      this.items.push(pair);
  }
  /**
   * If `keepPair` is `true`, returns the Pair matching `key`.
   * Otherwise, returns the value of that Pair's key.
   */
  get(key, keepPair) {
    const pair = findPair(this.items, key);
    return !keepPair && isPair(pair) ? isScalar(pair.key) ? pair.key.value : pair.key : pair;
  }
  set(key, value) {
    if (typeof value !== "boolean")
      throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
    const prev = findPair(this.items, key);
    if (prev && !value) {
      this.items.splice(this.items.indexOf(prev), 1);
    } else if (!prev && value) {
      this.items.push(new Pair(key));
    }
  }
  toJSON(_, ctx) {
    return super.toJSON(_, ctx, Set);
  }
  toString(ctx, onComment, onChompKeep) {
    if (!ctx)
      return JSON.stringify(this);
    if (this.hasAllNullValues(true))
      return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
    else
      throw new Error("Set items must all have null values");
  }
  static from(schema2, iterable, ctx) {
    const { replacer } = ctx;
    const set2 = new this(schema2);
    if (iterable && Symbol.iterator in Object(iterable))
      for (let value of iterable) {
        if (typeof replacer === "function")
          value = replacer.call(iterable, value, value);
        set2.items.push(createPair(value, null, ctx));
      }
    return set2;
  }
}
YAMLSet.tag = "tag:yaml.org,2002:set";
const set = {
  collection: "map",
  identify: (value) => value instanceof Set,
  nodeClass: YAMLSet,
  default: false,
  tag: "tag:yaml.org,2002:set",
  createNode: (schema2, iterable, ctx) => YAMLSet.from(schema2, iterable, ctx),
  resolve(map2, onError) {
    if (isMap(map2)) {
      if (map2.hasAllNullValues(true))
        return Object.assign(new YAMLSet(), map2);
      else
        onError("Set items must all have null values");
    } else
      onError("Expected a mapping for this tag");
    return map2;
  }
};
function parseSexagesimal(str, asBigInt) {
  const sign = str[0];
  const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
  const num = (n) => asBigInt ? BigInt(n) : Number(n);
  const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
  return sign === "-" ? num(-1) * res : res;
}
function stringifySexagesimal(node) {
  let { value } = node;
  let num = (n) => n;
  if (typeof value === "bigint")
    num = (n) => BigInt(n);
  else if (isNaN(value) || !isFinite(value))
    return stringifyNumber(node);
  let sign = "";
  if (value < 0) {
    sign = "-";
    value *= num(-1);
  }
  const _60 = num(60);
  const parts = [value % _60];
  if (value < 60) {
    parts.unshift(0);
  } else {
    value = (value - parts[0]) / _60;
    parts.unshift(value % _60);
    if (value >= 60) {
      value = (value - parts[0]) / _60;
      parts.unshift(value);
    }
  }
  return sign + parts.map((n) => String(n).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
}
const intTime = {
  identify: (value) => typeof value === "bigint" || Number.isInteger(value),
  default: true,
  tag: "tag:yaml.org,2002:int",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
  resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
  stringify: stringifySexagesimal
};
const floatTime = {
  identify: (value) => typeof value === "number",
  default: true,
  tag: "tag:yaml.org,2002:float",
  format: "TIME",
  test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
  resolve: (str) => parseSexagesimal(str, false),
  stringify: stringifySexagesimal
};
const timestamp = {
  identify: (value) => value instanceof Date,
  default: true,
  tag: "tag:yaml.org,2002:timestamp",
  // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
  // may be omitted altogether, resulting in a date format. In such a case, the time part is
  // assumed to be 00:00:00Z (start of day, UTC).
  test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
  resolve(str) {
    const match = str.match(timestamp.test);
    if (!match)
      throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
    const [, year2, month, day2, hour2, minute2, second] = match.map(Number);
    const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
    let date2 = Date.UTC(year2, month - 1, day2, hour2 || 0, minute2 || 0, second || 0, millisec);
    const tz = match[8];
    if (tz && tz !== "Z") {
      let d = parseSexagesimal(tz, false);
      if (Math.abs(d) < 30)
        d *= 60;
      date2 -= 6e4 * d;
    }
    return new Date(date2);
  },
  stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? ""
};
const schema = [
  map$2,
  seq,
  string,
  nullTag,
  trueTag,
  falseTag,
  intBin,
  intOct,
  int,
  intHex,
  floatNaN,
  floatExp,
  float,
  binary,
  merge,
  omap,
  pairs,
  set,
  intTime,
  floatTime,
  timestamp
];
const schemas = /* @__PURE__ */ new Map([
  ["core", schema$2],
  ["failsafe", [map$2, seq, string]],
  ["json", schema$1],
  ["yaml11", schema],
  ["yaml-1.1", schema]
]);
const tagsByName = {
  binary,
  bool: boolTag,
  float: float$1,
  floatExp: floatExp$1,
  floatNaN: floatNaN$1,
  floatTime,
  int: int$1,
  intHex: intHex$1,
  intOct: intOct$1,
  intTime,
  map: map$2,
  merge,
  null: nullTag,
  omap,
  pairs,
  seq,
  set,
  timestamp
};
const coreKnownTags = {
  "tag:yaml.org,2002:binary": binary,
  "tag:yaml.org,2002:merge": merge,
  "tag:yaml.org,2002:omap": omap,
  "tag:yaml.org,2002:pairs": pairs,
  "tag:yaml.org,2002:set": set,
  "tag:yaml.org,2002:timestamp": timestamp
};
function getTags(customTags, schemaName, addMergeTag) {
  const schemaTags = schemas.get(schemaName);
  if (schemaTags && !customTags) {
    return addMergeTag && !schemaTags.includes(merge) ? schemaTags.concat(merge) : schemaTags.slice();
  }
  let tags2 = schemaTags;
  if (!tags2) {
    if (Array.isArray(customTags))
      tags2 = [];
    else {
      const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
    }
  }
  if (Array.isArray(customTags)) {
    for (const tag2 of customTags)
      tags2 = tags2.concat(tag2);
  } else if (typeof customTags === "function") {
    tags2 = customTags(tags2.slice());
  }
  if (addMergeTag)
    tags2 = tags2.concat(merge);
  return tags2.reduce((tags3, tag2) => {
    const tagObj = typeof tag2 === "string" ? tagsByName[tag2] : tag2;
    if (!tagObj) {
      const tagName = JSON.stringify(tag2);
      const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
      throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
    }
    if (!tags3.includes(tagObj))
      tags3.push(tagObj);
    return tags3;
  }, []);
}
const sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
class Schema {
  constructor({ compat, customTags, merge: merge2, resolveKnownTags, schema: schema2, sortMapEntries, toStringDefaults }) {
    this.compat = Array.isArray(compat) ? getTags(compat, "compat") : compat ? getTags(null, compat) : null;
    this.name = typeof schema2 === "string" && schema2 || "core";
    this.knownTags = resolveKnownTags ? coreKnownTags : {};
    this.tags = getTags(customTags, this.name, merge2);
    this.toStringOptions = toStringDefaults ?? null;
    Object.defineProperty(this, MAP, { value: map$2 });
    Object.defineProperty(this, SCALAR$1, { value: string });
    Object.defineProperty(this, SEQ, { value: seq });
    this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
  }
  clone() {
    const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
    copy.tags = this.tags.slice();
    return copy;
  }
}
function stringifyDocument(doc, options) {
  const lines = [];
  let hasDirectives = options.directives === true;
  if (options.directives !== false && doc.directives) {
    const dir = doc.directives.toString(doc);
    if (dir) {
      lines.push(dir);
      hasDirectives = true;
    } else if (doc.directives.docStart)
      hasDirectives = true;
  }
  if (hasDirectives)
    lines.push("---");
  const ctx = createStringifyContext(doc, options);
  const { commentString } = ctx.options;
  if (doc.commentBefore) {
    if (lines.length !== 1)
      lines.unshift("");
    const cs = commentString(doc.commentBefore);
    lines.unshift(indentComment(cs, ""));
  }
  let chompKeep = false;
  let contentComment = null;
  if (doc.contents) {
    if (isNode(doc.contents)) {
      if (doc.contents.spaceBefore && hasDirectives)
        lines.push("");
      if (doc.contents.commentBefore) {
        const cs = commentString(doc.contents.commentBefore);
        lines.push(indentComment(cs, ""));
      }
      ctx.forceBlockIndent = !!doc.comment;
      contentComment = doc.contents.comment;
    }
    const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
    let body = stringify$1(doc.contents, ctx, () => contentComment = null, onChompKeep);
    if (contentComment)
      body += lineComment(body, "", commentString(contentComment));
    if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
      lines[lines.length - 1] = `--- ${body}`;
    } else
      lines.push(body);
  } else {
    lines.push(stringify$1(doc.contents, ctx));
  }
  if (doc.directives?.docEnd) {
    if (doc.comment) {
      const cs = commentString(doc.comment);
      if (cs.includes("\n")) {
        lines.push("...");
        lines.push(indentComment(cs, ""));
      } else {
        lines.push(`... ${cs}`);
      }
    } else {
      lines.push("...");
    }
  } else {
    let dc = doc.comment;
    if (dc && chompKeep)
      dc = dc.replace(/^\n+/, "");
    if (dc) {
      if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
        lines.push("");
      lines.push(indentComment(commentString(dc), ""));
    }
  }
  return lines.join("\n") + "\n";
}
class Document {
  constructor(value, replacer, options) {
    this.commentBefore = null;
    this.comment = null;
    this.errors = [];
    this.warnings = [];
    Object.defineProperty(this, NODE_TYPE, { value: DOC });
    let _replacer = null;
    if (typeof replacer === "function" || Array.isArray(replacer)) {
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const opt = Object.assign({
      intAsBigInt: false,
      keepSourceTokens: false,
      logLevel: "warn",
      prettyErrors: true,
      strict: true,
      stringKeys: false,
      uniqueKeys: true,
      version: "1.2"
    }, options);
    this.options = opt;
    let { version } = opt;
    if (options?._directives) {
      this.directives = options._directives.atDocument();
      if (this.directives.yaml.explicit)
        version = this.directives.yaml.version;
    } else
      this.directives = new Directives({ version });
    this.setSchema(version, options);
    this.contents = value === void 0 ? null : this.createNode(value, _replacer, options);
  }
  /**
   * Create a deep copy of this Document and its contents.
   *
   * Custom Node values that inherit from `Object` still refer to their original instances.
   */
  clone() {
    const copy = Object.create(Document.prototype, {
      [NODE_TYPE]: { value: DOC }
    });
    copy.commentBefore = this.commentBefore;
    copy.comment = this.comment;
    copy.errors = this.errors.slice();
    copy.warnings = this.warnings.slice();
    copy.options = Object.assign({}, this.options);
    if (this.directives)
      copy.directives = this.directives.clone();
    copy.schema = this.schema.clone();
    copy.contents = isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
    if (this.range)
      copy.range = this.range.slice();
    return copy;
  }
  /** Adds a value to the document. */
  add(value) {
    if (assertCollection(this.contents))
      this.contents.add(value);
  }
  /** Adds a value to the document. */
  addIn(path, value) {
    if (assertCollection(this.contents))
      this.contents.addIn(path, value);
  }
  /**
   * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
   *
   * If `node` already has an anchor, `name` is ignored.
   * Otherwise, the `node.anchor` value will be set to `name`,
   * or if an anchor with that name is already present in the document,
   * `name` will be used as a prefix for a new unique anchor.
   * If `name` is undefined, the generated anchor will use 'a' as a prefix.
   */
  createAlias(node, name) {
    if (!node.anchor) {
      const prev = anchorNames(this);
      node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      !name || prev.has(name) ? findNewAnchor(name || "a", prev) : name;
    }
    return new Alias(node.anchor);
  }
  createNode(value, replacer, options) {
    let _replacer = void 0;
    if (typeof replacer === "function") {
      value = replacer.call({ "": value }, "", value);
      _replacer = replacer;
    } else if (Array.isArray(replacer)) {
      const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
      const asStr = replacer.filter(keyToStr).map(String);
      if (asStr.length > 0)
        replacer = replacer.concat(asStr);
      _replacer = replacer;
    } else if (options === void 0 && replacer) {
      options = replacer;
      replacer = void 0;
    }
    const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag: tag2 } = options ?? {};
    const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(
      this,
      // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
      anchorPrefix || "a"
    );
    const ctx = {
      aliasDuplicateObjects: aliasDuplicateObjects ?? true,
      keepUndefined: keepUndefined ?? false,
      onAnchor,
      onTagObj,
      replacer: _replacer,
      schema: this.schema,
      sourceObjects
    };
    const node = createNode(value, tag2, ctx);
    if (flow && isCollection(node))
      node.flow = true;
    setAnchors();
    return node;
  }
  /**
   * Convert a key and a value into a `Pair` using the current schema,
   * recursively wrapping all values as `Scalar` or `Collection` nodes.
   */
  createPair(key, value, options = {}) {
    const k = this.createNode(key, null, options);
    const v = this.createNode(value, null, options);
    return new Pair(k, v);
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  delete(key) {
    return assertCollection(this.contents) ? this.contents.delete(key) : false;
  }
  /**
   * Removes a value from the document.
   * @returns `true` if the item was found and removed.
   */
  deleteIn(path) {
    if (isEmptyPath(path)) {
      if (this.contents == null)
        return false;
      this.contents = null;
      return true;
    }
    return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
  }
  /**
   * Returns item at `key`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  get(key, keepScalar) {
    return isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
  }
  /**
   * Returns item at `path`, or `undefined` if not found. By default unwraps
   * scalar values from their surrounding node; to disable set `keepScalar` to
   * `true` (collections are always returned intact).
   */
  getIn(path, keepScalar) {
    if (isEmptyPath(path))
      return !keepScalar && isScalar(this.contents) ? this.contents.value : this.contents;
    return isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : void 0;
  }
  /**
   * Checks if the document includes a value with the key `key`.
   */
  has(key) {
    return isCollection(this.contents) ? this.contents.has(key) : false;
  }
  /**
   * Checks if the document includes a value at `path`.
   */
  hasIn(path) {
    if (isEmptyPath(path))
      return this.contents !== void 0;
    return isCollection(this.contents) ? this.contents.hasIn(path) : false;
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  set(key, value) {
    if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, [key], value);
    } else if (assertCollection(this.contents)) {
      this.contents.set(key, value);
    }
  }
  /**
   * Sets a value in this document. For `!!set`, `value` needs to be a
   * boolean to add/remove the item from the set.
   */
  setIn(path, value) {
    if (isEmptyPath(path)) {
      this.contents = value;
    } else if (this.contents == null) {
      this.contents = collectionFromPath(this.schema, Array.from(path), value);
    } else if (assertCollection(this.contents)) {
      this.contents.setIn(path, value);
    }
  }
  /**
   * Change the YAML version and schema used by the document.
   * A `null` version disables support for directives, explicit tags, anchors, and aliases.
   * It also requires the `schema` option to be given as a `Schema` instance value.
   *
   * Overrides all previously set schema options.
   */
  setSchema(version, options = {}) {
    if (typeof version === "number")
      version = String(version);
    let opt;
    switch (version) {
      case "1.1":
        if (this.directives)
          this.directives.yaml.version = "1.1";
        else
          this.directives = new Directives({ version: "1.1" });
        opt = { resolveKnownTags: false, schema: "yaml-1.1" };
        break;
      case "1.2":
      case "next":
        if (this.directives)
          this.directives.yaml.version = version;
        else
          this.directives = new Directives({ version });
        opt = { resolveKnownTags: true, schema: "core" };
        break;
      case null:
        if (this.directives)
          delete this.directives;
        opt = null;
        break;
      default: {
        const sv = JSON.stringify(version);
        throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
      }
    }
    if (options.schema instanceof Object)
      this.schema = options.schema;
    else if (opt)
      this.schema = new Schema(Object.assign(opt, options));
    else
      throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
  }
  // json & jsonArg are only used from toJSON()
  toJS({ json: json2, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
    const ctx = {
      anchors: /* @__PURE__ */ new Map(),
      doc: this,
      keep: !json2,
      mapAsMap: mapAsMap === true,
      mapKeyWarned: false,
      maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
    };
    const res = toJS(this.contents, jsonArg ?? "", ctx);
    if (typeof onAnchor === "function")
      for (const { count, res: res2 } of ctx.anchors.values())
        onAnchor(res2, count);
    return typeof reviver === "function" ? applyReviver(reviver, { "": res }, "", res) : res;
  }
  /**
   * A JSON representation of the document `contents`.
   *
   * @param jsonArg Used by `JSON.stringify` to indicate the array index or
   *   property name.
   */
  toJSON(jsonArg, onAnchor) {
    return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
  }
  /** A YAML representation of the document. */
  toString(options = {}) {
    if (this.errors.length > 0)
      throw new Error("Document with errors cannot be stringified");
    if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
      const s = JSON.stringify(options.indent);
      throw new Error(`"indent" option must be a positive integer, not ${s}`);
    }
    return stringifyDocument(this, options);
  }
}
function assertCollection(contents) {
  if (isCollection(contents))
    return true;
  throw new Error("Expected a YAML collection as document contents");
}
class YAMLError extends Error {
  constructor(name, pos, code, message2) {
    super();
    this.name = name;
    this.code = code;
    this.message = message2;
    this.pos = pos;
  }
}
class YAMLParseError extends YAMLError {
  constructor(pos, code, message2) {
    super("YAMLParseError", pos, code, message2);
  }
}
class YAMLWarning extends YAMLError {
  constructor(pos, code, message2) {
    super("YAMLWarning", pos, code, message2);
  }
}
const prettifyError = (src, lc) => (error) => {
  if (error.pos[0] === -1)
    return;
  error.linePos = error.pos.map((pos) => lc.linePos(pos));
  const { line, col } = error.linePos[0];
  error.message += ` at line ${line}, column ${col}`;
  let ci = col - 1;
  let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
  if (ci >= 60 && lineStr.length > 80) {
    const trimStart = Math.min(ci - 39, lineStr.length - 79);
    lineStr = "" + lineStr.substring(trimStart);
    ci -= trimStart - 1;
  }
  if (lineStr.length > 80)
    lineStr = lineStr.substring(0, 79) + "";
  if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
    let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
    if (prev.length > 80)
      prev = prev.substring(0, 79) + "\n";
    lineStr = prev + lineStr;
  }
  if (/[^ ]/.test(lineStr)) {
    let count = 1;
    const end = error.linePos[1];
    if (end && end.line === line && end.col > col) {
      count = Math.max(1, Math.min(end.col - col, 80 - ci));
    }
    const pointer = " ".repeat(ci) + "^".repeat(count);
    error.message += `:

${lineStr}
${pointer}
`;
  }
};
function resolveProps(tokens, { flow, indicator, next, offset: offset2, onError, parentIndent, startOnNewline }) {
  let spaceBefore = false;
  let atNewline = startOnNewline;
  let hasSpace = startOnNewline;
  let comment = "";
  let commentSep = "";
  let hasNewline = false;
  let reqSpace = false;
  let tab = null;
  let anchor = null;
  let tag2 = null;
  let newlineAfterProp = null;
  let comma = null;
  let found = null;
  let start = null;
  for (const token of tokens) {
    if (reqSpace) {
      if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
        onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      reqSpace = false;
    }
    if (tab) {
      if (atNewline && token.type !== "comment" && token.type !== "newline") {
        onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
      }
      tab = null;
    }
    switch (token.type) {
      case "space":
        if (!flow && (indicator !== "doc-start" || next?.type !== "flow-collection") && token.source.includes("	")) {
          tab = token;
        }
        hasSpace = true;
        break;
      case "comment": {
        if (!hasSpace)
          onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
        const cb = token.source.substring(1) || " ";
        if (!comment)
          comment = cb;
        else
          comment += commentSep + cb;
        commentSep = "";
        atNewline = false;
        break;
      }
      case "newline":
        if (atNewline) {
          if (comment)
            comment += token.source;
          else if (!found || indicator !== "seq-item-ind")
            spaceBefore = true;
        } else
          commentSep += token.source;
        atNewline = true;
        hasNewline = true;
        if (anchor || tag2)
          newlineAfterProp = token;
        hasSpace = true;
        break;
      case "anchor":
        if (anchor)
          onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
        if (token.source.endsWith(":"))
          onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
        anchor = token;
        start ?? (start = token.offset);
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      case "tag": {
        if (tag2)
          onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
        tag2 = token;
        start ?? (start = token.offset);
        atNewline = false;
        hasSpace = false;
        reqSpace = true;
        break;
      }
      case indicator:
        if (anchor || tag2)
          onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
        if (found)
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
        found = token;
        atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
        hasSpace = false;
        break;
      case "comma":
        if (flow) {
          if (comma)
            onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
          comma = token;
          atNewline = false;
          hasSpace = false;
          break;
        }
      // else fallthrough
      default:
        onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
        atNewline = false;
        hasSpace = false;
    }
  }
  const last2 = tokens[tokens.length - 1];
  const end = last2 ? last2.offset + last2.source.length : offset2;
  if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) {
    onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
  }
  if (tab && (atNewline && tab.indent <= parentIndent || next?.type === "block-map" || next?.type === "block-seq"))
    onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
  return {
    comma,
    found,
    spaceBefore,
    comment,
    hasNewline,
    anchor,
    tag: tag2,
    newlineAfterProp,
    end,
    start: start ?? end
  };
}
function containsNewline(key) {
  if (!key)
    return null;
  switch (key.type) {
    case "alias":
    case "scalar":
    case "double-quoted-scalar":
    case "single-quoted-scalar":
      if (key.source.includes("\n"))
        return true;
      if (key.end) {
        for (const st of key.end)
          if (st.type === "newline")
            return true;
      }
      return false;
    case "flow-collection":
      for (const it of key.items) {
        for (const st of it.start)
          if (st.type === "newline")
            return true;
        if (it.sep) {
          for (const st of it.sep)
            if (st.type === "newline")
              return true;
        }
        if (containsNewline(it.key) || containsNewline(it.value))
          return true;
      }
      return false;
    default:
      return true;
  }
}
function flowIndentCheck(indent, fc, onError) {
  if (fc?.type === "flow-collection") {
    const end = fc.end[0];
    if (end.indent === indent && (end.source === "]" || end.source === "}") && containsNewline(fc)) {
      const msg = "Flow end indicator should be more indented than parent";
      onError(end, "BAD_INDENT", msg, true);
    }
  }
}
function mapIncludes(ctx, items, search2) {
  const { uniqueKeys } = ctx.options;
  if (uniqueKeys === false)
    return false;
  const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || isScalar(a) && isScalar(b) && a.value === b.value;
  return items.some((pair) => isEqual(pair.key, search2));
}
const startColMsg = "All mapping items must start at the same column";
function resolveBlockMap({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bm, onError, tag2) {
  const NodeClass = tag2?.nodeClass ?? YAMLMap;
  const map2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  let offset2 = bm.offset;
  let commentEnd = null;
  for (const collItem of bm.items) {
    const { start, key, sep: sep2, value } = collItem;
    const keyProps = resolveProps(start, {
      indicator: "explicit-key-ind",
      next: key ?? sep2?.[0],
      offset: offset2,
      onError,
      parentIndent: bm.indent,
      startOnNewline: true
    });
    const implicitKey = !keyProps.found;
    if (implicitKey) {
      if (key) {
        if (key.type === "block-seq")
          onError(offset2, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
        else if ("indent" in key && key.indent !== bm.indent)
          onError(offset2, "BAD_INDENT", startColMsg);
      }
      if (!keyProps.anchor && !keyProps.tag && !sep2) {
        commentEnd = keyProps.end;
        if (keyProps.comment) {
          if (map2.comment)
            map2.comment += "\n" + keyProps.comment;
          else
            map2.comment = keyProps.comment;
        }
        continue;
      }
      if (keyProps.newlineAfterProp || containsNewline(key)) {
        onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
      }
    } else if (keyProps.found?.indent !== bm.indent) {
      onError(offset2, "BAD_INDENT", startColMsg);
    }
    ctx.atKey = true;
    const keyStart = keyProps.end;
    const keyNode = key ? composeNode2(ctx, key, keyProps, onError) : composeEmptyNode2(ctx, keyStart, start, null, keyProps, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bm.indent, key, onError);
    ctx.atKey = false;
    if (mapIncludes(ctx, map2.items, keyNode))
      onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
    const valueProps = resolveProps(sep2 ?? [], {
      indicator: "map-value-ind",
      next: value,
      offset: keyNode.range[2],
      onError,
      parentIndent: bm.indent,
      startOnNewline: !key || key.type === "block-scalar"
    });
    offset2 = valueProps.end;
    if (valueProps.found) {
      if (implicitKey) {
        if (value?.type === "block-map" && !valueProps.hasNewline)
          onError(offset2, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
        if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
          onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : composeEmptyNode2(ctx, offset2, sep2, null, valueProps, onError);
      if (ctx.schema.compat)
        flowIndentCheck(bm.indent, value, onError);
      offset2 = valueNode.range[2];
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    } else {
      if (implicitKey)
        onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
      if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      map2.items.push(pair);
    }
  }
  if (commentEnd && commentEnd < offset2)
    onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
  map2.range = [bm.offset, offset2, commentEnd ?? offset2];
  return map2;
}
function resolveBlockSeq({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, bs, onError, tag2) {
  const NodeClass = tag2?.nodeClass ?? YAMLSeq;
  const seq2 = new NodeClass(ctx.schema);
  if (ctx.atRoot)
    ctx.atRoot = false;
  if (ctx.atKey)
    ctx.atKey = false;
  let offset2 = bs.offset;
  let commentEnd = null;
  for (const { start, value } of bs.items) {
    const props = resolveProps(start, {
      indicator: "seq-item-ind",
      next: value,
      offset: offset2,
      onError,
      parentIndent: bs.indent,
      startOnNewline: true
    });
    if (!props.found) {
      if (props.anchor || props.tag || value) {
        if (value && value.type === "block-seq")
          onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
        else
          onError(offset2, "MISSING_CHAR", "Sequence item without - indicator");
      } else {
        commentEnd = props.end;
        if (props.comment)
          seq2.comment = props.comment;
        continue;
      }
    }
    const node = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, start, null, props, onError);
    if (ctx.schema.compat)
      flowIndentCheck(bs.indent, value, onError);
    offset2 = node.range[2];
    seq2.items.push(node);
  }
  seq2.range = [bs.offset, offset2, commentEnd ?? offset2];
  return seq2;
}
function resolveEnd(end, offset2, reqSpace, onError) {
  let comment = "";
  if (end) {
    let hasSpace = false;
    let sep2 = "";
    for (const token of end) {
      const { source, type } = token;
      switch (type) {
        case "space":
          hasSpace = true;
          break;
        case "comment": {
          if (reqSpace && !hasSpace)
            onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
          const cb = source.substring(1) || " ";
          if (!comment)
            comment = cb;
          else
            comment += sep2 + cb;
          sep2 = "";
          break;
        }
        case "newline":
          if (comment)
            sep2 += source;
          hasSpace = true;
          break;
        default:
          onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
      }
      offset2 += source.length;
    }
  }
  return { comment, offset: offset2 };
}
const blockMsg = "Block collections are not allowed within flow collections";
const isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
function resolveFlowCollection({ composeNode: composeNode2, composeEmptyNode: composeEmptyNode2 }, ctx, fc, onError, tag2) {
  const isMap2 = fc.start.source === "{";
  const fcName = isMap2 ? "flow map" : "flow sequence";
  const NodeClass = tag2?.nodeClass ?? (isMap2 ? YAMLMap : YAMLSeq);
  const coll = new NodeClass(ctx.schema);
  coll.flow = true;
  const atRoot = ctx.atRoot;
  if (atRoot)
    ctx.atRoot = false;
  if (ctx.atKey)
    ctx.atKey = false;
  let offset2 = fc.offset + fc.start.source.length;
  for (let i = 0; i < fc.items.length; ++i) {
    const collItem = fc.items[i];
    const { start, key, sep: sep2, value } = collItem;
    const props = resolveProps(start, {
      flow: fcName,
      indicator: "explicit-key-ind",
      next: key ?? sep2?.[0],
      offset: offset2,
      onError,
      parentIndent: fc.indent,
      startOnNewline: false
    });
    if (!props.found) {
      if (!props.anchor && !props.tag && !sep2 && !value) {
        if (i === 0 && props.comma)
          onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        else if (i < fc.items.length - 1)
          onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
        if (props.comment) {
          if (coll.comment)
            coll.comment += "\n" + props.comment;
          else
            coll.comment = props.comment;
        }
        offset2 = props.end;
        continue;
      }
      if (!isMap2 && ctx.options.strict && containsNewline(key))
        onError(
          key,
          // checked by containsNewline()
          "MULTILINE_IMPLICIT_KEY",
          "Implicit keys of flow sequence pairs need to be on a single line"
        );
    }
    if (i === 0) {
      if (props.comma)
        onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
    } else {
      if (!props.comma)
        onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
      if (props.comment) {
        let prevItemComment = "";
        loop: for (const st of start) {
          switch (st.type) {
            case "comma":
            case "space":
              break;
            case "comment":
              prevItemComment = st.source.substring(1);
              break loop;
            default:
              break loop;
          }
        }
        if (prevItemComment) {
          let prev = coll.items[coll.items.length - 1];
          if (isPair(prev))
            prev = prev.value ?? prev.key;
          if (prev.comment)
            prev.comment += "\n" + prevItemComment;
          else
            prev.comment = prevItemComment;
          props.comment = props.comment.substring(prevItemComment.length + 1);
        }
      }
    }
    if (!isMap2 && !sep2 && !props.found) {
      const valueNode = value ? composeNode2(ctx, value, props, onError) : composeEmptyNode2(ctx, props.end, sep2, null, props, onError);
      coll.items.push(valueNode);
      offset2 = valueNode.range[2];
      if (isBlock(value))
        onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
    } else {
      ctx.atKey = true;
      const keyStart = props.end;
      const keyNode = key ? composeNode2(ctx, key, props, onError) : composeEmptyNode2(ctx, keyStart, start, null, props, onError);
      if (isBlock(key))
        onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
      ctx.atKey = false;
      const valueProps = resolveProps(sep2 ?? [], {
        flow: fcName,
        indicator: "map-value-ind",
        next: value,
        offset: keyNode.range[2],
        onError,
        parentIndent: fc.indent,
        startOnNewline: false
      });
      if (valueProps.found) {
        if (!isMap2 && !props.found && ctx.options.strict) {
          if (sep2)
            for (const st of sep2) {
              if (st === valueProps.found)
                break;
              if (st.type === "newline") {
                onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                break;
              }
            }
          if (props.start < valueProps.found.offset - 1024)
            onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
        }
      } else if (value) {
        if ("source" in value && value.source && value.source[0] === ":")
          onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
        else
          onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
      }
      const valueNode = value ? composeNode2(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode2(ctx, valueProps.end, sep2, null, valueProps, onError) : null;
      if (valueNode) {
        if (isBlock(value))
          onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
      } else if (valueProps.comment) {
        if (keyNode.comment)
          keyNode.comment += "\n" + valueProps.comment;
        else
          keyNode.comment = valueProps.comment;
      }
      const pair = new Pair(keyNode, valueNode);
      if (ctx.options.keepSourceTokens)
        pair.srcToken = collItem;
      if (isMap2) {
        const map2 = coll;
        if (mapIncludes(ctx, map2.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        map2.items.push(pair);
      } else {
        const map2 = new YAMLMap(ctx.schema);
        map2.flow = true;
        map2.items.push(pair);
        const endRange = (valueNode ?? keyNode).range;
        map2.range = [keyNode.range[0], endRange[1], endRange[2]];
        coll.items.push(map2);
      }
      offset2 = valueNode ? valueNode.range[2] : valueProps.end;
    }
  }
  const expectedEnd = isMap2 ? "}" : "]";
  const [ce, ...ee] = fc.end;
  let cePos = offset2;
  if (ce && ce.source === expectedEnd)
    cePos = ce.offset + ce.source.length;
  else {
    const name = fcName[0].toUpperCase() + fcName.substring(1);
    const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
    onError(offset2, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
    if (ce && ce.source.length !== 1)
      ee.unshift(ce);
  }
  if (ee.length > 0) {
    const end = resolveEnd(ee, cePos, ctx.options.strict, onError);
    if (end.comment) {
      if (coll.comment)
        coll.comment += "\n" + end.comment;
      else
        coll.comment = end.comment;
    }
    coll.range = [fc.offset, cePos, end.offset];
  } else {
    coll.range = [fc.offset, cePos, cePos];
  }
  return coll;
}
function resolveCollection(CN2, ctx, token, onError, tagName, tag2) {
  const coll = token.type === "block-map" ? resolveBlockMap(CN2, ctx, token, onError, tag2) : token.type === "block-seq" ? resolveBlockSeq(CN2, ctx, token, onError, tag2) : resolveFlowCollection(CN2, ctx, token, onError, tag2);
  const Coll = coll.constructor;
  if (tagName === "!" || tagName === Coll.tagName) {
    coll.tag = Coll.tagName;
    return coll;
  }
  if (tagName)
    coll.tag = tagName;
  return coll;
}
function composeCollection(CN2, ctx, token, props, onError) {
  const tagToken = props.tag;
  const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
  if (token.type === "block-seq") {
    const { anchor, newlineAfterProp: nl } = props;
    const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
    if (lastProp && (!nl || nl.offset < lastProp.offset)) {
      const message2 = "Missing newline after block sequence props";
      onError(lastProp, "MISSING_CHAR", message2);
    }
  }
  const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
  if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.tagName && expType === "seq") {
    return resolveCollection(CN2, ctx, token, onError, tagName);
  }
  let tag2 = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
  if (!tag2) {
    const kt = ctx.schema.knownTags[tagName];
    if (kt && kt.collection === expType) {
      ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
      tag2 = kt;
    } else {
      if (kt) {
        onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? "scalar"}`, true);
      } else {
        onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
      }
      return resolveCollection(CN2, ctx, token, onError, tagName);
    }
  }
  const coll = resolveCollection(CN2, ctx, token, onError, tagName, tag2);
  const res = tag2.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
  const node = isNode(res) ? res : new Scalar(res);
  node.range = coll.range;
  node.tag = tagName;
  if (tag2?.format)
    node.format = tag2.format;
  return node;
}
function resolveBlockScalar(ctx, scalar, onError) {
  const start = scalar.offset;
  const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
  if (!header)
    return { value: "", type: null, comment: "", range: [start, start, start] };
  const type = header.mode === ">" ? Scalar.BLOCK_FOLDED : Scalar.BLOCK_LITERAL;
  const lines = scalar.source ? splitLines(scalar.source) : [];
  let chompStart = lines.length;
  for (let i = lines.length - 1; i >= 0; --i) {
    const content = lines[i][1];
    if (content === "" || content === "\r")
      chompStart = i;
    else
      break;
  }
  if (chompStart === 0) {
    const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
    let end2 = start + header.length;
    if (scalar.source)
      end2 += scalar.source.length;
    return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
  }
  let trimIndent = scalar.indent + header.indent;
  let offset2 = scalar.offset + header.length;
  let contentStart = 0;
  for (let i = 0; i < chompStart; ++i) {
    const [indent, content] = lines[i];
    if (content === "" || content === "\r") {
      if (header.indent === 0 && indent.length > trimIndent)
        trimIndent = indent.length;
    } else {
      if (indent.length < trimIndent) {
        const message2 = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
        onError(offset2 + indent.length, "MISSING_CHAR", message2);
      }
      if (header.indent === 0)
        trimIndent = indent.length;
      contentStart = i;
      if (trimIndent === 0 && !ctx.atRoot) {
        const message2 = "Block scalar values in collections must be indented";
        onError(offset2, "BAD_INDENT", message2);
      }
      break;
    }
    offset2 += indent.length + content.length + 1;
  }
  for (let i = lines.length - 1; i >= chompStart; --i) {
    if (lines[i][0].length > trimIndent)
      chompStart = i + 1;
  }
  let value = "";
  let sep2 = "";
  let prevMoreIndented = false;
  for (let i = 0; i < contentStart; ++i)
    value += lines[i][0].slice(trimIndent) + "\n";
  for (let i = contentStart; i < chompStart; ++i) {
    let [indent, content] = lines[i];
    offset2 += indent.length + content.length + 1;
    const crlf = content[content.length - 1] === "\r";
    if (crlf)
      content = content.slice(0, -1);
    if (content && indent.length < trimIndent) {
      const src = header.indent ? "explicit indentation indicator" : "first line";
      const message2 = `Block scalar lines must not be less indented than their ${src}`;
      onError(offset2 - content.length - (crlf ? 2 : 1), "BAD_INDENT", message2);
      indent = "";
    }
    if (type === Scalar.BLOCK_LITERAL) {
      value += sep2 + indent.slice(trimIndent) + content;
      sep2 = "\n";
    } else if (indent.length > trimIndent || content[0] === "	") {
      if (sep2 === " ")
        sep2 = "\n";
      else if (!prevMoreIndented && sep2 === "\n")
        sep2 = "\n\n";
      value += sep2 + indent.slice(trimIndent) + content;
      sep2 = "\n";
      prevMoreIndented = true;
    } else if (content === "") {
      if (sep2 === "\n")
        value += "\n";
      else
        sep2 = "\n";
    } else {
      value += sep2 + content;
      sep2 = " ";
      prevMoreIndented = false;
    }
  }
  switch (header.chomp) {
    case "-":
      break;
    case "+":
      for (let i = chompStart; i < lines.length; ++i)
        value += "\n" + lines[i][0].slice(trimIndent);
      if (value[value.length - 1] !== "\n")
        value += "\n";
      break;
    default:
      value += "\n";
  }
  const end = start + header.length + scalar.source.length;
  return { value, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset: offset2, props }, strict, onError) {
  if (props[0].type !== "block-scalar-header") {
    onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
    return null;
  }
  const { source } = props[0];
  const mode = source[0];
  let indent = 0;
  let chomp = "";
  let error = -1;
  for (let i = 1; i < source.length; ++i) {
    const ch = source[i];
    if (!chomp && (ch === "-" || ch === "+"))
      chomp = ch;
    else {
      const n = Number(ch);
      if (!indent && n)
        indent = n;
      else if (error === -1)
        error = offset2 + i;
    }
  }
  if (error !== -1)
    onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
  let hasSpace = false;
  let comment = "";
  let length = source.length;
  for (let i = 1; i < props.length; ++i) {
    const token = props[i];
    switch (token.type) {
      case "space":
        hasSpace = true;
      // fallthrough
      case "newline":
        length += token.source.length;
        break;
      case "comment":
        if (strict && !hasSpace) {
          const message2 = "Comments must be separated from other tokens by white space characters";
          onError(token, "MISSING_CHAR", message2);
        }
        length += token.source.length;
        comment = token.source.substring(1);
        break;
      case "error":
        onError(token, "UNEXPECTED_TOKEN", token.message);
        length += token.source.length;
        break;
      /* istanbul ignore next should not happen */
      default: {
        const message2 = `Unexpected token in block scalar header: ${token.type}`;
        onError(token, "UNEXPECTED_TOKEN", message2);
        const ts = token.source;
        if (ts && typeof ts === "string")
          length += ts.length;
      }
    }
  }
  return { mode, indent, chomp, comment, length };
}
function splitLines(source) {
  const split2 = source.split(/\n( *)/);
  const first2 = split2[0];
  const m = first2.match(/^( *)/);
  const line0 = m?.[1] ? [m[1], first2.slice(m[1].length)] : ["", first2];
  const lines = [line0];
  for (let i = 1; i < split2.length; i += 2)
    lines.push([split2[i], split2[i + 1]]);
  return lines;
}
function resolveFlowScalar(scalar, strict, onError) {
  const { offset: offset2, type, source, end } = scalar;
  let _type;
  let value;
  const _onError = (rel, code, msg) => onError(offset2 + rel, code, msg);
  switch (type) {
    case "scalar":
      _type = Scalar.PLAIN;
      value = plainValue(source, _onError);
      break;
    case "single-quoted-scalar":
      _type = Scalar.QUOTE_SINGLE;
      value = singleQuotedValue(source, _onError);
      break;
    case "double-quoted-scalar":
      _type = Scalar.QUOTE_DOUBLE;
      value = doubleQuotedValue(source, _onError);
      break;
    /* istanbul ignore next should not happen */
    default:
      onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
      return {
        value: "",
        type: null,
        comment: "",
        range: [offset2, offset2 + source.length, offset2 + source.length]
      };
  }
  const valueEnd = offset2 + source.length;
  const re = resolveEnd(end, valueEnd, strict, onError);
  return {
    value,
    type: _type,
    comment: re.comment,
    range: [offset2, valueEnd, re.offset]
  };
}
function plainValue(source, onError) {
  let badChar = "";
  switch (source[0]) {
    /* istanbul ignore next should not happen */
    case "	":
      badChar = "a tab character";
      break;
    case ",":
      badChar = "flow indicator character ,";
      break;
    case "%":
      badChar = "directive indicator character %";
      break;
    case "|":
    case ">": {
      badChar = `block scalar indicator ${source[0]}`;
      break;
    }
    case "@":
    case "`": {
      badChar = `reserved character ${source[0]}`;
      break;
    }
  }
  if (badChar)
    onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
  return foldLines(source);
}
function singleQuotedValue(source, onError) {
  if (source[source.length - 1] !== "'" || source.length === 1)
    onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
  return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
  let first2, line;
  try {
    first2 = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
    line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
  } catch {
    first2 = /(.*?)[ \t]*\r?\n/sy;
    line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
  }
  let match = first2.exec(source);
  if (!match)
    return source;
  let res = match[1];
  let sep2 = " ";
  let pos = first2.lastIndex;
  line.lastIndex = pos;
  while (match = line.exec(source)) {
    if (match[1] === "") {
      if (sep2 === "\n")
        res += sep2;
      else
        sep2 = "\n";
    } else {
      res += sep2 + match[1];
      sep2 = " ";
    }
    pos = line.lastIndex;
  }
  const last2 = /[ \t]*(.*)/sy;
  last2.lastIndex = pos;
  match = last2.exec(source);
  return res + sep2 + (match?.[1] ?? "");
}
function doubleQuotedValue(source, onError) {
  let res = "";
  for (let i = 1; i < source.length - 1; ++i) {
    const ch = source[i];
    if (ch === "\r" && source[i + 1] === "\n")
      continue;
    if (ch === "\n") {
      const { fold, offset: offset2 } = foldNewline(source, i);
      res += fold;
      i = offset2;
    } else if (ch === "\\") {
      let next = source[++i];
      const cc = escapeCodes[next];
      if (cc)
        res += cc;
      else if (next === "\n") {
        next = source[i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "\r" && source[i + 1] === "\n") {
        next = source[++i + 1];
        while (next === " " || next === "	")
          next = source[++i + 1];
      } else if (next === "x" || next === "u" || next === "U") {
        const length = { x: 2, u: 4, U: 8 }[next];
        res += parseCharCode(source, i + 1, length, onError);
        i += length;
      } else {
        const raw2 = source.substr(i - 1, 2);
        onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw2}`);
        res += raw2;
      }
    } else if (ch === " " || ch === "	") {
      const wsStart = i;
      let next = source[i + 1];
      while (next === " " || next === "	")
        next = source[++i + 1];
      if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n"))
        res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
    } else {
      res += ch;
    }
  }
  if (source[source.length - 1] !== '"' || source.length === 1)
    onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
  return res;
}
function foldNewline(source, offset2) {
  let fold = "";
  let ch = source[offset2 + 1];
  while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
    if (ch === "\r" && source[offset2 + 2] !== "\n")
      break;
    if (ch === "\n")
      fold += "\n";
    offset2 += 1;
    ch = source[offset2 + 1];
  }
  if (!fold)
    fold = " ";
  return { fold, offset: offset2 };
}
const escapeCodes = {
  "0": "\0",
  // null character
  a: "\x07",
  // bell character
  b: "\b",
  // backspace
  e: "\x1B",
  // escape character
  f: "\f",
  // form feed
  n: "\n",
  // line feed
  r: "\r",
  // carriage return
  t: "	",
  // horizontal tab
  v: "\v",
  // vertical tab
  N: "",
  // Unicode next line
  _: "",
  // Unicode non-breaking space
  L: "\u2028",
  // Unicode line separator
  P: "\u2029",
  // Unicode paragraph separator
  " ": " ",
  '"': '"',
  "/": "/",
  "\\": "\\",
  "	": "	"
};
function parseCharCode(source, offset2, length, onError) {
  const cc = source.substr(offset2, length);
  const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
  const code = ok ? parseInt(cc, 16) : NaN;
  if (isNaN(code)) {
    const raw2 = source.substr(offset2 - 2, length + 2);
    onError(offset2 - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw2}`);
    return raw2;
  }
  return String.fromCodePoint(code);
}
function composeScalar(ctx, token, tagToken, onError) {
  const { value, type, comment, range: range2 } = token.type === "block-scalar" ? resolveBlockScalar(ctx, token, onError) : resolveFlowScalar(token, ctx.options.strict, onError);
  const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
  let tag2;
  if (ctx.options.stringKeys && ctx.atKey) {
    tag2 = ctx.schema[SCALAR$1];
  } else if (tagName)
    tag2 = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
  else if (token.type === "scalar")
    tag2 = findScalarTagByTest(ctx, value, token, onError);
  else
    tag2 = ctx.schema[SCALAR$1];
  let scalar;
  try {
    const res = tag2.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
    scalar = isScalar(res) ? res : new Scalar(res);
  } catch (error) {
    const msg = error instanceof Error ? error.message : String(error);
    onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
    scalar = new Scalar(value);
  }
  scalar.range = range2;
  scalar.source = value;
  if (type)
    scalar.type = type;
  if (tagName)
    scalar.tag = tagName;
  if (tag2.format)
    scalar.format = tag2.format;
  if (comment)
    scalar.comment = comment;
  return scalar;
}
function findScalarTagByName(schema2, value, tagName, tagToken, onError) {
  if (tagName === "!")
    return schema2[SCALAR$1];
  const matchWithTest = [];
  for (const tag2 of schema2.tags) {
    if (!tag2.collection && tag2.tag === tagName) {
      if (tag2.default && tag2.test)
        matchWithTest.push(tag2);
      else
        return tag2;
    }
  }
  for (const tag2 of matchWithTest)
    if (tag2.test?.test(value))
      return tag2;
  const kt = schema2.knownTags[tagName];
  if (kt && !kt.collection) {
    schema2.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
    return kt;
  }
  onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
  return schema2[SCALAR$1];
}
function findScalarTagByTest({ atKey, directives, schema: schema2 }, value, token, onError) {
  const tag2 = schema2.tags.find((tag3) => (tag3.default === true || atKey && tag3.default === "key") && tag3.test?.test(value)) || schema2[SCALAR$1];
  if (schema2.compat) {
    const compat = schema2.compat.find((tag3) => tag3.default && tag3.test?.test(value)) ?? schema2[SCALAR$1];
    if (tag2.tag !== compat.tag) {
      const ts = directives.tagString(tag2.tag);
      const cs = directives.tagString(compat.tag);
      const msg = `Value may be parsed as either ${ts} or ${cs}`;
      onError(token, "TAG_RESOLVE_FAILED", msg, true);
    }
  }
  return tag2;
}
function emptyScalarPosition(offset2, before, pos) {
  if (before) {
    pos ?? (pos = before.length);
    for (let i = pos - 1; i >= 0; --i) {
      let st = before[i];
      switch (st.type) {
        case "space":
        case "comment":
        case "newline":
          offset2 -= st.source.length;
          continue;
      }
      st = before[++i];
      while (st?.type === "space") {
        offset2 += st.source.length;
        st = before[++i];
      }
      break;
    }
  }
  return offset2;
}
const CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token, props, onError) {
  const atKey = ctx.atKey;
  const { spaceBefore, comment, anchor, tag: tag2 } = props;
  let node;
  let isSrcToken = true;
  switch (token.type) {
    case "alias":
      node = composeAlias(ctx, token, onError);
      if (anchor || tag2)
        onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
      break;
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "block-scalar":
      node = composeScalar(ctx, token, tag2, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    case "block-map":
    case "block-seq":
    case "flow-collection":
      node = composeCollection(CN, ctx, token, props, onError);
      if (anchor)
        node.anchor = anchor.source.substring(1);
      break;
    default: {
      const message2 = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
      onError(token, "UNEXPECTED_TOKEN", message2);
      node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
      isSrcToken = false;
    }
  }
  if (anchor && node.anchor === "")
    onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  if (atKey && ctx.options.stringKeys && (!isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
    const msg = "With stringKeys, all keys must be strings";
    onError(tag2 ?? token, "NON_STRING_KEY", msg);
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    if (token.type === "scalar" && token.source === "")
      node.comment = comment;
    else
      node.commentBefore = comment;
  }
  if (ctx.options.keepSourceTokens && isSrcToken)
    node.srcToken = token;
  return node;
}
function composeEmptyNode(ctx, offset2, before, pos, { spaceBefore, comment, anchor, tag: tag2, end }, onError) {
  const token = {
    type: "scalar",
    offset: emptyScalarPosition(offset2, before, pos),
    indent: -1,
    source: ""
  };
  const node = composeScalar(ctx, token, tag2, onError);
  if (anchor) {
    node.anchor = anchor.source.substring(1);
    if (node.anchor === "")
      onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
  }
  if (spaceBefore)
    node.spaceBefore = true;
  if (comment) {
    node.comment = comment;
    node.range[2] = end;
  }
  return node;
}
function composeAlias({ options }, { offset: offset2, source, end }, onError) {
  const alias = new Alias(source.substring(1));
  if (alias.source === "")
    onError(offset2, "BAD_ALIAS", "Alias cannot be an empty string");
  if (alias.source.endsWith(":"))
    onError(offset2 + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
  const valueEnd = offset2 + source.length;
  const re = resolveEnd(end, valueEnd, options.strict, onError);
  alias.range = [offset2, valueEnd, re.offset];
  if (re.comment)
    alias.comment = re.comment;
  return alias;
}
function composeDoc(options, directives, { offset: offset2, start, value, end }, onError) {
  const opts = Object.assign({ _directives: directives }, options);
  const doc = new Document(void 0, opts);
  const ctx = {
    atKey: false,
    atRoot: true,
    directives: doc.directives,
    options: doc.options,
    schema: doc.schema
  };
  const props = resolveProps(start, {
    indicator: "doc-start",
    next: value ?? end?.[0],
    offset: offset2,
    onError,
    parentIndent: 0,
    startOnNewline: true
  });
  if (props.found) {
    doc.directives.docStart = true;
    if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
      onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
  }
  doc.contents = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
  const contentEnd = doc.contents.range[2];
  const re = resolveEnd(end, contentEnd, false, onError);
  if (re.comment)
    doc.comment = re.comment;
  doc.range = [offset2, contentEnd, re.offset];
  return doc;
}
function getErrorPos(src) {
  if (typeof src === "number")
    return [src, src + 1];
  if (Array.isArray(src))
    return src.length === 2 ? src : [src[0], src[1]];
  const { offset: offset2, source } = src;
  return [offset2, offset2 + (typeof source === "string" ? source.length : 1)];
}
function parsePrelude(prelude) {
  let comment = "";
  let atComment = false;
  let afterEmptyLine = false;
  for (let i = 0; i < prelude.length; ++i) {
    const source = prelude[i];
    switch (source[0]) {
      case "#":
        comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
        atComment = true;
        afterEmptyLine = false;
        break;
      case "%":
        if (prelude[i + 1]?.[0] !== "#")
          i += 1;
        atComment = false;
        break;
      default:
        if (!atComment)
          afterEmptyLine = true;
        atComment = false;
    }
  }
  return { comment, afterEmptyLine };
}
class Composer {
  constructor(options = {}) {
    this.doc = null;
    this.atDirectives = false;
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
    this.onError = (source, code, message2, warning) => {
      const pos = getErrorPos(source);
      if (warning)
        this.warnings.push(new YAMLWarning(pos, code, message2));
      else
        this.errors.push(new YAMLParseError(pos, code, message2));
    };
    this.directives = new Directives({ version: options.version || "1.2" });
    this.options = options;
  }
  decorate(doc, afterDoc) {
    const { comment, afterEmptyLine } = parsePrelude(this.prelude);
    if (comment) {
      const dc = doc.contents;
      if (afterDoc) {
        doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
      } else if (afterEmptyLine || doc.directives.docStart || !dc) {
        doc.commentBefore = comment;
      } else if (isCollection(dc) && !dc.flow && dc.items.length > 0) {
        let it = dc.items[0];
        if (isPair(it))
          it = it.key;
        const cb = it.commentBefore;
        it.commentBefore = cb ? `${comment}
${cb}` : comment;
      } else {
        const cb = dc.commentBefore;
        dc.commentBefore = cb ? `${comment}
${cb}` : comment;
      }
    }
    if (afterDoc) {
      Array.prototype.push.apply(doc.errors, this.errors);
      Array.prototype.push.apply(doc.warnings, this.warnings);
    } else {
      doc.errors = this.errors;
      doc.warnings = this.warnings;
    }
    this.prelude = [];
    this.errors = [];
    this.warnings = [];
  }
  /**
   * Current stream status information.
   *
   * Mostly useful at the end of input for an empty stream.
   */
  streamInfo() {
    return {
      comment: parsePrelude(this.prelude).comment,
      directives: this.directives,
      errors: this.errors,
      warnings: this.warnings
    };
  }
  /**
   * Compose tokens into documents.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *compose(tokens, forceDoc = false, endOffset = -1) {
    for (const token of tokens)
      yield* this.next(token);
    yield* this.end(forceDoc, endOffset);
  }
  /** Advance the composer by one CST token. */
  *next(token) {
    switch (token.type) {
      case "directive":
        this.directives.add(token.source, (offset2, message2, warning) => {
          const pos = getErrorPos(token);
          pos[0] += offset2;
          this.onError(pos, "BAD_DIRECTIVE", message2, warning);
        });
        this.prelude.push(token.source);
        this.atDirectives = true;
        break;
      case "document": {
        const doc = composeDoc(this.options, this.directives, token, this.onError);
        if (this.atDirectives && !doc.directives.docStart)
          this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
        this.decorate(doc, false);
        if (this.doc)
          yield this.doc;
        this.doc = doc;
        this.atDirectives = false;
        break;
      }
      case "byte-order-mark":
      case "space":
        break;
      case "comment":
      case "newline":
        this.prelude.push(token.source);
        break;
      case "error": {
        const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
        const error = new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
        if (this.atDirectives || !this.doc)
          this.errors.push(error);
        else
          this.doc.errors.push(error);
        break;
      }
      case "doc-end": {
        if (!this.doc) {
          const msg = "Unexpected doc-end without preceding document";
          this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
          break;
        }
        this.doc.directives.docEnd = true;
        const end = resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
        this.decorate(this.doc, true);
        if (end.comment) {
          const dc = this.doc.comment;
          this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
        }
        this.doc.range[2] = end.offset;
        break;
      }
      default:
        this.errors.push(new YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
    }
  }
  /**
   * Call at end of input to yield any remaining document.
   *
   * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
   * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
   */
  *end(forceDoc = false, endOffset = -1) {
    if (this.doc) {
      this.decorate(this.doc, true);
      yield this.doc;
      this.doc = null;
    } else if (forceDoc) {
      const opts = Object.assign({ _directives: this.directives }, this.options);
      const doc = new Document(void 0, opts);
      if (this.atDirectives)
        this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
      doc.range = [0, endOffset, endOffset];
      this.decorate(doc, false);
      yield doc;
    }
  }
}
const BOM = "\uFEFF";
const DOCUMENT = "";
const FLOW_END = "";
const SCALAR = "";
function tokenType(source) {
  switch (source) {
    case BOM:
      return "byte-order-mark";
    case DOCUMENT:
      return "doc-mode";
    case FLOW_END:
      return "flow-error-end";
    case SCALAR:
      return "scalar";
    case "---":
      return "doc-start";
    case "...":
      return "doc-end";
    case "":
    case "\n":
    case "\r\n":
      return "newline";
    case "-":
      return "seq-item-ind";
    case "?":
      return "explicit-key-ind";
    case ":":
      return "map-value-ind";
    case "{":
      return "flow-map-start";
    case "}":
      return "flow-map-end";
    case "[":
      return "flow-seq-start";
    case "]":
      return "flow-seq-end";
    case ",":
      return "comma";
  }
  switch (source[0]) {
    case " ":
    case "	":
      return "space";
    case "#":
      return "comment";
    case "%":
      return "directive-line";
    case "*":
      return "alias";
    case "&":
      return "anchor";
    case "!":
      return "tag";
    case "'":
      return "single-quoted-scalar";
    case '"':
      return "double-quoted-scalar";
    case "|":
    case ">":
      return "block-scalar-header";
  }
  return null;
}
function isEmpty$1(ch) {
  switch (ch) {
    case void 0:
    case " ":
    case "\n":
    case "\r":
    case "	":
      return true;
    default:
      return false;
  }
}
const hexDigits = new Set("0123456789ABCDEFabcdef");
const tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
const flowIndicatorChars = new Set(",[]{}");
const invalidAnchorChars = new Set(" ,[]{}\n\r	");
const isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
class Lexer {
  constructor() {
    this.atEnd = false;
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    this.buffer = "";
    this.flowKey = false;
    this.flowLevel = 0;
    this.indentNext = 0;
    this.indentValue = 0;
    this.lineEndPos = null;
    this.next = null;
    this.pos = 0;
  }
  /**
   * Generate YAML tokens from the `source` string. If `incomplete`,
   * a part of the last line may be left as a buffer for the next call.
   *
   * @returns A generator of lexical tokens
   */
  *lex(source, incomplete = false) {
    if (source) {
      if (typeof source !== "string")
        throw TypeError("source is not a string");
      this.buffer = this.buffer ? this.buffer + source : source;
      this.lineEndPos = null;
    }
    this.atEnd = !incomplete;
    let next = this.next ?? "stream";
    while (next && (incomplete || this.hasChars(1)))
      next = yield* this.parseNext(next);
  }
  atLineEnd() {
    let i = this.pos;
    let ch = this.buffer[i];
    while (ch === " " || ch === "	")
      ch = this.buffer[++i];
    if (!ch || ch === "#" || ch === "\n")
      return true;
    if (ch === "\r")
      return this.buffer[i + 1] === "\n";
    return false;
  }
  charAt(n) {
    return this.buffer[this.pos + n];
  }
  continueScalar(offset2) {
    let ch = this.buffer[offset2];
    if (this.indentNext > 0) {
      let indent = 0;
      while (ch === " ")
        ch = this.buffer[++indent + offset2];
      if (ch === "\r") {
        const next = this.buffer[indent + offset2 + 1];
        if (next === "\n" || !next && !this.atEnd)
          return offset2 + indent + 1;
      }
      return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset2 + indent : -1;
    }
    if (ch === "-" || ch === ".") {
      const dt = this.buffer.substr(offset2, 3);
      if ((dt === "---" || dt === "...") && isEmpty$1(this.buffer[offset2 + 3]))
        return -1;
    }
    return offset2;
  }
  getLine() {
    let end = this.lineEndPos;
    if (typeof end !== "number" || end !== -1 && end < this.pos) {
      end = this.buffer.indexOf("\n", this.pos);
      this.lineEndPos = end;
    }
    if (end === -1)
      return this.atEnd ? this.buffer.substring(this.pos) : null;
    if (this.buffer[end - 1] === "\r")
      end -= 1;
    return this.buffer.substring(this.pos, end);
  }
  hasChars(n) {
    return this.pos + n <= this.buffer.length;
  }
  setNext(state) {
    this.buffer = this.buffer.substring(this.pos);
    this.pos = 0;
    this.lineEndPos = null;
    this.next = state;
    return null;
  }
  peek(n) {
    return this.buffer.substr(this.pos, n);
  }
  *parseNext(next) {
    switch (next) {
      case "stream":
        return yield* this.parseStream();
      case "line-start":
        return yield* this.parseLineStart();
      case "block-start":
        return yield* this.parseBlockStart();
      case "doc":
        return yield* this.parseDocument();
      case "flow":
        return yield* this.parseFlowCollection();
      case "quoted-scalar":
        return yield* this.parseQuotedScalar();
      case "block-scalar":
        return yield* this.parseBlockScalar();
      case "plain-scalar":
        return yield* this.parsePlainScalar();
    }
  }
  *parseStream() {
    let line = this.getLine();
    if (line === null)
      return this.setNext("stream");
    if (line[0] === BOM) {
      yield* this.pushCount(1);
      line = line.substring(1);
    }
    if (line[0] === "%") {
      let dirEnd = line.length;
      let cs = line.indexOf("#");
      while (cs !== -1) {
        const ch = line[cs - 1];
        if (ch === " " || ch === "	") {
          dirEnd = cs - 1;
          break;
        } else {
          cs = line.indexOf("#", cs + 1);
        }
      }
      while (true) {
        const ch = line[dirEnd - 1];
        if (ch === " " || ch === "	")
          dirEnd -= 1;
        else
          break;
      }
      const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
      yield* this.pushCount(line.length - n);
      this.pushNewline();
      return "stream";
    }
    if (this.atLineEnd()) {
      const sp = yield* this.pushSpaces(true);
      yield* this.pushCount(line.length - sp);
      yield* this.pushNewline();
      return "stream";
    }
    yield DOCUMENT;
    return yield* this.parseLineStart();
  }
  *parseLineStart() {
    const ch = this.charAt(0);
    if (!ch && !this.atEnd)
      return this.setNext("line-start");
    if (ch === "-" || ch === ".") {
      if (!this.atEnd && !this.hasChars(4))
        return this.setNext("line-start");
      const s = this.peek(3);
      if ((s === "---" || s === "...") && isEmpty$1(this.charAt(3))) {
        yield* this.pushCount(3);
        this.indentValue = 0;
        this.indentNext = 0;
        return s === "---" ? "doc" : "stream";
      }
    }
    this.indentValue = yield* this.pushSpaces(false);
    if (this.indentNext > this.indentValue && !isEmpty$1(this.charAt(1)))
      this.indentNext = this.indentValue;
    return yield* this.parseBlockStart();
  }
  *parseBlockStart() {
    const [ch0, ch1] = this.peek(2);
    if (!ch1 && !this.atEnd)
      return this.setNext("block-start");
    if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty$1(ch1)) {
      const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
      this.indentNext = this.indentValue + 1;
      this.indentValue += n;
      return yield* this.parseBlockStart();
    }
    return "doc";
  }
  *parseDocument() {
    yield* this.pushSpaces(true);
    const line = this.getLine();
    if (line === null)
      return this.setNext("doc");
    let n = yield* this.pushIndicators();
    switch (line[n]) {
      case "#":
        yield* this.pushCount(line.length - n);
      // fallthrough
      case void 0:
        yield* this.pushNewline();
        return yield* this.parseLineStart();
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel = 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        return "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "doc";
      case '"':
      case "'":
        return yield* this.parseQuotedScalar();
      case "|":
      case ">":
        n += yield* this.parseBlockScalarHeader();
        n += yield* this.pushSpaces(true);
        yield* this.pushCount(line.length - n);
        yield* this.pushNewline();
        return yield* this.parseBlockScalar();
      default:
        return yield* this.parsePlainScalar();
    }
  }
  *parseFlowCollection() {
    let nl, sp;
    let indent = -1;
    do {
      nl = yield* this.pushNewline();
      if (nl > 0) {
        sp = yield* this.pushSpaces(false);
        this.indentValue = indent = sp;
      } else {
        sp = 0;
      }
      sp += yield* this.pushSpaces(true);
    } while (nl + sp > 0);
    const line = this.getLine();
    if (line === null)
      return this.setNext("flow");
    if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty$1(line[3])) {
      const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
      if (!atFlowEndMarker) {
        this.flowLevel = 0;
        yield FLOW_END;
        return yield* this.parseLineStart();
      }
    }
    let n = 0;
    while (line[n] === ",") {
      n += yield* this.pushCount(1);
      n += yield* this.pushSpaces(true);
      this.flowKey = false;
    }
    n += yield* this.pushIndicators();
    switch (line[n]) {
      case void 0:
        return "flow";
      case "#":
        yield* this.pushCount(line.length - n);
        return "flow";
      case "{":
      case "[":
        yield* this.pushCount(1);
        this.flowKey = false;
        this.flowLevel += 1;
        return "flow";
      case "}":
      case "]":
        yield* this.pushCount(1);
        this.flowKey = true;
        this.flowLevel -= 1;
        return this.flowLevel ? "flow" : "doc";
      case "*":
        yield* this.pushUntil(isNotAnchorChar);
        return "flow";
      case '"':
      case "'":
        this.flowKey = true;
        return yield* this.parseQuotedScalar();
      case ":": {
        const next = this.charAt(1);
        if (this.flowKey || isEmpty$1(next) || next === ",") {
          this.flowKey = false;
          yield* this.pushCount(1);
          yield* this.pushSpaces(true);
          return "flow";
        }
      }
      // fallthrough
      default:
        this.flowKey = false;
        return yield* this.parsePlainScalar();
    }
  }
  *parseQuotedScalar() {
    const quote = this.charAt(0);
    let end = this.buffer.indexOf(quote, this.pos + 1);
    if (quote === "'") {
      while (end !== -1 && this.buffer[end + 1] === "'")
        end = this.buffer.indexOf("'", end + 2);
    } else {
      while (end !== -1) {
        let n = 0;
        while (this.buffer[end - 1 - n] === "\\")
          n += 1;
        if (n % 2 === 0)
          break;
        end = this.buffer.indexOf('"', end + 1);
      }
    }
    const qb = this.buffer.substring(0, end);
    let nl = qb.indexOf("\n", this.pos);
    if (nl !== -1) {
      while (nl !== -1) {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = qb.indexOf("\n", cs);
      }
      if (nl !== -1) {
        end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
      }
    }
    if (end === -1) {
      if (!this.atEnd)
        return this.setNext("quoted-scalar");
      end = this.buffer.length;
    }
    yield* this.pushToIndex(end + 1, false);
    return this.flowLevel ? "flow" : "doc";
  }
  *parseBlockScalarHeader() {
    this.blockScalarIndent = -1;
    this.blockScalarKeep = false;
    let i = this.pos;
    while (true) {
      const ch = this.buffer[++i];
      if (ch === "+")
        this.blockScalarKeep = true;
      else if (ch > "0" && ch <= "9")
        this.blockScalarIndent = Number(ch) - 1;
      else if (ch !== "-")
        break;
    }
    return yield* this.pushUntil((ch) => isEmpty$1(ch) || ch === "#");
  }
  *parseBlockScalar() {
    let nl = this.pos - 1;
    let indent = 0;
    let ch;
    loop: for (let i2 = this.pos; ch = this.buffer[i2]; ++i2) {
      switch (ch) {
        case " ":
          indent += 1;
          break;
        case "\n":
          nl = i2;
          indent = 0;
          break;
        case "\r": {
          const next = this.buffer[i2 + 1];
          if (!next && !this.atEnd)
            return this.setNext("block-scalar");
          if (next === "\n")
            break;
        }
        // fallthrough
        default:
          break loop;
      }
    }
    if (!ch && !this.atEnd)
      return this.setNext("block-scalar");
    if (indent >= this.indentNext) {
      if (this.blockScalarIndent === -1)
        this.indentNext = indent;
      else {
        this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
      }
      do {
        const cs = this.continueScalar(nl + 1);
        if (cs === -1)
          break;
        nl = this.buffer.indexOf("\n", cs);
      } while (nl !== -1);
      if (nl === -1) {
        if (!this.atEnd)
          return this.setNext("block-scalar");
        nl = this.buffer.length;
      }
    }
    let i = nl + 1;
    ch = this.buffer[i];
    while (ch === " ")
      ch = this.buffer[++i];
    if (ch === "	") {
      while (ch === "	" || ch === " " || ch === "\r" || ch === "\n")
        ch = this.buffer[++i];
      nl = i - 1;
    } else if (!this.blockScalarKeep) {
      do {
        let i2 = nl - 1;
        let ch2 = this.buffer[i2];
        if (ch2 === "\r")
          ch2 = this.buffer[--i2];
        const lastChar = i2;
        while (ch2 === " ")
          ch2 = this.buffer[--i2];
        if (ch2 === "\n" && i2 >= this.pos && i2 + 1 + indent > lastChar)
          nl = i2;
        else
          break;
      } while (true);
    }
    yield SCALAR;
    yield* this.pushToIndex(nl + 1, true);
    return yield* this.parseLineStart();
  }
  *parsePlainScalar() {
    const inFlow = this.flowLevel > 0;
    let end = this.pos - 1;
    let i = this.pos - 1;
    let ch;
    while (ch = this.buffer[++i]) {
      if (ch === ":") {
        const next = this.buffer[i + 1];
        if (isEmpty$1(next) || inFlow && flowIndicatorChars.has(next))
          break;
        end = i;
      } else if (isEmpty$1(ch)) {
        let next = this.buffer[i + 1];
        if (ch === "\r") {
          if (next === "\n") {
            i += 1;
            ch = "\n";
            next = this.buffer[i + 1];
          } else
            end = i;
        }
        if (next === "#" || inFlow && flowIndicatorChars.has(next))
          break;
        if (ch === "\n") {
          const cs = this.continueScalar(i + 1);
          if (cs === -1)
            break;
          i = Math.max(i, cs - 2);
        }
      } else {
        if (inFlow && flowIndicatorChars.has(ch))
          break;
        end = i;
      }
    }
    if (!ch && !this.atEnd)
      return this.setNext("plain-scalar");
    yield SCALAR;
    yield* this.pushToIndex(end + 1, true);
    return inFlow ? "flow" : "doc";
  }
  *pushCount(n) {
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos += n;
      return n;
    }
    return 0;
  }
  *pushToIndex(i, allowEmpty) {
    const s = this.buffer.slice(this.pos, i);
    if (s) {
      yield s;
      this.pos += s.length;
      return s.length;
    } else if (allowEmpty)
      yield "";
    return 0;
  }
  *pushIndicators() {
    switch (this.charAt(0)) {
      case "!":
        return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "&":
        return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
      case "-":
      // this is an error
      case "?":
      // this is an error outside flow collections
      case ":": {
        const inFlow = this.flowLevel > 0;
        const ch1 = this.charAt(1);
        if (isEmpty$1(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
          if (!inFlow)
            this.indentNext = this.indentValue + 1;
          else if (this.flowKey)
            this.flowKey = false;
          return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
        }
      }
    }
    return 0;
  }
  *pushTag() {
    if (this.charAt(1) === "<") {
      let i = this.pos + 2;
      let ch = this.buffer[i];
      while (!isEmpty$1(ch) && ch !== ">")
        ch = this.buffer[++i];
      return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
    } else {
      let i = this.pos + 1;
      let ch = this.buffer[i];
      while (ch) {
        if (tagChars.has(ch))
          ch = this.buffer[++i];
        else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
          ch = this.buffer[i += 3];
        } else
          break;
      }
      return yield* this.pushToIndex(i, false);
    }
  }
  *pushNewline() {
    const ch = this.buffer[this.pos];
    if (ch === "\n")
      return yield* this.pushCount(1);
    else if (ch === "\r" && this.charAt(1) === "\n")
      return yield* this.pushCount(2);
    else
      return 0;
  }
  *pushSpaces(allowTabs) {
    let i = this.pos - 1;
    let ch;
    do {
      ch = this.buffer[++i];
    } while (ch === " " || allowTabs && ch === "	");
    const n = i - this.pos;
    if (n > 0) {
      yield this.buffer.substr(this.pos, n);
      this.pos = i;
    }
    return n;
  }
  *pushUntil(test) {
    let i = this.pos;
    let ch = this.buffer[i];
    while (!test(ch))
      ch = this.buffer[++i];
    return yield* this.pushToIndex(i, false);
  }
}
class LineCounter {
  constructor() {
    this.lineStarts = [];
    this.addNewLine = (offset2) => this.lineStarts.push(offset2);
    this.linePos = (offset2) => {
      let low = 0;
      let high = this.lineStarts.length;
      while (low < high) {
        const mid = low + high >> 1;
        if (this.lineStarts[mid] < offset2)
          low = mid + 1;
        else
          high = mid;
      }
      if (this.lineStarts[low] === offset2)
        return { line: low + 1, col: 1 };
      if (low === 0)
        return { line: 0, col: offset2 };
      const start = this.lineStarts[low - 1];
      return { line: low, col: offset2 - start + 1 };
    };
  }
}
function includesToken(list, type) {
  for (let i = 0; i < list.length; ++i)
    if (list[i].type === type)
      return true;
  return false;
}
function findNonEmptyIndex(list) {
  for (let i = 0; i < list.length; ++i) {
    switch (list[i].type) {
      case "space":
      case "comment":
      case "newline":
        break;
      default:
        return i;
    }
  }
  return -1;
}
function isFlowToken(token) {
  switch (token?.type) {
    case "alias":
    case "scalar":
    case "single-quoted-scalar":
    case "double-quoted-scalar":
    case "flow-collection":
      return true;
    default:
      return false;
  }
}
function getPrevProps(parent) {
  switch (parent.type) {
    case "document":
      return parent.start;
    case "block-map": {
      const it = parent.items[parent.items.length - 1];
      return it.sep ?? it.start;
    }
    case "block-seq":
      return parent.items[parent.items.length - 1].start;
    /* istanbul ignore next should not happen */
    default:
      return [];
  }
}
function getFirstKeyStartProps(prev) {
  if (prev.length === 0)
    return [];
  let i = prev.length;
  loop: while (--i >= 0) {
    switch (prev[i].type) {
      case "doc-start":
      case "explicit-key-ind":
      case "map-value-ind":
      case "seq-item-ind":
      case "newline":
        break loop;
    }
  }
  while (prev[++i]?.type === "space") {
  }
  return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
  if (fc.start.type === "flow-seq-start") {
    for (const it of fc.items) {
      if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
        if (it.key)
          it.value = it.key;
        delete it.key;
        if (isFlowToken(it.value)) {
          if (it.value.end)
            Array.prototype.push.apply(it.value.end, it.sep);
          else
            it.value.end = it.sep;
        } else
          Array.prototype.push.apply(it.start, it.sep);
        delete it.sep;
      }
    }
  }
}
let Parser$2 = class Parser {
  /**
   * @param onNewLine - If defined, called separately with the start position of
   *   each new line (in `parse()`, including the start of input).
   */
  constructor(onNewLine) {
    this.atNewLine = true;
    this.atScalar = false;
    this.indent = 0;
    this.offset = 0;
    this.onKeyLine = false;
    this.stack = [];
    this.source = "";
    this.type = "";
    this.lexer = new Lexer();
    this.onNewLine = onNewLine;
  }
  /**
   * Parse `source` as a YAML stream.
   * If `incomplete`, a part of the last line may be left as a buffer for the next call.
   *
   * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
   *
   * @returns A generator of tokens representing each directive, document, and other structure.
   */
  *parse(source, incomplete = false) {
    if (this.onNewLine && this.offset === 0)
      this.onNewLine(0);
    for (const lexeme of this.lexer.lex(source, incomplete))
      yield* this.next(lexeme);
    if (!incomplete)
      yield* this.end();
  }
  /**
   * Advance the parser by the `source` of one lexical token.
   */
  *next(source) {
    this.source = source;
    if (this.atScalar) {
      this.atScalar = false;
      yield* this.step();
      this.offset += source.length;
      return;
    }
    const type = tokenType(source);
    if (!type) {
      const message2 = `Not a YAML token: ${source}`;
      yield* this.pop({ type: "error", offset: this.offset, message: message2, source });
      this.offset += source.length;
    } else if (type === "scalar") {
      this.atNewLine = false;
      this.atScalar = true;
      this.type = "scalar";
    } else {
      this.type = type;
      yield* this.step();
      switch (type) {
        case "newline":
          this.atNewLine = true;
          this.indent = 0;
          if (this.onNewLine)
            this.onNewLine(this.offset + source.length);
          break;
        case "space":
          if (this.atNewLine && source[0] === " ")
            this.indent += source.length;
          break;
        case "explicit-key-ind":
        case "map-value-ind":
        case "seq-item-ind":
          if (this.atNewLine)
            this.indent += source.length;
          break;
        case "doc-mode":
        case "flow-error-end":
          return;
        default:
          this.atNewLine = false;
      }
      this.offset += source.length;
    }
  }
  /** Call at end of input to push out any remaining constructions */
  *end() {
    while (this.stack.length > 0)
      yield* this.pop();
  }
  get sourceToken() {
    const st = {
      type: this.type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
    return st;
  }
  *step() {
    const top = this.peek(1);
    if (this.type === "doc-end" && (!top || top.type !== "doc-end")) {
      while (this.stack.length > 0)
        yield* this.pop();
      this.stack.push({
        type: "doc-end",
        offset: this.offset,
        source: this.source
      });
      return;
    }
    if (!top)
      return yield* this.stream();
    switch (top.type) {
      case "document":
        return yield* this.document(top);
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return yield* this.scalar(top);
      case "block-scalar":
        return yield* this.blockScalar(top);
      case "block-map":
        return yield* this.blockMap(top);
      case "block-seq":
        return yield* this.blockSequence(top);
      case "flow-collection":
        return yield* this.flowCollection(top);
      case "doc-end":
        return yield* this.documentEnd(top);
    }
    yield* this.pop();
  }
  peek(n) {
    return this.stack[this.stack.length - n];
  }
  *pop(error) {
    const token = error ?? this.stack.pop();
    if (!token) {
      const message2 = "Tried to pop an empty stack";
      yield { type: "error", offset: this.offset, source: "", message: message2 };
    } else if (this.stack.length === 0) {
      yield token;
    } else {
      const top = this.peek(1);
      if (token.type === "block-scalar") {
        token.indent = "indent" in top ? top.indent : 0;
      } else if (token.type === "flow-collection" && top.type === "document") {
        token.indent = 0;
      }
      if (token.type === "flow-collection")
        fixFlowSeqItems(token);
      switch (top.type) {
        case "document":
          top.value = token;
          break;
        case "block-scalar":
          top.props.push(token);
          break;
        case "block-map": {
          const it = top.items[top.items.length - 1];
          if (it.value) {
            top.items.push({ start: [], key: token, sep: [] });
            this.onKeyLine = true;
            return;
          } else if (it.sep) {
            it.value = token;
          } else {
            Object.assign(it, { key: token, sep: [] });
            this.onKeyLine = !it.explicitKey;
            return;
          }
          break;
        }
        case "block-seq": {
          const it = top.items[top.items.length - 1];
          if (it.value)
            top.items.push({ start: [], value: token });
          else
            it.value = token;
          break;
        }
        case "flow-collection": {
          const it = top.items[top.items.length - 1];
          if (!it || it.value)
            top.items.push({ start: [], key: token, sep: [] });
          else if (it.sep)
            it.value = token;
          else
            Object.assign(it, { key: token, sep: [] });
          return;
        }
        /* istanbul ignore next should not happen */
        default:
          yield* this.pop();
          yield* this.pop(token);
      }
      if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
        const last2 = token.items[token.items.length - 1];
        if (last2 && !last2.sep && !last2.value && last2.start.length > 0 && findNonEmptyIndex(last2.start) === -1 && (token.indent === 0 || last2.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
          if (top.type === "document")
            top.end = last2.start;
          else
            top.items.push({ start: last2.start });
          token.items.splice(-1, 1);
        }
      }
    }
  }
  *stream() {
    switch (this.type) {
      case "directive-line":
        yield { type: "directive", offset: this.offset, source: this.source };
        return;
      case "byte-order-mark":
      case "space":
      case "comment":
      case "newline":
        yield this.sourceToken;
        return;
      case "doc-mode":
      case "doc-start": {
        const doc = {
          type: "document",
          offset: this.offset,
          start: []
        };
        if (this.type === "doc-start")
          doc.start.push(this.sourceToken);
        this.stack.push(doc);
        return;
      }
    }
    yield {
      type: "error",
      offset: this.offset,
      message: `Unexpected ${this.type} token in YAML stream`,
      source: this.source
    };
  }
  *document(doc) {
    if (doc.value)
      return yield* this.lineEnd(doc);
    switch (this.type) {
      case "doc-start": {
        if (findNonEmptyIndex(doc.start) !== -1) {
          yield* this.pop();
          yield* this.step();
        } else
          doc.start.push(this.sourceToken);
        return;
      }
      case "anchor":
      case "tag":
      case "space":
      case "comment":
      case "newline":
        doc.start.push(this.sourceToken);
        return;
    }
    const bv = this.startBlockValue(doc);
    if (bv)
      this.stack.push(bv);
    else {
      yield {
        type: "error",
        offset: this.offset,
        message: `Unexpected ${this.type} token in YAML document`,
        source: this.source
      };
    }
  }
  *scalar(scalar) {
    if (this.type === "map-value-ind") {
      const prev = getPrevProps(this.peek(2));
      const start = getFirstKeyStartProps(prev);
      let sep2;
      if (scalar.end) {
        sep2 = scalar.end;
        sep2.push(this.sourceToken);
        delete scalar.end;
      } else
        sep2 = [this.sourceToken];
      const map2 = {
        type: "block-map",
        offset: scalar.offset,
        indent: scalar.indent,
        items: [{ start, key: scalar, sep: sep2 }]
      };
      this.onKeyLine = true;
      this.stack[this.stack.length - 1] = map2;
    } else
      yield* this.lineEnd(scalar);
  }
  *blockScalar(scalar) {
    switch (this.type) {
      case "space":
      case "comment":
      case "newline":
        scalar.props.push(this.sourceToken);
        return;
      case "scalar":
        scalar.source = this.source;
        this.atNewLine = true;
        this.indent = 0;
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        yield* this.pop();
        break;
      /* istanbul ignore next should not happen */
      default:
        yield* this.pop();
        yield* this.step();
    }
  }
  *blockMap(map2) {
    const it = map2.items[map2.items.length - 1];
    switch (this.type) {
      case "newline":
        this.onKeyLine = false;
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last2 = Array.isArray(end) ? end[end.length - 1] : void 0;
          if (last2?.type === "comment")
            end?.push(this.sourceToken);
          else
            map2.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          it.start.push(this.sourceToken);
        }
        return;
      case "space":
      case "comment":
        if (it.value) {
          map2.items.push({ start: [this.sourceToken] });
        } else if (it.sep) {
          it.sep.push(this.sourceToken);
        } else {
          if (this.atIndentedComment(it.start, map2.indent)) {
            const prev = map2.items[map2.items.length - 2];
            const end = prev?.value?.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              map2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
    }
    if (this.indent >= map2.indent) {
      const atMapIndent = !this.onKeyLine && this.indent === map2.indent;
      const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
      let start = [];
      if (atNextItem && it.sep && !it.value) {
        const nl = [];
        for (let i = 0; i < it.sep.length; ++i) {
          const st = it.sep[i];
          switch (st.type) {
            case "newline":
              nl.push(i);
              break;
            case "space":
              break;
            case "comment":
              if (st.indent > map2.indent)
                nl.length = 0;
              break;
            default:
              nl.length = 0;
          }
        }
        if (nl.length >= 2)
          start = it.sep.splice(nl[1]);
      }
      switch (this.type) {
        case "anchor":
        case "tag":
          if (atNextItem || it.value) {
            start.push(this.sourceToken);
            map2.items.push({ start });
            this.onKeyLine = true;
          } else if (it.sep) {
            it.sep.push(this.sourceToken);
          } else {
            it.start.push(this.sourceToken);
          }
          return;
        case "explicit-key-ind":
          if (!it.sep && !it.explicitKey) {
            it.start.push(this.sourceToken);
            it.explicitKey = true;
          } else if (atNextItem || it.value) {
            start.push(this.sourceToken);
            map2.items.push({ start, explicitKey: true });
          } else {
            this.stack.push({
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken], explicitKey: true }]
            });
          }
          this.onKeyLine = true;
          return;
        case "map-value-ind":
          if (it.explicitKey) {
            if (!it.sep) {
              if (includesToken(it.start, "newline")) {
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              } else {
                const start2 = getFirstKeyStartProps(it.start);
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                });
              }
            } else if (it.value) {
              map2.items.push({ start: [], key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start, key: null, sep: [this.sourceToken] }]
              });
            } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
              const start2 = getFirstKeyStartProps(it.start);
              const key = it.key;
              const sep2 = it.sep;
              sep2.push(this.sourceToken);
              delete it.key;
              delete it.sep;
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: start2, key, sep: sep2 }]
              });
            } else if (start.length > 0) {
              it.sep = it.sep.concat(start, this.sourceToken);
            } else {
              it.sep.push(this.sourceToken);
            }
          } else {
            if (!it.sep) {
              Object.assign(it, { key: null, sep: [this.sourceToken] });
            } else if (it.value || atNextItem) {
              map2.items.push({ start, key: null, sep: [this.sourceToken] });
            } else if (includesToken(it.sep, "map-value-ind")) {
              this.stack.push({
                type: "block-map",
                offset: this.offset,
                indent: this.indent,
                items: [{ start: [], key: null, sep: [this.sourceToken] }]
              });
            } else {
              it.sep.push(this.sourceToken);
            }
          }
          this.onKeyLine = true;
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs2 = this.flowScalar(this.type);
          if (atNextItem || it.value) {
            map2.items.push({ start, key: fs2, sep: [] });
            this.onKeyLine = true;
          } else if (it.sep) {
            this.stack.push(fs2);
          } else {
            Object.assign(it, { key: fs2, sep: [] });
            this.onKeyLine = true;
          }
          return;
        }
        default: {
          const bv = this.startBlockValue(map2);
          if (bv) {
            if (bv.type === "block-seq") {
              if (!it.explicitKey && it.sep && !includesToken(it.sep, "newline")) {
                yield* this.pop({
                  type: "error",
                  offset: this.offset,
                  message: "Unexpected block-seq-ind on same line with key",
                  source: this.source
                });
                return;
              }
            } else if (atMapIndent) {
              map2.items.push({ start });
            }
            this.stack.push(bv);
            return;
          }
        }
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *blockSequence(seq2) {
    const it = seq2.items[seq2.items.length - 1];
    switch (this.type) {
      case "newline":
        if (it.value) {
          const end = "end" in it.value ? it.value.end : void 0;
          const last2 = Array.isArray(end) ? end[end.length - 1] : void 0;
          if (last2?.type === "comment")
            end?.push(this.sourceToken);
          else
            seq2.items.push({ start: [this.sourceToken] });
        } else
          it.start.push(this.sourceToken);
        return;
      case "space":
      case "comment":
        if (it.value)
          seq2.items.push({ start: [this.sourceToken] });
        else {
          if (this.atIndentedComment(it.start, seq2.indent)) {
            const prev = seq2.items[seq2.items.length - 2];
            const end = prev?.value?.end;
            if (Array.isArray(end)) {
              Array.prototype.push.apply(end, it.start);
              end.push(this.sourceToken);
              seq2.items.pop();
              return;
            }
          }
          it.start.push(this.sourceToken);
        }
        return;
      case "anchor":
      case "tag":
        if (it.value || this.indent <= seq2.indent)
          break;
        it.start.push(this.sourceToken);
        return;
      case "seq-item-ind":
        if (this.indent !== seq2.indent)
          break;
        if (it.value || includesToken(it.start, "seq-item-ind"))
          seq2.items.push({ start: [this.sourceToken] });
        else
          it.start.push(this.sourceToken);
        return;
    }
    if (this.indent > seq2.indent) {
      const bv = this.startBlockValue(seq2);
      if (bv) {
        this.stack.push(bv);
        return;
      }
    }
    yield* this.pop();
    yield* this.step();
  }
  *flowCollection(fc) {
    const it = fc.items[fc.items.length - 1];
    if (this.type === "flow-error-end") {
      let top;
      do {
        yield* this.pop();
        top = this.peek(1);
      } while (top && top.type === "flow-collection");
    } else if (fc.end.length === 0) {
      switch (this.type) {
        case "comma":
        case "explicit-key-ind":
          if (!it || it.sep)
            fc.items.push({ start: [this.sourceToken] });
          else
            it.start.push(this.sourceToken);
          return;
        case "map-value-ind":
          if (!it || it.value)
            fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            Object.assign(it, { key: null, sep: [this.sourceToken] });
          return;
        case "space":
        case "comment":
        case "newline":
        case "anchor":
        case "tag":
          if (!it || it.value)
            fc.items.push({ start: [this.sourceToken] });
          else if (it.sep)
            it.sep.push(this.sourceToken);
          else
            it.start.push(this.sourceToken);
          return;
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar": {
          const fs2 = this.flowScalar(this.type);
          if (!it || it.value)
            fc.items.push({ start: [], key: fs2, sep: [] });
          else if (it.sep)
            this.stack.push(fs2);
          else
            Object.assign(it, { key: fs2, sep: [] });
          return;
        }
        case "flow-map-end":
        case "flow-seq-end":
          fc.end.push(this.sourceToken);
          return;
      }
      const bv = this.startBlockValue(fc);
      if (bv)
        this.stack.push(bv);
      else {
        yield* this.pop();
        yield* this.step();
      }
    } else {
      const parent = this.peek(2);
      if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
        yield* this.pop();
        yield* this.step();
      } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        fixFlowSeqItems(fc);
        const sep2 = fc.end.splice(1, fc.end.length);
        sep2.push(this.sourceToken);
        const map2 = {
          type: "block-map",
          offset: fc.offset,
          indent: fc.indent,
          items: [{ start, key: fc, sep: sep2 }]
        };
        this.onKeyLine = true;
        this.stack[this.stack.length - 1] = map2;
      } else {
        yield* this.lineEnd(fc);
      }
    }
  }
  flowScalar(type) {
    if (this.onNewLine) {
      let nl = this.source.indexOf("\n") + 1;
      while (nl !== 0) {
        this.onNewLine(this.offset + nl);
        nl = this.source.indexOf("\n", nl) + 1;
      }
    }
    return {
      type,
      offset: this.offset,
      indent: this.indent,
      source: this.source
    };
  }
  startBlockValue(parent) {
    switch (this.type) {
      case "alias":
      case "scalar":
      case "single-quoted-scalar":
      case "double-quoted-scalar":
        return this.flowScalar(this.type);
      case "block-scalar-header":
        return {
          type: "block-scalar",
          offset: this.offset,
          indent: this.indent,
          props: [this.sourceToken],
          source: ""
        };
      case "flow-map-start":
      case "flow-seq-start":
        return {
          type: "flow-collection",
          offset: this.offset,
          indent: this.indent,
          start: this.sourceToken,
          items: [],
          end: []
        };
      case "seq-item-ind":
        return {
          type: "block-seq",
          offset: this.offset,
          indent: this.indent,
          items: [{ start: [this.sourceToken] }]
        };
      case "explicit-key-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        start.push(this.sourceToken);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start, explicitKey: true }]
        };
      }
      case "map-value-ind": {
        this.onKeyLine = true;
        const prev = getPrevProps(parent);
        const start = getFirstKeyStartProps(prev);
        return {
          type: "block-map",
          offset: this.offset,
          indent: this.indent,
          items: [{ start, key: null, sep: [this.sourceToken] }]
        };
      }
    }
    return null;
  }
  atIndentedComment(start, indent) {
    if (this.type !== "comment")
      return false;
    if (this.indent <= indent)
      return false;
    return start.every((st) => st.type === "newline" || st.type === "space");
  }
  *documentEnd(docEnd) {
    if (this.type !== "doc-mode") {
      if (docEnd.end)
        docEnd.end.push(this.sourceToken);
      else
        docEnd.end = [this.sourceToken];
      if (this.type === "newline")
        yield* this.pop();
    }
  }
  *lineEnd(token) {
    switch (this.type) {
      case "comma":
      case "doc-start":
      case "doc-end":
      case "flow-seq-end":
      case "flow-map-end":
      case "map-value-ind":
        yield* this.pop();
        yield* this.step();
        break;
      case "newline":
        this.onKeyLine = false;
      // fallthrough
      case "space":
      case "comment":
      default:
        if (token.end)
          token.end.push(this.sourceToken);
        else
          token.end = [this.sourceToken];
        if (this.type === "newline")
          yield* this.pop();
    }
  }
};
function parseOptions(options) {
  const prettyErrors = options.prettyErrors !== false;
  const lineCounter = options.lineCounter || prettyErrors && new LineCounter() || null;
  return { lineCounter, prettyErrors };
}
function parseDocument(source, options = {}) {
  const { lineCounter, prettyErrors } = parseOptions(options);
  const parser = new Parser$2(lineCounter?.addNewLine);
  const composer = new Composer(options);
  let doc = null;
  for (const _doc of composer.compose(parser.parse(source), true, source.length)) {
    if (!doc)
      doc = _doc;
    else if (doc.options.logLevel !== "silent") {
      doc.errors.push(new YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
      break;
    }
  }
  if (prettyErrors && lineCounter) {
    doc.errors.forEach(prettifyError(source, lineCounter));
    doc.warnings.forEach(prettifyError(source, lineCounter));
  }
  return doc;
}
function parse(src, reviver, options) {
  let _reviver = void 0;
  if (typeof reviver === "function") {
    _reviver = reviver;
  } else if (options === void 0 && reviver && typeof reviver === "object") {
    options = reviver;
  }
  const doc = parseDocument(src, options);
  if (!doc)
    return null;
  doc.warnings.forEach((warning) => warn(doc.options.logLevel, warning));
  if (doc.errors.length > 0) {
    if (doc.options.logLevel !== "silent")
      throw doc.errors[0];
    else
      doc.errors = [];
  }
  return doc.toJS(Object.assign({ reviver: _reviver }, options));
}
var util;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first2, second) => {
    return {
      ...first2,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
const ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
class ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        const firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [];
        fieldErrors[firstEl].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
const errorMap = (issue, _ctx) => {
  let message2;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message2 = "Required";
      } else {
        message2 = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message2 = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message2 = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message2 = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message2 = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message2 = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message2 = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message2 = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message2 = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message2 = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message2 = `${message2} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message2 = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message2 = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message2 = `Invalid ${issue.validation}`;
      } else {
        message2 = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message2 = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message2 = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message2 = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "bigint")
        message2 = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message2 = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message2 = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message2 = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message2 = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message2 = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message2 = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message2 = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message2 = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message2 = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message2 = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message2 = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message2 = "Number must be finite";
      break;
    default:
      message2 = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message: message2 };
};
let overrideErrorMap = errorMap;
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map2 of maps) {
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs2) {
    const syncPairs = [];
    for (const pair of pairs2) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs2) {
    const finalObject = {};
    for (const pair of pairs2) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x) => x.status === "aborted";
const isDirty = (x) => x.status === "dirty";
const isValid = (x) => x.status === "valid";
const isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message2) => typeof message2 === "string" ? { message: message2 } : message2 || {};
  errorUtil2.toString = (message2) => typeof message2 === "string" ? message2 : message2?.message;
})(errorUtil || (errorUtil = {}));
class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (Array.isArray(this._key)) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message: message2 } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message2 ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message2 ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message2 ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
class ZodType {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    const ctx = {
      common: {
        issues: [],
        async: params?.async ?? false,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    const ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async) {
      try {
        const result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        if (err?.message?.toLowerCase()?.includes("encountered")) {
          this["~standard"].async = true;
        }
        ctx.common = {
          issues: [],
          async: true
        };
      }
    }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: true
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message2) {
    const getIssueProperties = (val) => {
      if (typeof message2 === "string" || typeof message2 === "undefined") {
        return { message: message2 };
      } else if (typeof message2 === "function") {
        return message2(val);
      } else {
        return message2;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
    this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
const ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
const ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version) {
  if ((version === "v4" || !version) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "jwt") {
        if (!isValidJWT(input.data, check.alg)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "jwt",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cidr") {
        if (!isValidCidr(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cidr",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64url") {
        if (!base64urlRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message2) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message2)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message2) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message2) });
  }
  url(message2) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message2) });
  }
  emoji(message2) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message2) });
  }
  uuid(message2) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message2) });
  }
  nanoid(message2) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message2) });
  }
  cuid(message2) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message2) });
  }
  cuid2(message2) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message2) });
  }
  ulid(message2) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message2) });
  }
  base64(message2) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message2) });
  }
  base64url(message2) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message2)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      offset: options?.offset ?? false,
      local: options?.local ?? false,
      ...errorUtil.errToObj(options?.message)
    });
  }
  date(message2) {
    return this._addCheck({ kind: "date", message: message2 });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof options?.precision === "undefined" ? null : options?.precision,
      ...errorUtil.errToObj(options?.message)
    });
  }
  duration(message2) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message2) });
  }
  regex(regex, message2) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message2)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options?.position,
      ...errorUtil.errToObj(options?.message)
    });
  }
  startsWith(value, message2) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message2)
    });
  }
  endsWith(value, message2) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message2)
    });
  }
  min(minLength, message2) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message2)
    });
  }
  max(maxLength, message2) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message2)
    });
  }
  length(len, message2) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message2)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message2) {
    return this.min(1, errorUtil.errToObj(message2));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step2) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step2.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step2.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message2) {
    return this.setLimit("min", value, true, errorUtil.toString(message2));
  }
  gt(value, message2) {
    return this.setLimit("min", value, false, errorUtil.toString(message2));
  }
  lte(value, message2) {
    return this.setLimit("max", value, true, errorUtil.toString(message2));
  }
  lt(value, message2) {
    return this.setLimit("max", value, false, errorUtil.toString(message2));
  }
  setLimit(kind, value, inclusive, message2) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message2)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message2) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message2)
    });
  }
  positive(message2) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  negative(message2) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  nonpositive(message2) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  nonnegative(message2) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  multipleOf(value, message2) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message2)
    });
  }
  finite(message2) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message2)
    });
  }
  safe(message2) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message2)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message2)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null;
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      return this._getInvalidInput(input);
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    });
    return INVALID;
  }
  gte(value, message2) {
    return this.setLimit("min", value, true, errorUtil.toString(message2));
  }
  gt(value, message2) {
    return this.setLimit("min", value, false, errorUtil.toString(message2));
  }
  lte(value, message2) {
    return this.setLimit("max", value, true, errorUtil.toString(message2));
  }
  lt(value, message2) {
    return this.setLimit("max", value, false, errorUtil.toString(message2));
  }
  setLimit(kind, value, inclusive, message2) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message2)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message2) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  negative(message2) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message2)
    });
  }
  nonpositive(message2) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  nonnegative(message2) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message2)
    });
  }
  multipleOf(value, message2) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message2)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: params?.coerce ?? false,
    ...processCreateParams(params)
  });
};
class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: params?.coerce || false,
    ...processCreateParams(params)
  });
};
class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message2) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message2)
    });
  }
  max(maxDate, message2) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message2)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: params?.coerce || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message2) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message2) }
    });
  }
  max(maxLength, message2) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message2) }
    });
  }
  length(len, message2) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message2) }
    });
  }
  nonempty(message2) {
    return this.min(1, message2);
  }
}
ZodArray.create = (schema2, params) => {
  return new ZodArray({
    type: schema2,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema2) {
  if (schema2 instanceof ZodObject) {
    const newShape = {};
    for (const key in schema2.shape) {
      const fieldSchema = schema2.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema2._def,
      shape: () => newShape
    });
  } else if (schema2 instanceof ZodArray) {
    return new ZodArray({
      ...schema2._def,
      type: deepPartialify(schema2.element)
    });
  } else if (schema2 instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema2.unwrap()));
  } else if (schema2 instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema2.unwrap()));
  } else if (schema2 instanceof ZodTuple) {
    return ZodTuple.create(schema2.items.map((item) => deepPartialify(item)));
  } else {
    return schema2;
  }
}
class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    this._cached = { shape, keys };
    return this._cached;
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs2 = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs2.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs2.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs2.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs2) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs2);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message2) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message2 !== void 0 ? {
        errorMap: (issue, ctx) => {
          const defaultError = this._def.errorMap?.(issue, ctx).message ?? ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: errorUtil.errToObj(message2).message ?? defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema2) {
    return this.augment({ [key]: schema2 });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    for (const key of util.objectKeys(mask)) {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    for (const key of util.objectKeys(this.shape)) {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    }
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
const getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema2 = this._def.items[itemIndex] || this._def.rest;
      if (!schema2)
        return null;
      return schema2._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas2, params) => {
  if (!Array.isArray(schemas2)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas2,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs2 = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs2.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs2);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs2);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first2, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first2,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first2,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}
class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs2 = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs2) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs2) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message2) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message2) }
    });
  }
  max(maxSize, message2) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message2) }
    });
  }
  size(size2, message2) {
    return this.min(size2, message2).max(size2, message2);
  }
  nonempty(message2) {
    return this.min(1, message2);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), errorMap].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), errorMap].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(this._def.values);
    }
    if (!this._cache.has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!this._cache) {
      this._cache = new Set(util.getValidEnumValues(this._def.values));
    }
    if (!this._cache.has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema2, params) => {
  return new ZodPromise({
    type: schema2,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return INVALID;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
            status: status.value,
            value: result
          }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema2, effect, params) => {
  return new ZodEffects({
    schema: schema2,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema2, params) => {
  return new ZodEffects({
    schema: schema2,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const booleanType = ZodBoolean.create;
const unknownType = ZodUnknown.create;
ZodNever.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
ZodIntersection.create;
ZodTuple.create;
const recordType = ZodRecord.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
ZodPromise.create;
ZodOptional.create;
ZodNullable.create;
const filters$1 = {
  // String filters
  uppercase: (str) => String(str).toUpperCase(),
  lowercase: (str) => String(str).toLowerCase(),
  capitalize: (str) => {
    const s = String(str);
    return s.charAt(0).toUpperCase() + s.slice(1).toLowerCase();
  },
  trim: (str) => String(str).trim(),
  // Array/String filters
  split: (str, delimiter = " ") => String(str).split(delimiter),
  join: (arr, delimiter = ", ") => arr.join(delimiter),
  length: (value) => {
    if (typeof value === "string") return value.length;
    if (Array.isArray(value)) return value.length;
    return 0;
  },
  // Array filters
  first: (arr) => Array.isArray(arr) && arr.length > 0 ? arr[0] : void 0,
  last: (arr) => Array.isArray(arr) && arr.length > 0 ? arr[arr.length - 1] : void 0,
  slice: (arr, start, end) => Array.isArray(arr) ? arr.slice(start, end) : [],
  reverse: (arr) => Array.isArray(arr) ? [...arr].reverse() : [],
  sort: (arr) => Array.isArray(arr) ? [...arr].sort() : [],
  // Number filters
  abs: (num) => Math.abs(Number(num)),
  round: (num) => Math.round(Number(num)),
  floor: (num) => Math.floor(Number(num)),
  ceil: (num) => Math.ceil(Number(num)),
  // Type conversion
  string: (value) => String(value),
  number: (value) => Number(value),
  boolean: (value) => Boolean(value),
  // Object filters
  keys: (obj) => typeof obj === "object" && obj !== null ? Object.keys(obj) : [],
  values: (obj) => typeof obj === "object" && obj !== null ? Object.values(obj) : [],
  // Utility filters
  default: (value, defaultValue) => value !== void 0 && value !== null ? value : defaultValue,
  json: (value) => JSON.stringify(value)
};
function applyFilters(value, filterChain) {
  let result = value;
  for (const filterExpr of filterChain) {
    const match = filterExpr.match(/^(\w+)(?:\((.*)\))?$/);
    if (!match) {
      throw new Error(`Invalid filter syntax: ${filterExpr}`);
    }
    const [, filterName, argsStr] = match;
    const filter2 = filters$1[filterName];
    if (!filter2) {
      throw new Error(`Unknown filter: ${filterName}`);
    }
    const args = [];
    if (argsStr) {
      const argMatches = argsStr.match(/"[^"]*"|'[^']*'|[^,\s]+/g) || [];
      for (const arg of argMatches) {
        const trimmed = arg.trim();
        if (trimmed.startsWith('"') && trimmed.endsWith('"') || trimmed.startsWith("'") && trimmed.endsWith("'")) {
          args.push(trimmed.slice(1, -1));
        } else if (!isNaN(Number(trimmed))) {
          args.push(Number(trimmed));
        } else if (trimmed === "true" || trimmed === "false") {
          args.push(trimmed === "true");
        } else {
          args.push(trimmed);
        }
      }
    }
    result = filter2(result, ...args);
  }
  return result;
}
class StringResolver {
  constructor() {
    this.fullPatternDollar = /^\$\{([^}]*)\}$/;
    this.fullPatternHandlebar = /^\{\{([^}]*)\}\}$/;
    this.hasInterpolationPattern = /(\$\{[^}]*\}|\{\{[^}]*\}\})/;
  }
  // Either syntax
  canResolve(template2) {
    if (typeof template2 !== "string") return false;
    return this.fullPatternDollar.test(template2) || this.fullPatternHandlebar.test(template2) || this.hasInterpolationPattern.test(template2);
  }
  resolve(template2, context, interpolate) {
    const dollarMatch = template2.match(this.fullPatternDollar);
    const handlebarMatch = template2.match(this.fullPatternHandlebar);
    const fullMatch = dollarMatch || handlebarMatch;
    if (fullMatch) {
      const path = fullMatch[1].trim();
      if (!path) {
        return void 0;
      }
      return this.traversePath(path, context);
    }
    const result = template2.replace(
      /(\$\{([^}]*)\}|\{\{([^}]*)\}\})/g,
      (match, _full, dollarPath, handlebarPath) => {
        const path = dollarPath !== void 0 ? dollarPath : handlebarPath;
        const trimmedPath = path.trim();
        if (!trimmedPath) {
          return "";
        }
        const value = this.traversePath(trimmedPath, context);
        return value !== void 0 ? String(value) : match;
      }
    );
    return result;
  }
  /**
   * Traverse context using dot-separated path with optional operators and filter chain
   * Supports (in order of precedence):
   * - input.enabled ? "yes" : "no" (ternary conditional)
   * - input.name ?? "default" (nullish coalescing - null/undefined only)
   * - input.name || "default" (falsy coalescing - catches "", 0, false too)
   * - input.text | split(' ') | length (filters)
   * Note: We check for single pipe (filter) vs double pipe (|| logical OR)
   */
  traversePath(path, context) {
    const ternaryMatch = path.match(/^(.+?)\s*\?(?!\.)\s*(.+?)\s*:\s*(.+)$/);
    if (ternaryMatch) {
      const [, conditionPath, trueExpr, falseExpr] = ternaryMatch;
      const condition = this.resolvePathWithFilters(conditionPath.trim(), context);
      const selectedExpr = condition ? trueExpr.trim() : falseExpr.trim();
      return this.resolveLiteralOrPath(selectedExpr, context);
    }
    if (path.includes("??")) {
      const alternatives = path.split("??").map((alt) => alt.trim());
      for (const alt of alternatives) {
        const value = this.resolveLiteralOrPath(alt, context);
        if (value !== null && value !== void 0) {
          return value;
        }
      }
      return void 0;
    }
    if (/\|\|/.test(path)) {
      const alternatives = path.split("||").map((alt) => alt.trim());
      for (const alt of alternatives) {
        const value = this.resolveLiteralOrPath(alt, context);
        if (value) {
          return value;
        }
      }
      const lastAlt = alternatives[alternatives.length - 1];
      return this.resolveLiteralOrPath(lastAlt, context);
    }
    return this.resolvePathWithFilters(path, context);
  }
  /**
   * Resolve a value that could be a literal or a path expression
   */
  resolveLiteralOrPath(expr, context) {
    const stringLiteralMatch = expr.match(/^["'](.*)["']$/);
    if (stringLiteralMatch) {
      return stringLiteralMatch[1];
    }
    const numericMatch = expr.match(/^-?\d+(\.\d+)?$/);
    if (numericMatch) {
      return parseFloat(expr);
    }
    if (expr === "true") return true;
    if (expr === "false") return false;
    if (expr === "null") return null;
    return this.resolvePathWithFilters(expr, context);
  }
  /**
   * Resolve a path that may include filter chains
   */
  resolvePathWithFilters(path, context) {
    const hasSinglePipe = /(?<!\|)\|(?!\|)/.test(path);
    if (hasSinglePipe) {
      const parts = path.split(/(?<!\|)\|(?!\|)/);
      const propertyPath = parts[0].trim();
      let value = this.resolvePropertyPath(propertyPath, context);
      if (parts.length > 1) {
        const filterChain = parts.slice(1).map((f) => f.trim()).filter((f) => f.length > 0);
        if (filterChain.length > 0) {
          value = applyFilters(value, filterChain);
        }
      }
      return value;
    }
    return this.resolvePropertyPath(path, context);
  }
  /**
   * Resolve a simple dot-separated property path with support for:
   * - Array indexing: items[0], items[2].name
   * - Boolean negation: !input.disabled
   * - Optional chaining: input.user?.name, input.items?.[0]
   */
  resolvePropertyPath(path, context) {
    let negate = false;
    let actualPath = path;
    if (path.startsWith("!")) {
      negate = true;
      actualPath = path.slice(1).trim();
    }
    const segments = this.parsePathSegments(actualPath);
    let value = context;
    for (const segment of segments) {
      if (value === null || value === void 0) {
        if (segment.optional) {
          return negate ? true : void 0;
        }
        return negate ? true : void 0;
      }
      if (segment.arrayIndex !== void 0) {
        if (segment.name) {
          if (typeof value === "object" && segment.name in value) {
            value = value[segment.name];
          } else {
            return negate ? true : void 0;
          }
          if (value === null || value === void 0) {
            return negate ? true : void 0;
          }
        }
        if (Array.isArray(value) && segment.arrayIndex >= 0 && segment.arrayIndex < value.length) {
          value = value[segment.arrayIndex];
        } else {
          return negate ? true : void 0;
        }
      } else {
        if (typeof value === "object" && segment.name in value) {
          value = value[segment.name];
        } else {
          return negate ? true : void 0;
        }
      }
    }
    return negate ? !value : value;
  }
  /**
   * Parse a path string into segments, handling optional chaining (?.)
   *
   * Examples:
   * - "input.name"  [{name: "input", optional: false}, {name: "name", optional: false}]
   * - "input?.name"  [{name: "input", optional: false}, {name: "name", optional: true}]
   * - "items[0]"  [{name: "items", optional: false, arrayIndex: 0}]
   * - "items?.[0]"  [{name: "items", optional: false}, {name: "", optional: true, arrayIndex: 0}]
   */
  parsePathSegments(path) {
    const segments = [];
    let remaining = path.trim();
    while (remaining.length > 0) {
      let optional = false;
      if (remaining.startsWith("?.")) {
        optional = true;
        remaining = remaining.slice(2);
      } else if (remaining.startsWith(".") && segments.length > 0) {
        remaining = remaining.slice(1);
      }
      const standaloneArrayMatch = remaining.match(/^\[(\d+)\]/);
      if (standaloneArrayMatch) {
        segments.push({
          name: "",
          optional,
          arrayIndex: parseInt(standaloneArrayMatch[1], 10)
        });
        remaining = remaining.slice(standaloneArrayMatch[0].length);
        continue;
      }
      const propMatch = remaining.match(/^([\w-]+)(?:\[(\d+)\])?/);
      if (propMatch) {
        const [fullMatch, propName, indexStr] = propMatch;
        segments.push({
          name: propName,
          optional,
          arrayIndex: indexStr !== void 0 ? parseInt(indexStr, 10) : void 0
        });
        remaining = remaining.slice(fullMatch.length);
      } else {
        break;
      }
    }
    return segments;
  }
}
class ArrayResolver {
  canResolve(template2) {
    return Array.isArray(template2);
  }
  resolve(template2, context, interpolate) {
    return template2.map((item) => interpolate(item, context));
  }
}
class ObjectResolver {
  canResolve(template2) {
    return typeof template2 === "object" && template2 !== null && !Array.isArray(template2);
  }
  resolve(template2, context, interpolate) {
    const resolved = {};
    for (const [key, value] of Object.entries(template2)) {
      resolved[key] = interpolate(value, context);
    }
    return resolved;
  }
}
class PassthroughResolver {
  canResolve(template2) {
    return true;
  }
  resolve(template2, context, interpolate) {
    return template2;
  }
}
class Interpolator {
  constructor(resolvers) {
    this.resolvers = resolvers || [
      new StringResolver(),
      new ArrayResolver(),
      new ObjectResolver(),
      new PassthroughResolver()
      // Must be last (catches all)
    ];
  }
  /**
   * Resolve template with context
   * Delegates to first resolver that can handle the template
   */
  resolve(template2, context) {
    for (const resolver of this.resolvers) {
      if (resolver.canResolve(template2)) {
        return resolver.resolve(template2, context, (t, c) => this.resolve(t, c));
      }
    }
    return template2;
  }
}
let globalInterpolator = null;
function getInterpolator() {
  if (!globalInterpolator) {
    globalInterpolator = new Interpolator();
  }
  return globalInterpolator;
}
var Operation = /* @__PURE__ */ ((Operation2) => {
  Operation2["think"] = "think";
  Operation2["code"] = "code";
  Operation2["storage"] = "storage";
  Operation2["data"] = "data";
  Operation2["http"] = "http";
  Operation2["tools"] = "tools";
  Operation2["scoring"] = "scoring";
  Operation2["email"] = "email";
  Operation2["sms"] = "sms";
  Operation2["form"] = "form";
  Operation2["html"] = "html";
  Operation2["pdf"] = "pdf";
  Operation2["queue"] = "queue";
  Operation2["autorag"] = "autorag";
  return Operation2;
})(Operation || {});
var AIProvider = /* @__PURE__ */ ((AIProvider2) => {
  AIProvider2["OpenAI"] = "openai";
  AIProvider2["Anthropic"] = "anthropic";
  AIProvider2["Cloudflare"] = "cloudflare";
  AIProvider2["Custom"] = "custom";
  return AIProvider2;
})(AIProvider || {});
var StorageType = /* @__PURE__ */ ((StorageType2) => {
  StorageType2["KV"] = "kv";
  StorageType2["R2"] = "r2";
  StorageType2["Cache"] = "cache";
  return StorageType2;
})(StorageType || {});
var DatabaseType = /* @__PURE__ */ ((DatabaseType2) => {
  DatabaseType2["D1"] = "d1";
  DatabaseType2["Hyperdrive"] = "hyperdrive";
  DatabaseType2["Vectorize"] = "vectorize";
  DatabaseType2["Supabase"] = "supabase";
  DatabaseType2["Neon"] = "neon";
  DatabaseType2["PlanetScale"] = "planetscale";
  return DatabaseType2;
})(DatabaseType || {});
const RedirectOutputSchema = objectType({
  url: stringType(),
  status: unionType([literalType(301), literalType(302), literalType(307), literalType(308)]).optional()
});
const OutputBlockSchema = objectType({
  when: stringType().optional(),
  status: numberType().int().min(100).max(599).optional(),
  headers: recordType(stringType()).optional(),
  body: unknownType().optional(),
  rawBody: stringType().optional(),
  redirect: RedirectOutputSchema.optional()
});
const EnsembleOutputSchema = unionType([
  // New: Array of conditional output blocks
  arrayType(OutputBlockSchema),
  // Legacy: Simple object output (will be wrapped as body)
  recordType(unknownType())
]);
function isConditionalOutput(output) {
  return Array.isArray(output);
}
function normalizeOutput(output) {
  if (isConditionalOutput(output)) {
    return output;
  }
  return [{ body: output }];
}
var LogLevel = /* @__PURE__ */ ((LogLevel2) => {
  LogLevel2["DEBUG"] = "debug";
  LogLevel2["INFO"] = "info";
  LogLevel2["WARN"] = "warn";
  LogLevel2["ERROR"] = "error";
  return LogLevel2;
})(LogLevel || {});
var define_process_env_default = {};
const LOG_LEVEL_PRIORITY = {
  [LogLevel.DEBUG]: 0,
  [LogLevel.INFO]: 1,
  [LogLevel.WARN]: 2,
  [LogLevel.ERROR]: 3
};
class ConductorLogger {
  constructor(config = {}, analyticsEngine, baseContext = {}) {
    const globalDebug = typeof globalThis !== "undefined" && "DEBUG" in globalThis ? globalThis.DEBUG === true : false;
    const isDebug = config.debug ?? (typeof process !== "undefined" && define_process_env_default?.DEBUG === "true" || globalDebug);
    this.config = {
      level: config.level ?? (isDebug ? LogLevel.DEBUG : LogLevel.INFO),
      serviceName: config.serviceName ?? "conductor",
      environment: config.environment ?? "production",
      debug: isDebug,
      enableAnalytics: config.enableAnalytics ?? true,
      baseContext: config.baseContext ?? {}
    };
    this.baseContext = Object.freeze({ ...this.config.baseContext, ...baseContext });
    this.analyticsEngine = analyticsEngine;
  }
  /**
   * Check if a log level should be output
   */
  shouldLog(level) {
    return LOG_LEVEL_PRIORITY[level] >= LOG_LEVEL_PRIORITY[this.config.level];
  }
  /**
   * Create structured log entry
   */
  createLogEntry(level, message2, context, error) {
    const entry = {
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      level,
      message: message2,
      ...Object.keys({ ...this.baseContext, ...context }).length > 0 && {
        context: { ...this.baseContext, ...context }
      }
    };
    if (error) {
      entry.error = {
        name: error.name,
        message: error.message,
        stack: error.stack,
        // Include ConductorError specific fields
        ...this.isConductorError(error) && {
          code: error.code,
          details: error.details
        }
      };
    }
    return entry;
  }
  /**
   * Type guard for ConductorError
   */
  isConductorError(error) {
    return "code" in error && "toJSON" in error;
  }
  /**
   * Output log entry via console
   *
   * Cloudflare Workers Logs automatically captures console output
   * and indexes JSON fields for querying in the dashboard.
   */
  log(entry) {
    if (!this.shouldLog(entry.level)) {
      return;
    }
    const logOutput = JSON.stringify(entry);
    switch (entry.level) {
      case LogLevel.DEBUG:
        console.debug(logOutput);
        break;
      case LogLevel.INFO:
        console.info(logOutput);
        break;
      case LogLevel.WARN:
        console.warn(logOutput);
        break;
      case LogLevel.ERROR:
        console.error(logOutput);
        break;
    }
  }
  /**
   * Log debug information
   *
   * Only output when DEBUG=true or log level is DEBUG.
   * Useful for development and troubleshooting.
   */
  debug(message2, context) {
    const entry = this.createLogEntry(LogLevel.DEBUG, message2, context);
    this.log(entry);
  }
  /**
   * Log informational message
   *
   * Use for normal operational events worth tracking.
   */
  info(message2, context) {
    const entry = this.createLogEntry(LogLevel.INFO, message2, context);
    this.log(entry);
  }
  /**
   * Log warning
   *
   * Use for concerning but non-critical issues.
   */
  warn(message2, context) {
    const entry = this.createLogEntry(LogLevel.WARN, message2, context);
    this.log(entry);
  }
  /**
   * Log error
   *
   * Use for errors that need attention.
   * Includes full error details and stack trace.
   */
  error(message2, error, context) {
    const entry = this.createLogEntry(LogLevel.ERROR, message2, context, error);
    this.log(entry);
  }
  /**
   * Create child logger with additional context
   *
   * Useful for adding request-specific or execution-specific context
   * that applies to all logs within a scope.
   *
   * @example
   * const requestLogger = logger.child({ requestId: '123', userId: 'alice' });
   * requestLogger.info('Processing request'); // Includes requestId and userId
   */
  child(context) {
    return new ConductorLogger(this.config, this.analyticsEngine, {
      ...this.baseContext,
      ...context
    });
  }
  /**
   * Record metric to Analytics Engine
   *
   * Analytics Engine provides unlimited-cardinality analytics at scale.
   * Use for high-volume metrics that need SQL querying.
   *
   * @example
   * logger.metric('ensemble.execution', {
   *   blobs: ['user-workflow', 'completed'],
   *   doubles: [1234], // duration in ms
   *   indexes: ['ensemble.execution']
   * });
   */
  metric(name, data) {
    if (!this.config.enableAnalytics || !this.analyticsEngine) {
      return;
    }
    try {
      this.analyticsEngine.writeDataPoint({
        blobs: data.blobs ?? [],
        doubles: data.doubles ?? [],
        indexes: data.indexes ?? [name]
      });
    } catch (error) {
      this.warn("Failed to write metric", {
        metricName: name,
        error: error instanceof Error ? error.message : "Unknown error"
      });
    }
  }
}
function createLogger(config = {}, analyticsEngine) {
  return new ConductorLogger(config, analyticsEngine);
}
const ModelId = {
  /**
   * Create a ModelId from a string
   * @throws {Error} if the model ID is invalid
   */
  create(value) {
    if (!value || value.trim().length === 0) {
      throw new Error("Model ID cannot be empty");
    }
    if (value.includes(" ")) {
      throw new Error(`Invalid model ID format: "${value}" (contains spaces)`);
    }
    return value.trim();
  },
  /**
   * Check if a string is a valid ModelId
   */
  isValid(value) {
    return !!value && value.trim().length > 0 && !value.includes(" ");
  },
  /**
   * Safely create a ModelId, returning null if invalid
   */
  tryCreate(value) {
    try {
      return ModelId.create(value);
    } catch {
      return null;
    }
  },
  /**
   * Unwrap a ModelId back to a string
   */
  unwrap(modelId) {
    return modelId;
  }
};
const AgentName = {
  /**
   * Create an AgentName from a string
   * @throws {Error} if the agent name is invalid
   */
  create(value) {
    if (!value || value.trim().length === 0) {
      throw new Error("Agent name cannot be empty");
    }
    const normalized = value.trim();
    if (!/^[a-z0-9-]+$/.test(normalized)) {
      throw new Error(
        `Invalid agent name format: "${value}" (must be lowercase alphanumeric with hyphens)`
      );
    }
    return normalized;
  },
  /**
   * Check if a string is a valid AgentName
   */
  isValid(value) {
    return !!value && /^[a-z0-9-]+$/.test(value.trim());
  },
  /**
   * Safely create an AgentName, returning null if invalid
   */
  tryCreate(value) {
    try {
      return AgentName.create(value);
    } catch {
      return null;
    }
  },
  /**
   * Unwrap an AgentName back to a string
   */
  unwrap(agentName) {
    return agentName;
  }
};
const EnsembleName = {
  /**
   * Create an EnsembleName from a string
   * @throws {Error} if the ensemble name is invalid
   */
  create(value) {
    if (!value || value.trim().length === 0) {
      throw new Error("Ensemble name cannot be empty");
    }
    const normalized = value.trim();
    if (!/^[a-z0-9-]+$/.test(normalized)) {
      throw new Error(
        `Invalid ensemble name format: "${value}" (must be lowercase alphanumeric with hyphens)`
      );
    }
    return normalized;
  },
  /**
   * Check if a string is a valid EnsembleName
   */
  isValid(value) {
    return !!value && /^[a-z0-9-]+$/.test(value.trim());
  },
  /**
   * Safely create an EnsembleName, returning null if invalid
   */
  tryCreate(value) {
    try {
      return EnsembleName.create(value);
    } catch {
      return null;
    }
  },
  /**
   * Unwrap an EnsembleName back to a string
   */
  unwrap(ensembleName) {
    return ensembleName;
  }
};
const ProviderId = {
  /**
   * Create a ProviderId from a string
   * @throws {Error} if the provider ID is invalid
   */
  create(value) {
    if (!value || value.trim().length === 0) {
      throw new Error("Provider ID cannot be empty");
    }
    const normalized = value.trim().toLowerCase();
    if (!/^[a-z0-9-]+$/.test(normalized)) {
      throw new Error(
        `Invalid provider ID format: "${value}" (must be lowercase alphanumeric with hyphens)`
      );
    }
    return normalized;
  },
  /**
   * Check if a string is a valid ProviderId
   */
  isValid(value) {
    return !!value && /^[a-z0-9-]+$/.test(value.trim().toLowerCase());
  },
  /**
   * Safely create a ProviderId, returning null if invalid
   */
  tryCreate(value) {
    try {
      return ProviderId.create(value);
    } catch {
      return null;
    }
  },
  /**
   * Unwrap a ProviderId back to a string
   */
  unwrap(providerId) {
    return providerId;
  }
};
const PlatformName = {
  /**
   * Create a PlatformName from a string
   * @throws {Error} if the platform name is invalid
   */
  create(value) {
    if (!value || value.trim().length === 0) {
      throw new Error("Platform name cannot be empty");
    }
    const normalized = value.trim().toLowerCase();
    return normalized;
  },
  /**
   * Check if a string is a valid PlatformName
   */
  isValid(value) {
    return !!value && value.trim().length > 0;
  },
  /**
   * Safely create a PlatformName, returning null if invalid
   */
  tryCreate(value) {
    try {
      return PlatformName.create(value);
    } catch {
      return null;
    }
  },
  /**
   * Unwrap a PlatformName back to a string
   */
  unwrap(platformName) {
    return platformName;
  }
};
const BindingName = {
  /**
   * Create a BindingName from a string
   * @throws {Error} if the binding name is invalid
   */
  create(value) {
    if (!value || value.trim().length === 0) {
      throw new Error("Binding name cannot be empty");
    }
    const normalized = value.trim();
    if (!/^[A-Z_][A-Z0-9_]*$/.test(normalized)) {
      throw new Error(
        `Invalid binding name format: "${value}" (must be UPPER_CASE with underscores)`
      );
    }
    return normalized;
  },
  /**
   * Check if a string is a valid BindingName
   */
  isValid(value) {
    return !!value && /^[A-Z_][A-Z0-9_]*$/.test(value.trim());
  },
  /**
   * Safely create a BindingName, returning null if invalid
   */
  tryCreate(value) {
    try {
      return BindingName.create(value);
    } catch {
      return null;
    }
  },
  /**
   * Unwrap a BindingName back to a string
   */
  unwrap(bindingName) {
    return bindingName;
  }
};
const VersionString = {
  /**
   * Create a VersionString from a string
   * @throws {Error} if the version string is invalid
   */
  create(value) {
    if (!value || value.trim().length === 0) {
      throw new Error("Version string cannot be empty");
    }
    return value.trim();
  },
  /**
   * Check if a string is a valid VersionString
   */
  isValid(value) {
    return !!value && value.trim().length > 0;
  },
  /**
   * Safely create a VersionString, returning null if invalid
   */
  tryCreate(value) {
    try {
      return VersionString.create(value);
    } catch {
      return null;
    }
  },
  /**
   * Unwrap a VersionString back to a string
   */
  unwrap(versionString) {
    return versionString;
  }
};
const ExecutionId = {
  /**
   * Create an ExecutionId from a string
   * @throws {Error} if the execution ID is invalid
   */
  create(value) {
    if (!value || value.trim().length === 0) {
      throw new Error("Execution ID cannot be empty");
    }
    const normalized = value.trim();
    if (!normalized.startsWith("exec_")) {
      throw new Error(
        `Invalid execution ID format: "${value}" (must start with 'exec_')`
      );
    }
    return normalized;
  },
  /**
   * Generate a new unique execution ID
   */
  generate() {
    return `exec_${crypto.randomUUID()}`;
  },
  /**
   * Check if a string is a valid ExecutionId
   */
  isValid(value) {
    return !!value && value.trim().startsWith("exec_");
  },
  /**
   * Safely create an ExecutionId, returning null if invalid
   */
  tryCreate(value) {
    try {
      return ExecutionId.create(value);
    } catch {
      return null;
    }
  },
  /**
   * Unwrap an ExecutionId back to a string
   */
  unwrap(executionId) {
    return executionId;
  }
};
const RequestId = {
  /**
   * Create a RequestId from a string
   * @throws {Error} if the request ID is invalid
   */
  create(value) {
    if (!value || value.trim().length === 0) {
      throw new Error("Request ID cannot be empty");
    }
    const normalized = value.trim();
    if (!normalized.startsWith("req_")) {
      throw new Error(
        `Invalid request ID format: "${value}" (must start with 'req_')`
      );
    }
    return normalized;
  },
  /**
   * Generate a new unique request ID
   */
  generate() {
    return `req_${crypto.randomUUID()}`;
  },
  /**
   * Check if a string is a valid RequestId
   */
  isValid(value) {
    return !!value && value.trim().startsWith("req_");
  },
  /**
   * Safely create a RequestId, returning null if invalid
   */
  tryCreate(value) {
    try {
      return RequestId.create(value);
    } catch {
      return null;
    }
  },
  /**
   * Unwrap a RequestId back to a string
   */
  unwrap(requestId) {
    return requestId;
  }
};
const ResumeToken = {
  /**
   * Create a ResumeToken from a string
   * @throws {Error} if the resume token is invalid
   */
  create(value) {
    if (!value || value.trim().length === 0) {
      throw new Error("Resume token cannot be empty");
    }
    const normalized = value.trim();
    if (!normalized.startsWith("resume_")) {
      throw new Error(
        `Invalid resume token format: "${value}" (must start with 'resume_')`
      );
    }
    return normalized;
  },
  /**
   * Generate a new unique resume token
   */
  generate() {
    return `resume_${crypto.randomUUID()}`;
  },
  /**
   * Check if a string is a valid ResumeToken
   */
  isValid(value) {
    return !!value && value.trim().startsWith("resume_");
  },
  /**
   * Safely create a ResumeToken, returning null if invalid
   */
  tryCreate(value) {
    try {
      return ResumeToken.create(value);
    } catch {
      return null;
    }
  },
  /**
   * Unwrap a ResumeToken back to a string
   */
  unwrap(resumeToken) {
    return resumeToken;
  }
};
const CacheKey = {
  /**
   * Create a CacheKey from a string
   * @throws {Error} if the cache key is invalid
   */
  create(value) {
    if (!value || value.trim().length === 0) {
      throw new Error("Cache key cannot be empty");
    }
    return value.trim();
  },
  /**
   * Generate a cache key from components
   */
  generate(prefix, ...parts) {
    const key = [prefix, ...parts].join(":");
    return key;
  },
  /**
   * Check if a string is a valid CacheKey
   */
  isValid(value) {
    return !!value && value.trim().length > 0;
  },
  /**
   * Safely create a CacheKey, returning null if invalid
   */
  tryCreate(value) {
    try {
      return CacheKey.create(value);
    } catch {
      return null;
    }
  },
  /**
   * Unwrap a CacheKey back to a string
   */
  unwrap(cacheKey) {
    return cacheKey;
  }
};
const DEFAULT_REDACT_PATTERNS = [
  "password",
  "apiKey",
  "api_key",
  "token",
  "authorization",
  "secret",
  "creditCard",
  "credit_card",
  "ssn",
  "socialSecurityNumber"
];
const DEFAULT_LOG_EVENTS = [
  "request",
  "response",
  "agent:start",
  "agent:complete",
  "agent:error"
];
function normalizePathForMetrics(path) {
  const pathOnly = path.split("?")[0].split("#")[0];
  return pathOnly.split("/").map((segment) => {
    if (!segment) return segment;
    if (/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(segment)) {
      return ":uuid";
    }
    if (/^\d+$/.test(segment)) {
      return ":id";
    }
    if (/^[a-zA-Z0-9_-]+$/.test(segment) && /\d/.test(segment) && segment.length <= 36) {
      return ":id";
    }
    return segment;
  }).join("/");
}
const DEFAULT_METRIC_TYPES = [
  "ensemble:execution",
  "agent:execution",
  "http:request",
  "error"
];
function resolveObservabilityConfig(config) {
  let loggingConfig;
  if (config?.logging === false) {
    loggingConfig = { enabled: false };
  } else if (config?.logging === true || config?.logging === void 0) {
    loggingConfig = { enabled: true };
  } else {
    loggingConfig = config.logging;
  }
  let metricsConfig;
  if (config?.metrics === false) {
    metricsConfig = { enabled: false };
  } else if (config?.metrics === true || config?.metrics === void 0) {
    metricsConfig = { enabled: true };
  } else {
    metricsConfig = config.metrics;
  }
  return {
    logging: {
      enabled: loggingConfig.enabled !== false,
      level: stringToLogLevel(loggingConfig.level ?? "info"),
      format: loggingConfig.format ?? "json",
      context: loggingConfig.context ?? ["requestId", "executionId", "ensembleName", "agentName"],
      redact: loggingConfig.redact ?? DEFAULT_REDACT_PATTERNS,
      events: new Set(loggingConfig.events ?? DEFAULT_LOG_EVENTS)
    },
    metrics: {
      enabled: metricsConfig.enabled !== false,
      binding: metricsConfig.binding ?? "ANALYTICS",
      track: new Set(metricsConfig.track ?? DEFAULT_METRIC_TYPES),
      dimensions: metricsConfig.dimensions ?? []
    },
    opentelemetry: {
      enabled: config?.opentelemetry?.enabled ?? false,
      endpoint: config?.opentelemetry?.endpoint,
      headers: config?.opentelemetry?.headers,
      samplingRate: config?.opentelemetry?.samplingRate ?? 1
    },
    trackTokenUsage: config?.trackTokenUsage ?? true
  };
}
function stringToLogLevel(level) {
  switch (level.toLowerCase()) {
    case "debug":
      return LogLevel.DEBUG;
    case "info":
      return LogLevel.INFO;
    case "warn":
      return LogLevel.WARN;
    case "error":
      return LogLevel.ERROR;
    default:
      return LogLevel.INFO;
  }
}
function generateExecutionId() {
  return ExecutionId.generate();
}
function generateRequestId() {
  return RequestId.generate();
}
function createMetricsRecorder(analyticsEngine, config, baseContext) {
  const shouldTrack = (type) => {
    return config.metrics.enabled && config.metrics.track.has(type);
  };
  const writeMetric = (data) => {
    if (!analyticsEngine || !config.metrics.enabled) return;
    try {
      analyticsEngine.writeDataPoint({
        blobs: data.blobs ?? [],
        doubles: data.doubles ?? [],
        indexes: data.indexes ?? []
      });
    } catch {
    }
  };
  return {
    record(name, value, dimensions) {
      writeMetric({
        blobs: [name, ...dimensions ? Object.values(dimensions) : []],
        doubles: [value],
        indexes: [name]
      });
    },
    recordEnsembleExecution(ensembleName, durationMs, success) {
      if (!shouldTrack("ensemble:execution")) return;
      writeMetric({
        blobs: [
          ensembleName,
          success ? "success" : "failure",
          baseContext.environment ?? "unknown"
        ],
        doubles: [durationMs, success ? 1 : 0],
        indexes: ["ensemble.execution"]
      });
    },
    recordAgentExecution(agentName, durationMs, success, cached = false) {
      if (!shouldTrack("agent:execution")) return;
      writeMetric({
        blobs: [
          agentName,
          success ? "success" : "failure",
          cached ? "cached" : "executed",
          baseContext.ensembleName ?? "unknown"
        ],
        doubles: [durationMs, success ? 1 : 0, cached ? 1 : 0],
        indexes: ["agent.execution"]
      });
    },
    recordHttpRequest(method, path, statusCode, durationMs) {
      if (!shouldTrack("http:request")) return;
      const statusCategory = statusCode < 400 ? "success" : statusCode < 500 ? "client_error" : "server_error";
      const normalizedPath = normalizePathForMetrics(path);
      writeMetric({
        blobs: [method, normalizedPath, statusCategory, String(statusCode)],
        doubles: [durationMs, 1],
        indexes: ["http.request"]
      });
    },
    recordError(errorType, errorCode) {
      if (!shouldTrack("error")) return;
      writeMetric({
        blobs: [
          errorType,
          errorCode ?? "unknown",
          baseContext.ensembleName ?? "unknown",
          baseContext.agentName ?? "unknown"
        ],
        doubles: [1],
        indexes: ["error"]
      });
    },
    recordCachePerformance(hit, agentName) {
      if (!shouldTrack("cache:performance")) return;
      writeMetric({
        blobs: [
          hit ? "hit" : "miss",
          agentName ?? "unknown",
          baseContext.ensembleName ?? "unknown"
        ],
        doubles: [1],
        indexes: ["cache.performance"]
      });
    }
  };
}
function redactSensitiveFields(obj, patterns) {
  const result = {};
  for (const [key, value] of Object.entries(obj)) {
    const shouldRedact = patterns.some((pattern) => {
      const lowerKey = key.toLowerCase();
      const lowerPattern = pattern.toLowerCase();
      return lowerKey.includes(lowerPattern) || lowerKey === lowerPattern;
    });
    if (shouldRedact) {
      result[key] = "[REDACTED]";
    } else if (typeof value === "object" && value !== null && !Array.isArray(value)) {
      result[key] = redactSensitiveFields(value, patterns);
    } else {
      result[key] = value;
    }
  }
  return result;
}
function createScopedLogger(config, context, analyticsEngine) {
  if (!config.logging.enabled) {
    return {
      debug: () => {
      },
      info: () => {
      },
      warn: () => {
      },
      error: () => {
      },
      child: () => createScopedLogger(config, context, analyticsEngine),
      metric: () => {
      }
    };
  }
  const baseContext = {};
  for (const field of config.logging.context) {
    if (field in context && context[field] !== void 0) {
      baseContext[field] = context[field];
    }
  }
  return new ConductorLogger(
    {
      level: config.logging.level,
      serviceName: "conductor",
      enableAnalytics: config.metrics.enabled,
      baseContext
    },
    analyticsEngine,
    baseContext
  );
}
class ObservabilityManager {
  constructor(config, initialContext, analyticsEngine) {
    this.config = resolveObservabilityConfig(config);
    this.analyticsEngine = analyticsEngine;
    this.context = {
      requestId: initialContext.requestId ?? generateRequestId(),
      executionId: initialContext.executionId ?? generateExecutionId(),
      ...initialContext
    };
    this.logger = createScopedLogger(this.config, this.context, analyticsEngine);
    this.metrics = createMetricsRecorder(analyticsEngine, this.config, this.context);
  }
  /**
   * Internal method to set resolved config (used by child managers)
   */
  setResolvedConfig(resolvedConfig) {
    this.config = resolvedConfig;
  }
  /**
   * Create a child manager with inherited config
   */
  static createChild(resolvedConfig, context, analyticsEngine) {
    const manager = new ObservabilityManager(void 0, context, analyticsEngine);
    manager.setResolvedConfig(resolvedConfig);
    return manager;
  }
  /**
   * Get the current logger
   */
  getLogger() {
    return this.logger;
  }
  /**
   * Get the metrics recorder
   */
  getMetrics() {
    return this.metrics;
  }
  /**
   * Get the current execution context
   */
  getContext() {
    return { ...this.context };
  }
  /**
   * Get the resolved config
   */
  getConfig() {
    return this.config;
  }
  /**
   * Check if a log event should be logged
   */
  shouldLogEvent(event) {
    return this.config.logging.enabled && this.config.logging.events.has(event);
  }
  /**
   * Check if a metric type should be tracked
   */
  shouldTrackMetric(type) {
    return this.config.metrics.enabled && this.config.metrics.track.has(type);
  }
  /**
   * Create a child manager with additional context (e.g., for an agent)
   */
  forAgent(agentName, stepIndex) {
    const childContext = {
      ...this.context,
      agentName,
      stepIndex
    };
    return ObservabilityManager.createChild(this.config, childContext, this.analyticsEngine);
  }
  /**
   * Create a child manager for an ensemble
   */
  forEnsemble(ensembleName, executionId) {
    const childContext = {
      ...this.context,
      ensembleName,
      executionId: executionId ?? generateExecutionId()
    };
    return ObservabilityManager.createChild(this.config, childContext, this.analyticsEngine);
  }
  /**
   * Redact sensitive fields from data
   */
  redact(data) {
    return redactSensitiveFields(data, this.config.logging.redact);
  }
}
function createObservabilityManager(config, initialContext, analyticsEngine) {
  return new ObservabilityManager(config, initialContext ?? {}, analyticsEngine);
}
class Ensemble {
  constructor(options) {
    this.name = options.name;
    this.version = options.version;
    this.description = options.description;
    this.agents = options.agents;
    this.state = options.state;
    this.scoring = options.scoring;
    this.trigger = options.trigger;
    this.notifications = options.notifications;
    this.inputs = options.inputs;
    this.output = options.output;
    if (typeof options.steps === "function") {
      this.isDynamic = true;
      this.hooks = {
        dynamicSteps: options.steps,
        beforeExecute: options.beforeExecute,
        afterExecute: options.afterExecute,
        onError: options.onError
      };
    } else {
      this.isDynamic = false;
      this.staticSteps = options.steps;
      this.hooks = {
        beforeExecute: options.beforeExecute,
        afterExecute: options.afterExecute,
        onError: options.onError
      };
    }
  }
  /**
   * Resolve steps for execution
   *
   * For static ensembles, returns the static steps.
   * For dynamic ensembles, calls the step generator function.
   */
  async resolveSteps(context) {
    if (this.isDynamic && this.hooks?.dynamicSteps) {
      return await this.hooks.dynamicSteps(context);
    }
    return this.staticSteps ?? [];
  }
  /**
   * Get the flow steps (for backward compatibility)
   *
   * Note: For dynamic ensembles, this returns an empty array.
   * Use resolveSteps() for runtime step resolution.
   */
  get flow() {
    return this.staticSteps ?? [];
  }
  /**
   * Convert to plain config object (for serialization/YAML export)
   */
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      state: this.state,
      scoring: this.scoring,
      trigger: this.trigger,
      notifications: this.notifications,
      agents: this.agents,
      flow: this.staticSteps,
      inputs: this.inputs,
      output: this.output
    };
  }
}
function createEnsemble(options) {
  if (!options.name || typeof options.name !== "string") {
    throw new Error("Ensemble name is required and must be a string");
  }
  if (!options.steps) {
    throw new Error("Ensemble steps are required");
  }
  return new Ensemble(options);
}
function isEnsemble(value) {
  return value instanceof Ensemble;
}
function ensembleFromConfig(config) {
  return new Ensemble({
    name: config.name,
    description: config.description,
    steps: config.flow ?? [],
    agents: config.agents,
    state: config.state,
    scoring: config.scoring,
    trigger: config.trigger,
    notifications: config.notifications,
    inputs: config.inputs,
    output: config.output
  });
}
const logger$f = createLogger({ serviceName: "parser" });
const AgentFlowStepSchema = objectType({
  agent: stringType().min(1, "Agent name is required"),
  id: stringType().optional(),
  input: recordType(unknownType()).optional(),
  state: objectType({
    use: arrayType(stringType()).optional(),
    set: arrayType(stringType()).optional()
  }).optional(),
  cache: objectType({
    ttl: numberType().positive().optional(),
    bypass: booleanType().optional()
  }).optional(),
  scoring: objectType({
    evaluator: stringType().min(1),
    thresholds: objectType({
      minimum: numberType().min(0).max(1).optional(),
      target: numberType().min(0).max(1).optional(),
      excellent: numberType().min(0).max(1).optional()
    }).optional(),
    criteria: unionType([recordType(stringType()), arrayType(unknownType())]).optional(),
    onFailure: enumType(["retry", "continue", "abort"]).optional(),
    retryLimit: numberType().positive().optional(),
    requireImprovement: booleanType().optional(),
    minImprovement: numberType().min(0).max(1).optional()
  }).optional(),
  condition: unknownType().optional(),
  when: unknownType().optional(),
  // Alias for condition
  depends_on: arrayType(stringType()).optional(),
  retry: objectType({
    attempts: numberType().positive().optional(),
    backoff: enumType(["linear", "exponential", "fixed"]).optional(),
    initialDelay: numberType().positive().optional(),
    maxDelay: numberType().positive().optional(),
    retryOn: arrayType(stringType()).optional()
  }).optional(),
  timeout: numberType().positive().optional(),
  onTimeout: objectType({
    fallback: unknownType().optional(),
    error: booleanType().optional()
  }).optional()
});
const ParallelFlowStepSchema = objectType({
  type: literalType("parallel"),
  steps: arrayType(lazyType(() => FlowStepSchema)),
  waitFor: enumType(["all", "any", "first"]).optional()
  // Default: 'all'
});
const BranchFlowStepSchema = objectType({
  type: literalType("branch"),
  condition: unknownType(),
  then: arrayType(lazyType(() => FlowStepSchema)),
  else: arrayType(lazyType(() => FlowStepSchema)).optional()
});
const ForeachFlowStepSchema = objectType({
  type: literalType("foreach"),
  items: unknownType(),
  // Expression like ${input.items}
  maxConcurrency: numberType().positive().optional(),
  breakWhen: unknownType().optional(),
  // Early exit condition
  step: lazyType(() => FlowStepSchema)
});
const TryFlowStepSchema = objectType({
  type: literalType("try"),
  steps: arrayType(lazyType(() => FlowStepSchema)),
  catch: arrayType(lazyType(() => FlowStepSchema)).optional(),
  finally: arrayType(lazyType(() => FlowStepSchema)).optional()
});
const SwitchFlowStepSchema = objectType({
  type: literalType("switch"),
  value: unknownType(),
  // Expression to evaluate
  cases: recordType(arrayType(lazyType(() => FlowStepSchema))),
  default: arrayType(lazyType(() => FlowStepSchema)).optional()
});
const WhileFlowStepSchema = objectType({
  type: literalType("while"),
  condition: unknownType(),
  maxIterations: numberType().positive().optional(),
  // Safety limit
  steps: arrayType(lazyType(() => FlowStepSchema))
});
const MapReduceFlowStepSchema = objectType({
  type: literalType("map-reduce"),
  items: unknownType(),
  maxConcurrency: numberType().positive().optional(),
  map: lazyType(() => FlowStepSchema),
  reduce: lazyType(() => FlowStepSchema)
});
const FlowStepSchema = unionType([
  // Control flow steps (identified by 'type' field)
  ParallelFlowStepSchema,
  BranchFlowStepSchema,
  ForeachFlowStepSchema,
  TryFlowStepSchema,
  SwitchFlowStepSchema,
  WhileFlowStepSchema,
  MapReduceFlowStepSchema,
  // Agent steps (no 'type' field, has 'agent' field)
  AgentFlowStepSchema
]);
const EnsembleSchema = objectType({
  name: stringType().min(1, "Ensemble name is required"),
  description: stringType().optional(),
  state: objectType({
    schema: recordType(unknownType()).optional(),
    initial: recordType(unknownType()).optional()
  }).optional(),
  scoring: objectType({
    enabled: booleanType(),
    defaultThresholds: objectType({
      minimum: numberType().min(0).max(1),
      target: numberType().min(0).max(1).optional(),
      excellent: numberType().min(0).max(1).optional()
    }),
    maxRetries: numberType().positive().optional(),
    backoffStrategy: enumType(["linear", "exponential", "fixed"]).optional(),
    initialBackoff: numberType().positive().optional(),
    trackInState: booleanType().optional(),
    criteria: unionType([recordType(stringType()), arrayType(unknownType())]).optional(),
    aggregation: enumType(["weighted_average", "minimum", "geometric_mean"]).optional()
  }).optional(),
  trigger: arrayType(
    discriminatedUnionType("type", [
      // Webhook endpoint (inbound HTTP triggers)
      objectType({
        type: literalType("webhook"),
        path: stringType().min(1).optional(),
        // Defaults to /{ensemble-name}
        methods: arrayType(enumType(["POST", "GET", "PUT", "PATCH", "DELETE"])).optional(),
        auth: objectType({
          type: enumType(["bearer", "signature", "basic"]),
          secret: stringType()
        }).optional(),
        public: booleanType().optional(),
        // If true, no auth required
        mode: enumType(["trigger", "resume"]).optional(),
        async: booleanType().optional(),
        timeout: numberType().positive().optional()
      }),
      // MCP tool endpoint (expose ensemble as MCP tool)
      objectType({
        type: literalType("mcp"),
        toolName: stringType().optional(),
        // Custom tool name (defaults to ensemble name)
        auth: objectType({
          type: enumType(["bearer", "oauth"]),
          secret: stringType().optional()
        }).optional(),
        public: booleanType().optional()
      }),
      // Email invocation (trigger via email)
      objectType({
        type: literalType("email"),
        addresses: arrayType(stringType().email()).min(1),
        auth: objectType({
          from: arrayType(stringType()).min(1)
          // Whitelist of sender patterns
        }).optional(),
        public: booleanType().optional(),
        reply_with_output: booleanType().optional()
        // Send results back via email
      }),
      // Queue message trigger
      objectType({
        type: literalType("queue"),
        queue: stringType().min(1),
        // Queue binding name
        batch_size: numberType().positive().optional(),
        max_retries: numberType().nonnegative().optional(),
        max_wait_time: numberType().positive().optional()
        // Max seconds to wait for batch
      }),
      // Cron schedule trigger
      objectType({
        type: literalType("cron"),
        cron: stringType().min(1, "Cron expression is required"),
        timezone: stringType().optional(),
        enabled: booleanType().optional(),
        input: recordType(unknownType()).optional(),
        metadata: recordType(unknownType()).optional()
      }),
      // HTTP trigger (full web routing with Hono features)
      objectType({
        type: literalType("http"),
        // Core HTTP config - single path (like webhook)
        path: stringType().min(1).optional(),
        // Defaults to /{ensemble-name}
        methods: arrayType(enumType(["GET", "POST", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS"])).optional(),
        // Multi-path support - array of path/methods combinations
        paths: arrayType(
          objectType({
            path: stringType().min(1),
            methods: arrayType(enumType(["GET", "POST", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS"])).optional()
          })
        ).optional(),
        auth: objectType({
          type: enumType(["bearer", "signature", "basic"]),
          secret: stringType()
        }).optional(),
        public: booleanType().optional(),
        mode: enumType(["trigger", "resume"]).optional(),
        async: booleanType().optional(),
        timeout: numberType().positive().optional(),
        // Hono-specific features
        rateLimit: objectType({
          requests: numberType().positive(),
          window: numberType().positive(),
          // seconds
          key: unionType([enumType(["ip", "user"]), functionType()]).optional()
        }).optional(),
        cors: objectType({
          origin: unionType([stringType(), arrayType(stringType())]).optional(),
          methods: arrayType(stringType()).optional(),
          allowHeaders: arrayType(stringType()).optional(),
          exposeHeaders: arrayType(stringType()).optional(),
          credentials: booleanType().optional()
        }).optional(),
        cache: objectType({
          enabled: booleanType(),
          ttl: numberType().positive(),
          vary: arrayType(stringType()).optional(),
          tags: arrayType(stringType()).optional(),
          keyGenerator: functionType().optional()
        }).optional(),
        middleware: arrayType(unionType([stringType(), functionType()])).optional(),
        // Middleware names or functions
        responses: objectType({
          html: objectType({ enabled: booleanType() }).optional(),
          json: objectType({
            enabled: booleanType(),
            transform: functionType().optional()
          }).optional(),
          stream: objectType({
            enabled: booleanType(),
            chunkSize: numberType().optional()
          }).optional()
        }).optional(),
        templateEngine: enumType(["handlebars", "liquid", "simple"]).optional()
      }),
      // Build trigger - run at build/deploy time
      objectType({
        type: literalType("build"),
        enabled: booleanType().optional(),
        output: stringType().optional(),
        // Output directory (e.g., './dist/docs')
        input: recordType(unknownType()).optional(),
        // Static input for build
        metadata: recordType(unknownType()).optional()
      }),
      // CLI trigger - run from command line
      objectType({
        type: literalType("cli"),
        command: stringType().min(1),
        // Command name (e.g., 'docs-generate')
        description: stringType().optional(),
        // Description for help text
        options: arrayType(
          objectType({
            name: stringType().min(1),
            type: enumType(["string", "number", "boolean"]).optional(),
            default: unionType([stringType(), numberType(), booleanType()]).optional(),
            description: stringType().optional(),
            required: booleanType().optional()
          })
        ).optional(),
        enabled: booleanType().optional()
      })
    ])
  ).optional().refine(
    (trigger) => {
      if (!trigger) return true;
      return trigger.every((t) => {
        if (t.type === "queue" || t.type === "cron" || t.type === "build" || t.type === "cli")
          return true;
        return t.auth || t.public === true;
      });
    },
    {
      message: "All webhook, MCP, email, and HTTP triggers must have auth configuration or explicit public: true"
    }
  ),
  notifications: arrayType(
    discriminatedUnionType("type", [
      // Outbound webhook notifications
      objectType({
        type: literalType("webhook"),
        url: stringType().url(),
        events: arrayType(
          enumType([
            "execution.started",
            "execution.completed",
            "execution.failed",
            "execution.timeout",
            "agent.completed",
            "state.updated"
          ])
        ).min(1),
        secret: stringType().optional(),
        retries: numberType().positive().optional(),
        timeout: numberType().positive().optional()
      }),
      // Outbound email notifications
      objectType({
        type: literalType("email"),
        // Allow either valid email or env variable placeholder (${env.VAR})
        to: arrayType(
          stringType().refine(
            (val) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(val) || /^\$\{env\.[^}]+\}$/.test(val),
            { message: "Must be a valid email or environment variable (${env.VAR})" }
          )
        ).min(1),
        events: arrayType(
          enumType([
            "execution.started",
            "execution.completed",
            "execution.failed",
            "execution.timeout",
            "agent.completed",
            "state.updated"
          ])
        ).min(1),
        subject: stringType().optional(),
        // Allow either valid email or env variable placeholder
        from: stringType().refine(
          (val) => /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(val) || /^\$\{env\.[^}]+\}$/.test(val),
          { message: "Must be a valid email or environment variable (${env.VAR})" }
        ).optional()
      })
    ])
  ).optional(),
  agents: arrayType(recordType(unknownType())).optional(),
  // Inline agent definitions (legacy/optional)
  flow: arrayType(lazyType(() => FlowStepSchema)).optional(),
  inputs: recordType(unknownType()).optional(),
  // Input schema definition
  output: EnsembleOutputSchema.optional(),
  // Conditional outputs with status, headers, redirect, rawBody
  /** Memory configuration for persistent conversation and context */
  memory: objectType({
    /** Enable memory system (default: true if memory block is present) */
    enabled: booleanType().optional(),
    /** Session memory configuration (KV-based conversation history) */
    session: objectType({
      enabled: booleanType().optional(),
      /** Time-to-live in seconds (default: 3600 = 1 hour) */
      ttl: numberType().positive().optional(),
      /** Maximum messages to keep (default: 50) */
      maxMessages: numberType().positive().optional(),
      /** Maximum age of individual messages in hours (default: 24) */
      messageMaxAgeHours: numberType().positive().optional()
    }).optional(),
    /** Long-term memory configuration (D1-based persistent storage) */
    longTerm: objectType({
      enabled: booleanType().optional(),
      /** User ID expression for scoping long-term memory (e.g., {{ auth.userId }}) */
      userId: stringType().optional()
    }).optional(),
    /** Semantic memory configuration (Vectorize-based RAG) */
    semantic: objectType({
      enabled: booleanType().optional(),
      /** Embedding model (default: @cf/baai/bge-base-en-v1.5) */
      model: stringType().optional(),
      /** Number of results to return from search (default: 5) */
      topK: numberType().positive().optional(),
      /** Minimum similarity score (0-1) */
      minScore: numberType().min(0).max(1).optional()
    }).optional(),
    /** Analytical memory configuration (Hyperdrive SQL databases) */
    analytical: objectType({
      enabled: booleanType().optional(),
      /** Default database alias */
      defaultDatabase: stringType().optional()
    }).optional()
  }).optional(),
  /** Ensemble-level logging configuration */
  logging: objectType({
    /** Override log level for this ensemble */
    level: enumType(["debug", "info", "warn", "error"]).optional(),
    /** Execution trace logging */
    trace: objectType({
      enabled: booleanType().optional(),
      includeInputs: booleanType().optional(),
      includeOutputs: booleanType().optional(),
      redactInputs: arrayType(stringType()).optional(),
      redactOutputs: arrayType(stringType()).optional()
    }).optional(),
    /** Per-step logging overrides (keyed by step agent name or ID) */
    steps: recordType(recordType(unknownType())).optional()
  }).optional(),
  /** Ensemble-level metrics configuration */
  metrics: objectType({
    enabled: booleanType().optional(),
    /** Custom business metrics to track */
    custom: arrayType(
      objectType({
        name: stringType(),
        condition: stringType().optional(),
        // e.g., 'success' or expression
        value: stringType().optional(),
        // Expression like '_executionTime'
        type: enumType(["counter", "histogram", "gauge"]).optional()
      })
    ).optional()
  }).optional(),
  /** Ensemble-level tracing configuration */
  tracing: objectType({
    enabled: booleanType().optional(),
    samplingRate: numberType().min(0).max(1).optional()
  }).optional()
});
const AgentLoggingSchema = objectType({
  /** Override log level for this agent */
  level: enumType(["debug", "info", "warn", "error"]).optional(),
  /** Additional context fields to include in logs */
  context: arrayType(stringType()).optional(),
  /** Fields to redact from logs (merged with global) */
  redact: arrayType(stringType()).optional(),
  /** Events to log for this agent */
  events: objectType({
    onStart: booleanType().optional(),
    onComplete: booleanType().optional(),
    onError: booleanType().optional(),
    onCacheHit: booleanType().optional()
  }).optional()
}).optional();
const AgentMetricsSchema = objectType({
  /** Enable/disable metrics for this agent */
  enabled: booleanType().optional(),
  /** Custom metrics to record */
  custom: arrayType(
    objectType({
      name: stringType(),
      value: stringType(),
      // Expression to extract value (e.g., 'output.count')
      type: enumType(["counter", "histogram", "gauge"]).optional()
    })
  ).optional()
}).optional();
const AgentSecuritySchema = objectType({
  /**
   * Enable SSRF protection for fetch requests
   * When true (default), requests to private IPs, localhost, and metadata services are blocked
   * @default true
   */
  ssrf: booleanType().optional()
  // Future security features can be added here:
  // inputSanitization: z.boolean().optional(),
  // rateLimiting: z.boolean().optional(),
}).optional();
const AgentSchema = objectType({
  name: stringType().min(1, "Agent name is required"),
  operation: enumType([
    Operation.think,
    Operation.code,
    Operation.storage,
    Operation.data,
    Operation.http,
    Operation.tools,
    Operation.scoring,
    Operation.email,
    Operation.sms,
    Operation.form,
    Operation.html,
    Operation.pdf,
    Operation.queue,
    Operation.autorag
  ]),
  description: stringType().optional(),
  config: recordType(unknownType()).optional(),
  schema: objectType({
    input: recordType(unknownType()).optional(),
    output: recordType(unknownType()).optional()
  }).optional(),
  /** Agent-level logging configuration */
  logging: AgentLoggingSchema,
  /** Agent-level metrics configuration */
  metrics: AgentMetricsSchema,
  /** Security settings for the agent */
  security: AgentSecuritySchema
});
let Parser$1 = class Parser2 {
  static {
    this.interpolator = getInterpolator();
  }
  /**
   * Parse and validate an ensemble YAML file
   */
  static parseEnsemble(yamlContent) {
    try {
      const parsed = parse(yamlContent, { mapAsMap: false, logLevel: "silent" });
      if (!parsed) {
        throw new Error("Empty or invalid YAML content");
      }
      const validated = EnsembleSchema.parse(parsed);
      if (!validated.flow && validated.agents && validated.agents.length > 0) {
        validated.flow = validated.agents.map((agent) => {
          const name = typeof agent === "object" && agent !== null && "name" in agent ? String(agent.name) : void 0;
          if (!name) {
            logger$f.warn(`Skipping agent without name in ensemble "${validated.name}"`, {
              ensembleName: validated.name
            });
            return null;
          }
          return { agent: name };
        }).filter((step2) => step2 !== null);
        logger$f.debug(`Auto-generated sequential flow for ensemble`, {
          ensembleName: validated.name,
          agentCount: validated.flow.length
        });
      }
      return validated;
    } catch (error) {
      if (error instanceof ZodError) {
        const enhancedErrors = error.errors.map((e) => {
          const path = e.path.join(".");
          const baseMessage = `${path}: ${e.message}`;
          if (path === "output" && e.code === "invalid_type" && e.expected === "object") {
            return `${baseMessage}
     Hint: Use object syntax with field mappings:
      output:
        result: \${agent-name.output.fieldName}`;
          }
          if (path.startsWith("flow") && e.message.includes("agent")) {
            return `${baseMessage}
     Hint: Flow steps should use 'agent' key:
      flow:
        - agent: my-agent
          input:
            field: \${input.value}`;
          }
          return baseMessage;
        });
        throw new Error(`Ensemble validation failed:
  ${enhancedErrors.join("\n  ")}`);
      }
      throw new Error(
        `Failed to parse ensemble YAML: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }
  /**
   * Parse YAML and return an Ensemble instance
   *
   * This is the preferred method for loading ensembles, as it returns
   * the canonical Ensemble primitive used by both YAML and TypeScript authoring.
   *
   * @param yamlContent - Raw YAML string
   * @returns Ensemble instance
   *
   * @example
   * ```typescript
   * const yaml = fs.readFileSync('ensemble.yaml', 'utf-8');
   * const ensemble = Parser.parseEnsembleToInstance(yaml);
   *
   * // Ensemble is now identical to one created via createEnsemble()
   * const steps = await ensemble.resolveSteps(context);
   * ```
   */
  static parseEnsembleToInstance(yamlContent) {
    const config = this.parseEnsemble(yamlContent);
    return ensembleFromConfig(config);
  }
  /**
   * Parse and validate an agent YAML file
   */
  static parseAgent(yamlContent) {
    try {
      const parsed = parse(yamlContent, { mapAsMap: false, logLevel: "silent" });
      if (!parsed) {
        throw new Error("Empty or invalid YAML content");
      }
      const validated = AgentSchema.parse(parsed);
      return validated;
    } catch (error) {
      if (error instanceof ZodError) {
        throw new Error(
          `Agent validation failed: ${error.errors.map((e) => `${e.path.join(".")}: ${e.message}`).join(", ")}`
        );
      }
      throw new Error(
        `Failed to parse agent YAML: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }
  /**
   * Resolve input interpolations using composition-based resolver chain
   *
   * Supports: ${input.x}, ${state.y}, ${agent.output.z}
   *
   * Reduced from 42 lines of nested if/else to 1 line via chain of responsibility
   */
  static resolveInterpolation(template2, context) {
    return this.interpolator.resolve(template2, context);
  }
  /**
   * Parse an agent reference that may include version
   * Supports formats:
   * - "agent-name" (no version)
   * - "agent-name@v1.0.0" (semver version)
   * - "agent-name@production" (deployment tag)
   * - "agent-name@latest" (latest tag)
   */
  static parseAgentReference(agentRef) {
    const parts = agentRef.split("@");
    if (parts.length === 1) {
      return { name: parts[0] };
    }
    if (parts.length === 2) {
      return {
        name: parts[0],
        version: parts[1]
      };
    }
    throw new Error(
      `Invalid agent reference format: ${agentRef}. Expected "name" or "name@version"`
    );
  }
  /**
   * Validate that all required agents exist
   */
  static validateAgentReferences(ensemble, availableAgents) {
    if (!ensemble.flow || ensemble.flow.length === 0) {
      return;
    }
    const missingAgents = [];
    const collectAgentRefs = (steps) => {
      for (const step2 of steps) {
        if (typeof step2 !== "object" || step2 === null) continue;
        const stepObj = step2;
        if ("agent" in stepObj && typeof stepObj.agent === "string") {
          const { name } = this.parseAgentReference(stepObj.agent);
          if (!availableAgents.has(name)) {
            missingAgents.push(stepObj.agent);
          }
        }
        if ("type" in stepObj) {
          if (stepObj.type === "parallel" && Array.isArray(stepObj.steps)) {
            collectAgentRefs(stepObj.steps);
          }
          if (stepObj.type === "branch") {
            if (Array.isArray(stepObj.then)) collectAgentRefs(stepObj.then);
            if (Array.isArray(stepObj.else)) collectAgentRefs(stepObj.else);
          }
          if (stepObj.type === "foreach" && stepObj.step) {
            collectAgentRefs([stepObj.step]);
          }
          if (stepObj.type === "try") {
            if (Array.isArray(stepObj.steps)) collectAgentRefs(stepObj.steps);
            if (Array.isArray(stepObj.catch)) collectAgentRefs(stepObj.catch);
            if (Array.isArray(stepObj.finally)) collectAgentRefs(stepObj.finally);
          }
          if (stepObj.type === "switch") {
            if (typeof stepObj.cases === "object" && stepObj.cases !== null) {
              for (const caseSteps of Object.values(stepObj.cases)) {
                if (Array.isArray(caseSteps)) collectAgentRefs(caseSteps);
              }
            }
            if (Array.isArray(stepObj.default)) collectAgentRefs(stepObj.default);
          }
          if (stepObj.type === "while" && Array.isArray(stepObj.steps)) {
            collectAgentRefs(stepObj.steps);
          }
          if (stepObj.type === "map-reduce") {
            if (stepObj.map) collectAgentRefs([stepObj.map]);
            if (stepObj.reduce) collectAgentRefs([stepObj.reduce]);
          }
        }
      }
    };
    collectAgentRefs(ensemble.flow);
    if (missingAgents.length > 0) {
      throw new Error(
        `Ensemble "${ensemble.name}" references missing agents: ${missingAgents.join(", ")}`
      );
    }
  }
};
function isParallelStep(step2) {
  return "type" in step2 && step2.type === "parallel";
}
function isBranchStep(step2) {
  return "type" in step2 && step2.type === "branch";
}
function isForeachStep(step2) {
  return "type" in step2 && step2.type === "foreach";
}
function isTryStep(step2) {
  return "type" in step2 && step2.type === "try";
}
function isSwitchStep(step2) {
  return "type" in step2 && step2.type === "switch";
}
function isWhileStep(step2) {
  return "type" in step2 && step2.type === "while";
}
function isMapReduceStep(step2) {
  return "type" in step2 && step2.type === "map-reduce";
}
function isAgentStep$1(step2) {
  return "agent" in step2 && !("type" in step2);
}
function isControlFlowStep(step2) {
  return "type" in step2;
}
function isFlowControlStep(step2) {
  return isParallelStep(step2) || isBranchStep(step2) || isForeachStep(step2) || isTryStep(step2) || isSwitchStep(step2) || isWhileStep(step2) || isMapReduceStep(step2);
}
const Result = {
  /**
   * Create a successful Result
   */
  ok(value) {
    return { success: true, value };
  },
  /**
   * Create a failed Result
   */
  err(error) {
    return { success: false, error };
  },
  /**
   * Wrap a Promise to catch errors and return a Result
   * @example
   * ```typescript
   * const result = await Result.fromPromise(
   *   fetch('https://api.example.com/data')
   * );
   * ```
   */
  async fromPromise(promise) {
    try {
      const value = await promise;
      return Result.ok(value);
    } catch (error) {
      return Result.err(error instanceof Error ? error : new Error(String(error)));
    }
  },
  /**
   * Wrap a synchronous function to catch errors and return a Result
   * @example
   * ```typescript
   * const result = Result.fromThrowable(() => JSON.parse(input));
   * ```
   */
  fromThrowable(fn) {
    try {
      return Result.ok(fn());
    } catch (error) {
      return Result.err(error instanceof Error ? error : new Error(String(error)));
    }
  },
  /**
   * Transform the value inside a successful Result
   * Leaves error Results unchanged
   * @example
   * ```typescript
   * const result = Result.ok(5);
   * const doubled = Result.map(result, x => x * 2);
   * // doubled = { success: true, value: 10 }
   * ```
   */
  map(result, fn) {
    if (result.success) {
      return Result.ok(fn(result.value));
    }
    return result;
  },
  /**
   * Async version of map
   */
  async mapAsync(result, fn) {
    if (result.success) {
      return Result.ok(await fn(result.value));
    }
    return result;
  },
  /**
   * Transform the error inside a failed Result
   * Leaves success Results unchanged
   * @example
   * ```typescript
   * const result = Result.err(new Error('failed'));
   * const wrapped = Result.mapErr(result, e => new CustomError(e));
   * ```
   */
  mapErr(result, fn) {
    if (result.success) {
      return result;
    }
    return Result.err(fn(result.error));
  },
  /**
   * Chain Results together (flatMap/bind)
   * If the first Result is an error, returns it without calling fn
   * If the first Result is success, calls fn with the value
   * @example
   * ```typescript
   * const result = Result.ok(5);
   * const chained = Result.flatMap(result, x => {
   *   if (x > 10) return Result.ok(x);
   *   return Result.err(new Error('too small'));
   * });
   * ```
   */
  flatMap(result, fn) {
    if (result.success) {
      return fn(result.value);
    }
    return result;
  },
  /**
   * Async version of flatMap
   */
  async flatMapAsync(result, fn) {
    if (result.success) {
      return await fn(result.value);
    }
    return result;
  },
  /**
   * Unwrap a Result, throwing if it's an error
   * Use sparingly - prefer explicit error handling
   * @throws The error if Result is failed
   * @example
   * ```typescript
   * const value = Result.unwrap(result); // Throws if error
   * ```
   */
  unwrap(result) {
    if (result.success) {
      return result.value;
    }
    throw result.error;
  },
  /**
   * Unwrap a Result, returning a default value if it's an error
   * @example
   * ```typescript
   * const value = Result.unwrapOr(result, 'default');
   * ```
   */
  unwrapOr(result, defaultValue) {
    return result.success ? result.value : defaultValue;
  },
  /**
   * Unwrap a Result, computing a default value from the error
   * @example
   * ```typescript
   * const value = Result.unwrapOrElse(result, error => {
   *   console.error('Failed:', error);
   *   return 'fallback';
   * });
   * ```
   */
  unwrapOrElse(result, fn) {
    return result.success ? result.value : fn(result.error);
  },
  /**
   * Check if Result is success
   */
  isOk(result) {
    return result.success === true;
  },
  /**
   * Check if Result is error
   */
  isErr(result) {
    return result.success === false;
  },
  /**
   * Combine multiple Results into one
   * Returns first error, or all values if all succeed
   * @example
   * ```typescript
   * const results = [Result.ok(1), Result.ok(2), Result.ok(3)];
   * const combined = Result.all(results);
   * // combined = { success: true, value: [1, 2, 3] }
   * ```
   */
  all(results) {
    const values = [];
    for (const result of results) {
      if (!result.success) {
        return result;
      }
      values.push(result.value);
    }
    return Result.ok(values);
  },
  /**
   * Combine multiple Results, collecting all errors or all values
   * Unlike `all`, this doesn't short-circuit on first error
   * @example
   * ```typescript
   * const results = [
   *   Result.ok(1),
   *   Result.err(new Error('e1')),
   *   Result.err(new Error('e2'))
   * ];
   * const combined = Result.partition(results);
   * // combined = { success: false, error: [Error('e1'), Error('e2')] }
   * ```
   */
  partition(results) {
    const values = [];
    const errors = [];
    for (const result of results) {
      if (result.success) {
        values.push(result.value);
      } else {
        errors.push(result.error);
      }
    }
    if (errors.length > 0) {
      return Result.err(errors);
    }
    return Result.ok(values);
  },
  /**
   * Sequence async operations, short-circuiting on first error
   * @example
   * ```typescript
   * const result = await Result.sequence([
   *   () => validateInput(data),
   *   () => fetchUser(data.userId),
   *   () => updateUser(user)
   * ]);
   * ```
   */
  async sequence(operations) {
    const values = [];
    for (const operation of operations) {
      const result = await operation();
      if (!result.success) {
        return result;
      }
      values.push(result.value);
    }
    return Result.ok(values);
  },
  /**
   * Match on a Result, providing handlers for both cases
   * @example
   * ```typescript
   * const message = Result.match(result, {
   *   ok: user => `Welcome ${user.name}`,
   *   err: error => `Error: ${error.message}`
   * });
   * ```
   */
  match(result, handlers) {
    if (result.success) {
      return handlers.ok(result.value);
    }
    return handlers.err(result.error);
  },
  /**
   * Perform a side effect on success, returning the original Result
   * @example
   * ```typescript
   * const result = Result.ok(user)
   *   .pipe(Result.tap(u => console.log('Found user:', u.name)));
   * ```
   */
  tap(result, fn) {
    if (result.success) {
      fn(result.value);
    }
    return result;
  },
  /**
   * Perform a side effect on error, returning the original Result
   * @example
   * ```typescript
   * const result = operation()
   *   .pipe(Result.tapErr(e => console.error('Operation failed:', e)));
   * ```
   */
  tapErr(result, fn) {
    if (!result.success) {
      fn(result.error);
    }
    return result;
  }
};
class ConductorError extends Error {
  constructor(message2, details) {
    super(message2);
    this.name = this.constructor.name;
    this.details = details;
    if ("captureStackTrace" in Error && typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, this.constructor);
    }
  }
  /**
   * Convert error to JSON for logging/serialization
   */
  toJSON() {
    return {
      name: this.name,
      code: this.code,
      message: this.message,
      isOperational: this.isOperational,
      ...this.details && { details: this.details },
      stack: this.stack
    };
  }
}
class MemberNotFoundError extends ConductorError {
  constructor(agentName) {
    super(`Agent "${agentName}" not found in registry`);
    this.agentName = agentName;
    this.code = "MEMBER_NOT_FOUND";
    this.isOperational = true;
  }
  toUserMessage() {
    return `The agent "${this.agentName}" does not exist. Check your ensemble configuration.`;
  }
}
class MemberConfigurationError extends ConductorError {
  constructor(agentName, reason) {
    super(`Invalid configuration for agent "${agentName}": ${reason}`);
    this.agentName = agentName;
    this.reason = reason;
    this.code = "MEMBER_INVALID_CONFIG";
    this.isOperational = true;
  }
  toUserMessage() {
    return `Configuration error in agent "${this.agentName}": ${this.reason}`;
  }
}
class AgentExecutionError extends ConductorError {
  constructor(agentName, reason, cause) {
    super(`Agent "${agentName}" execution failed: ${reason}`);
    this.agentName = agentName;
    this.reason = reason;
    this.cause = cause;
    this.code = "MEMBER_EXECUTION_FAILED";
    this.isOperational = true;
  }
  toUserMessage() {
    return `Execution failed for agent "${this.agentName}": ${this.reason}`;
  }
}
class ProviderNotFoundError extends ConductorError {
  constructor(providerId) {
    super(`AI provider "${providerId}" not found`);
    this.providerId = providerId;
    this.code = "PROVIDER_NOT_FOUND";
    this.isOperational = true;
  }
  toUserMessage() {
    return `The AI provider "${this.providerId}" is not available. Check your provider configuration.`;
  }
}
class ProviderAuthError extends ConductorError {
  constructor(providerId, reason) {
    super(`Authentication failed for provider "${providerId}": ${reason}`);
    this.providerId = providerId;
    this.reason = reason;
    this.code = "PROVIDER_AUTH_FAILED";
    this.isOperational = true;
  }
  toUserMessage() {
    return `Authentication error with "${this.providerId}": ${this.reason}. Check your API keys.`;
  }
}
class ProviderAPIError extends ConductorError {
  constructor(providerId, statusCode, response) {
    super(`API error from provider "${providerId}": ${statusCode} - ${response}`);
    this.providerId = providerId;
    this.statusCode = statusCode;
    this.response = response;
    this.code = "PROVIDER_API_ERROR";
    this.isOperational = true;
  }
  toUserMessage() {
    return `API error from "${this.providerId}" (HTTP ${this.statusCode}): ${this.response}`;
  }
}
class ProviderTimeoutError extends ConductorError {
  constructor(providerId, timeoutMs) {
    super(`Request to provider "${providerId}" timed out after ${timeoutMs}ms`);
    this.providerId = providerId;
    this.timeoutMs = timeoutMs;
    this.code = "PROVIDER_TIMEOUT";
    this.isOperational = true;
  }
  toUserMessage() {
    return `Request to "${this.providerId}" timed out. The service may be slow or unavailable.`;
  }
}
class PlatformBindingMissingError extends ConductorError {
  constructor(bindingName, hint) {
    super(`Binding "${bindingName}" not found` + (hint ? `: ${hint}` : ""));
    this.bindingName = bindingName;
    this.hint = hint;
    this.code = "PLATFORM_BINDING_MISSING";
    this.isOperational = true;
  }
  toUserMessage() {
    return `Required binding "${this.bindingName}" is not configured. ${this.hint || "Add it to wrangler.toml"}`;
  }
}
class ModelNotFoundError extends ConductorError {
  constructor(modelId) {
    super(`Model "${modelId}" not found in platform data`);
    this.modelId = modelId;
    this.code = "MODEL_NOT_FOUND";
    this.isOperational = true;
  }
  toUserMessage() {
    return `The model "${this.modelId}" is not available. Check the model ID or use a different model.`;
  }
}
class ModelDeprecatedError extends ConductorError {
  constructor(modelId, reason, replacement) {
    super(
      `Model "${modelId}" is deprecated` + (reason ? `: ${reason}` : "") + (replacement ? `. Use "${replacement}" instead` : "")
    );
    this.modelId = modelId;
    this.reason = reason;
    this.replacement = replacement;
    this.code = "MODEL_DEPRECATED";
    this.isOperational = true;
  }
  toUserMessage() {
    let msg = `The model "${this.modelId}" is deprecated`;
    if (this.reason) msg += `: ${this.reason}`;
    if (this.replacement) msg += `. Please migrate to "${this.replacement}"`;
    return msg;
  }
}
class ModelEOLError extends ConductorError {
  constructor(modelId, eolDate, replacement) {
    super(
      `Model "${modelId}" reached end of life on ${eolDate}` + (replacement ? `. Use "${replacement}" instead` : "")
    );
    this.modelId = modelId;
    this.eolDate = eolDate;
    this.replacement = replacement;
    this.code = "MODEL_EOL";
    this.isOperational = true;
  }
  toUserMessage() {
    let msg = `The model "${this.modelId}" is no longer available (EOL: ${this.eolDate})`;
    if (this.replacement) msg += `. Please use "${this.replacement}" instead`;
    return msg;
  }
}
class EnsembleNotFoundError extends ConductorError {
  constructor(ensembleName) {
    super(`Ensemble "${ensembleName}" not found`);
    this.ensembleName = ensembleName;
    this.code = "ENSEMBLE_NOT_FOUND";
    this.isOperational = true;
  }
  toUserMessage() {
    return `The ensemble "${this.ensembleName}" does not exist.`;
  }
}
class EnsembleParseError extends ConductorError {
  constructor(ensembleName, reason) {
    super(`Failed to parse ensemble "${ensembleName}": ${reason}`);
    this.ensembleName = ensembleName;
    this.reason = reason;
    this.code = "ENSEMBLE_PARSE_FAILED";
    this.isOperational = true;
  }
  toUserMessage() {
    return `Syntax error in ensemble "${this.ensembleName}": ${this.reason}`;
  }
}
class EnsembleExecutionError extends ConductorError {
  constructor(ensembleName, step2, cause) {
    super(`Ensemble "${ensembleName}" failed at step "${step2}": ${cause.message}`);
    this.ensembleName = ensembleName;
    this.step = step2;
    this.cause = cause;
    this.code = "ENSEMBLE_EXECUTION_FAILED";
    this.isOperational = true;
  }
  toUserMessage() {
    return `Execution failed in ensemble "${this.ensembleName}" at step "${this.step}": ${this.cause.message}`;
  }
}
class StorageKeyNotFoundError extends ConductorError {
  constructor(key, storageType) {
    super(`Key "${key}" not found in ${storageType}`);
    this.key = key;
    this.storageType = storageType;
    this.code = "STORAGE_NOT_FOUND";
    this.isOperational = true;
  }
  toUserMessage() {
    return `The key "${this.key}" does not exist in ${this.storageType} storage.`;
  }
}
class ConfigurationError extends ConductorError {
  constructor(reason) {
    super(`Configuration error: ${reason}`);
    this.reason = reason;
    this.code = "CONFIGURATION_ERROR";
    this.isOperational = true;
  }
  toUserMessage() {
    return `Configuration error: ${this.reason}`;
  }
}
class InternalError extends ConductorError {
  // Non-operational - indicates a bug
  constructor(reason, cause) {
    super(`Internal error: ${reason}`);
    this.reason = reason;
    this.cause = cause;
    this.code = "INTERNAL_ERROR";
    this.isOperational = false;
  }
  toUserMessage() {
    return `An unexpected error occurred. Please contact support.`;
  }
}
const Errors = {
  /** @deprecated Use agentNotFound instead */
  memberNotFound: (name) => new MemberNotFoundError(name),
  agentNotFound: (name) => new MemberNotFoundError(name),
  agentConfig: (name, reason) => new MemberConfigurationError(name, reason),
  memberExecution: (name, reason, cause) => new AgentExecutionError(name, reason, cause),
  providerNotFound: (id) => new ProviderNotFoundError(id),
  providerAuth: (id, reason) => new ProviderAuthError(id, reason),
  providerAPI: (id, status, response) => new ProviderAPIError(id, status, response),
  providerTimeout: (id, timeout) => new ProviderTimeoutError(id, timeout),
  modelNotFound: (id) => new ModelNotFoundError(id),
  modelDeprecated: (id, reason, replacement) => new ModelDeprecatedError(id, reason, replacement),
  modelEOL: (id, eolDate, replacement) => new ModelEOLError(id, eolDate, replacement),
  ensembleNotFound: (name) => new EnsembleNotFoundError(name),
  ensembleParse: (name, reason) => new EnsembleParseError(name, reason),
  ensembleExecution: (name, step2, cause) => new EnsembleExecutionError(name, step2, cause),
  bindingMissing: (name, hint) => new PlatformBindingMissingError(name, hint),
  storageNotFound: (key, storageType) => new StorageKeyNotFoundError(key, storageType),
  config: (reason) => new ConfigurationError(reason),
  internal: (reason, cause) => new InternalError(reason, cause)
};
function hasControlFlowSteps(flow) {
  return flow.some(
    (step2) => isParallelStep(step2) || isBranchStep(step2) || isForeachStep(step2) || isTryStep(step2) || isSwitchStep(step2) || isWhileStep(step2) || isMapReduceStep(step2)
  );
}
class GraphExecutor {
  /**
   * Create a new GraphExecutor
   *
   * @param agentExecutor - Callback function to execute agent steps
   * @param ensembleName - Name of the ensemble (for error messages)
   */
  constructor(agentExecutor, ensembleName = "unknown") {
    this.agentExecutor = agentExecutor;
    this.ensembleName = ensembleName;
  }
  /**
   * Execute a graph-based flow
   *
   * @param flow - Array of flow steps to execute
   * @param initialContext - Initial execution context (input, state)
   * @returns Result containing all step outputs or an error
   */
  async execute(flow, initialContext) {
    const context = {
      input: initialContext.input,
      state: initialContext.state,
      results: /* @__PURE__ */ new Map()
    };
    context.input = initialContext.input;
    if (initialContext.state) {
      context.state = initialContext.state;
    }
    try {
      for (let i = 0; i < flow.length; i++) {
        const step2 = flow[i];
        const result = await this.executeStep(step2, context);
        const stepKey = this.getStepKey(step2, i);
        context.results.set(stepKey, result);
        context[stepKey] = { output: result };
      }
      return Result.ok(Object.fromEntries(context.results));
    } catch (error) {
      return Result.err(
        new EnsembleExecutionError(
          this.ensembleName,
          "graph-execution",
          error instanceof Error ? error : new Error(String(error))
        )
      );
    }
  }
  /**
   * Execute a single step (dispatches to appropriate handler based on type)
   */
  async executeStep(step2, context) {
    if (isAgentStep$1(step2)) {
      return this.executeAgentStep(step2, context);
    }
    if (isParallelStep(step2)) {
      return this.executeParallel(step2, context);
    }
    if (isBranchStep(step2)) {
      return this.executeBranch(step2, context);
    }
    if (isForeachStep(step2)) {
      return this.executeForeach(step2, context);
    }
    if (isTryStep(step2)) {
      return this.executeTry(step2, context);
    }
    if (isSwitchStep(step2)) {
      return this.executeSwitch(step2, context);
    }
    if (isWhileStep(step2)) {
      return this.executeWhile(step2, context);
    }
    if (isMapReduceStep(step2)) {
      return this.executeMapReduce(step2, context);
    }
    throw new Error(`Unknown step type: ${JSON.stringify(step2)}`);
  }
  /**
   * Execute an agent step by delegating to the executor callback
   */
  async executeAgentStep(step2, context) {
    if (step2.when !== void 0 || step2.condition !== void 0) {
      const condition = step2.when ?? step2.condition;
      const shouldExecute = this.evaluateCondition(condition, context);
      if (!shouldExecute) {
        return { skipped: true, reason: "condition evaluated to false" };
      }
    }
    const resolvedInput = step2.input ? Parser$1.resolveInterpolation(step2.input, this.buildResolutionContext(context)) : void 0;
    const resolvedStep = {
      ...step2,
      input: resolvedInput
    };
    return this.agentExecutor(resolvedStep, context);
  }
  /**
   * Execute parallel steps concurrently
   */
  async executeParallel(step2, context) {
    const executions = step2.steps.map((subStep) => this.executeStep(subStep, context));
    switch (step2.waitFor) {
      case "any":
        return [await Promise.race(executions)];
      case "first":
        return [
          await Promise.any(executions).catch(() => {
            throw new Error("All parallel steps failed");
          })
        ];
      case "all":
      default:
        return Promise.all(executions);
    }
  }
  /**
   * Execute conditional branch
   */
  async executeBranch(step2, context) {
    const conditionResult = this.evaluateCondition(step2.condition, context);
    const branchSteps = conditionResult ? step2.then : step2.else || [];
    const branchResults = [];
    for (const subStep of branchSteps) {
      const result = await this.executeStep(subStep, context);
      branchResults.push(result);
    }
    return branchResults;
  }
  /**
   * Execute foreach loop over items
   */
  async executeForeach(step2, context) {
    const items = this.resolveExpression(step2.items, context);
    if (!Array.isArray(items)) {
      throw new Error(`Foreach items must be an array, got: ${typeof items}`);
    }
    const maxConcurrency = step2.maxConcurrency || items.length;
    const results = [];
    for (let i = 0; i < items.length; i += maxConcurrency) {
      const batch = items.slice(i, i + maxConcurrency);
      const batchResults = await Promise.all(
        batch.map((item, index) => {
          const itemContext = {
            ...context,
            results: new Map(context.results)
          };
          itemContext.item = item;
          itemContext.index = i + index;
          return this.executeStep(step2.step, itemContext);
        })
      );
      results.push(...batchResults);
      if (step2.breakWhen) {
        const shouldBreak = this.evaluateCondition(step2.breakWhen, {
          ...context,
          results: new Map([...context.results, ["lastBatchResults", batchResults]])
        });
        if (shouldBreak) {
          break;
        }
      }
    }
    return results;
  }
  /**
   * Execute try/catch/finally block
   */
  async executeTry(step2, context) {
    let tryResult;
    let caughtError = null;
    try {
      const tryResults = [];
      for (const subStep of step2.steps) {
        const result = await this.executeStep(subStep, context);
        tryResults.push(result);
      }
      tryResult = tryResults;
    } catch (error) {
      caughtError = error instanceof Error ? error : new Error(String(error));
      if (step2.catch && step2.catch.length > 0) {
        const errorContext = {
          ...context,
          results: new Map(context.results)
        };
        errorContext.error = {
          message: caughtError.message,
          name: caughtError.name,
          stack: caughtError.stack
        };
        const catchResults = [];
        for (const subStep of step2.catch) {
          const result = await this.executeStep(subStep, errorContext);
          catchResults.push(result);
        }
        tryResult = catchResults;
      } else {
        throw caughtError;
      }
    } finally {
      if (step2.finally && step2.finally.length > 0) {
        for (const subStep of step2.finally) {
          await this.executeStep(subStep, context);
        }
      }
    }
    return tryResult;
  }
  /**
   * Execute switch/case branching
   */
  async executeSwitch(step2, context) {
    const value = this.resolveExpression(step2.value, context);
    const valueStr = String(value);
    let caseSteps = step2.cases[valueStr];
    if (!caseSteps && step2.default) {
      caseSteps = step2.default;
    }
    if (!caseSteps) {
      return null;
    }
    const caseResults = [];
    for (const subStep of caseSteps) {
      const result = await this.executeStep(subStep, context);
      caseResults.push(result);
    }
    return caseResults;
  }
  /**
   * Execute while loop
   */
  async executeWhile(step2, context) {
    const maxIterations = step2.maxIterations || 1e3;
    const results = [];
    let iterations = 0;
    const loopContext = {
      ...context,
      results: new Map(context.results)
    };
    while (iterations < maxIterations) {
      const shouldContinue = this.evaluateCondition(step2.condition, loopContext);
      if (!shouldContinue) {
        break;
      }
      const iterationResults = [];
      for (const subStep of step2.steps) {
        const result = await this.executeStep(subStep, loopContext);
        iterationResults.push(result);
      }
      results.push(iterationResults);
      loopContext.iteration = iterations;
      loopContext.lastIterationResults = iterationResults;
      iterations++;
    }
    if (iterations >= maxIterations) {
      throw new Error(`While loop exceeded maximum iterations (${maxIterations})`);
    }
    return results;
  }
  /**
   * Execute map-reduce pattern
   */
  async executeMapReduce(step2, context) {
    const items = this.resolveExpression(step2.items, context);
    if (!Array.isArray(items)) {
      throw new Error(`Map-reduce items must be an array, got: ${typeof items}`);
    }
    const maxConcurrency = step2.maxConcurrency || items.length;
    const mapResults = [];
    for (let i = 0; i < items.length; i += maxConcurrency) {
      const batch = items.slice(i, i + maxConcurrency);
      const batchResults = await Promise.all(
        batch.map((item, index) => {
          const itemContext = {
            ...context,
            results: new Map(context.results)
          };
          itemContext.item = item;
          itemContext.index = i + index;
          return this.executeStep(step2.map, itemContext);
        })
      );
      mapResults.push(...batchResults);
    }
    const reduceContext = {
      ...context,
      results: new Map(context.results)
    };
    reduceContext.mapResults = mapResults;
    reduceContext.results = mapResults;
    return this.executeStep(step2.reduce, reduceContext);
  }
  /**
   * Get a unique key for storing step results
   */
  getStepKey(step2, index) {
    if (isAgentStep$1(step2)) {
      return step2.id || step2.agent;
    }
    if ("type" in step2) {
      return `${step2.type}_${index}`;
    }
    return `step_${index}`;
  }
  /**
   * Evaluate a condition expression
   * Supports both interpolation expressions and JavaScript expressions
   */
  evaluateCondition(condition, context) {
    if (typeof condition === "boolean") {
      return condition;
    }
    if (typeof condition === "string") {
      const resolved = this.resolveExpression(condition, context);
      if (typeof resolved === "boolean") {
        return resolved;
      }
      if (typeof resolved === "string") {
        return this.evaluateJsExpression(resolved, context);
      }
      return Boolean(resolved);
    }
    return Boolean(condition);
  }
  /**
   * Resolve an expression using Parser's interpolation system
   */
  resolveExpression(expression, context) {
    if (expression === null || expression === void 0) {
      return expression;
    }
    return Parser$1.resolveInterpolation(expression, this.buildResolutionContext(context));
  }
  /**
   * Build resolution context for Parser.resolveInterpolation
   */
  buildResolutionContext(context) {
    const resolutionContext = {
      input: context.input,
      state: context.state || {}
    };
    for (const [key, value] of context.results) {
      resolutionContext[key] = { output: value };
    }
    for (const [key, value] of Object.entries(context)) {
      if (key !== "input" && key !== "state" && key !== "results") {
        resolutionContext[key] = value;
      }
    }
    return resolutionContext;
  }
  /**
   * Evaluate a JavaScript expression in the context
   * Used as fallback for complex condition expressions
   */
  evaluateJsExpression(expression, context) {
    try {
      const evalContext = this.buildResolutionContext(context);
      const func = new Function(
        "context",
        "input",
        "state",
        "results",
        `return ${expression}`
      );
      return Boolean(
        func(evalContext, context.input, context.state || {}, Object.fromEntries(context.results))
      );
    } catch (error) {
      console.warn(`Failed to evaluate condition "${expression}":`, error);
      return false;
    }
  }
}
class StateManager {
  constructor(config, existingState, existingLog) {
    this.schema = Object.freeze(config.schema || {});
    this.state = Object.freeze(existingState || { ...config.initial || {} });
    this.accessLog = existingLog || [];
    this.logger = config.logger || createLogger({ serviceName: "state-manager" });
  }
  /**
   * Create a state context for a specific agent
   * Returns both the context and a function to retrieve accumulated updates
   */
  getStateForAgent(agentName, config) {
    const { use = [], set: set2 = [] } = config;
    const viewState = {};
    const newLog = [...this.accessLog];
    for (const key of use) {
      if (this.state && key in this.state) {
        viewState[key] = this.state[key];
        newLog.push({
          agent: agentName,
          key,
          operation: "read",
          timestamp: Date.now()
        });
      }
    }
    const pendingUpdates = {};
    const setState = (updates) => {
      for (const [key, value] of Object.entries(updates)) {
        if (set2.includes(key)) {
          pendingUpdates[key] = value;
          newLog.push({
            agent: agentName,
            key,
            operation: "write",
            timestamp: Date.now()
          });
        } else {
          this.logger.warn("Agent attempted to set undeclared state key", {
            agentName,
            key,
            declaredKeys: set2
          });
        }
      }
    };
    return {
      context: {
        state: Object.freeze(viewState),
        setState
      },
      getPendingUpdates: () => ({ updates: pendingUpdates, newLog })
    };
  }
  /**
   * Apply pending updates from a agent execution (returns new StateManager instance)
   * This is the preferred method when using getStateForAgent with getPendingUpdates
   */
  applyPendingUpdates(updates, newLog) {
    if (Object.keys(updates).length === 0 && newLog.length === this.accessLog.length) {
      return this;
    }
    const newState = { ...this.state, ...updates };
    return new StateManager(
      { schema: this.schema, initial: {}, logger: this.logger },
      newState,
      newLog
    );
  }
  /**
   * Update state from a agent (returns new StateManager instance)
   * Use applyPendingUpdates for better performance when using getStateForAgent
   */
  setStateFromMember(agentName, updates, config) {
    const { set: set2 = [] } = config;
    const newState = { ...this.state };
    const newLog = [...this.accessLog];
    for (const [key, value] of Object.entries(updates)) {
      if (set2.includes(key)) {
        newState[key] = value;
        newLog.push({
          agent: agentName,
          key,
          operation: "write",
          timestamp: Date.now()
        });
      } else {
        this.logger.warn("Agent attempted to set undeclared state key", {
          agentName,
          key,
          declaredKeys: set2
        });
      }
    }
    return new StateManager(
      { schema: this.schema, initial: {}, logger: this.logger },
      newState,
      newLog
    );
  }
  /**
   * Get the full current state snapshot
   */
  getState() {
    return this.state;
  }
  /**
   * Generate an access report showing state usage patterns
   */
  getAccessReport() {
    const allKeys = Object.keys(this.state);
    const usedKeys = /* @__PURE__ */ new Set();
    for (const access of this.accessLog) {
      usedKeys.add(access.key);
    }
    const unusedKeys = allKeys.filter((key) => !usedKeys.has(key));
    const accessPatterns = {};
    for (const access of this.accessLog) {
      if (!accessPatterns[access.agent]) {
        accessPatterns[access.agent] = [];
      }
      accessPatterns[access.agent].push(access);
    }
    return {
      unusedKeys,
      accessPatterns
    };
  }
  /**
   * Clear access logs (returns new instance)
   */
  clearAccessLog() {
    return new StateManager(
      { schema: this.schema, initial: {}, logger: this.logger },
      this.state,
      []
    );
  }
  /**
   * Reset state to initial values (returns new instance)
   */
  reset(initialState) {
    return new StateManager(
      { schema: this.schema, initial: initialState || {}, logger: this.logger },
      void 0,
      []
    );
  }
  /**
   * Create a new StateManager with merged state
   */
  merge(updates) {
    const newState = { ...this.state, ...updates };
    return new StateManager(
      { schema: this.schema, initial: {}, logger: this.logger },
      newState,
      this.accessLog
    );
  }
}
function isPrivateOrInternalIP(hostname) {
  const cleanHostname = hostname.replace(/^\[|\]$/g, "");
  if (cleanHostname === "localhost" || cleanHostname.endsWith(".local") || cleanHostname.endsWith(".internal") || cleanHostname.endsWith(".localhost")) {
    return true;
  }
  const ipv4Parts = cleanHostname.split(".").map(Number);
  if (ipv4Parts.length === 4 && ipv4Parts.every((n) => !isNaN(n) && n >= 0 && n <= 255)) {
    const [a, b, c] = ipv4Parts;
    if (a === 127) return true;
    if (a === 10) return true;
    if (a === 172 && b >= 16 && b <= 31) return true;
    if (a === 192 && b === 168) return true;
    if (a === 169 && b === 254) return true;
    if (a === 0) return true;
    if (a === 100 && b >= 64 && b <= 127) return true;
    if (a === 192 && b === 0 && c === 0) return true;
    if (a === 192 && b === 0 && c === 2 || a === 198 && b === 51 && c === 100 || a === 203 && b === 0 && c === 113)
      return true;
    if (a >= 224 && a <= 239) return true;
    if (a >= 240) return true;
  }
  const lowerHostname = cleanHostname.toLowerCase();
  if (lowerHostname === "::1" || lowerHostname === "0:0:0:0:0:0:0:1") return true;
  if (lowerHostname.startsWith("fc") || lowerHostname.startsWith("fd")) return true;
  if (lowerHostname.startsWith("fe8") || lowerHostname.startsWith("fe9") || lowerHostname.startsWith("fea") || lowerHostname.startsWith("feb"))
    return true;
  if (lowerHostname === "::" || lowerHostname === "0:0:0:0:0:0:0:0") return true;
  return false;
}
function validateURL(urlString, allowInternal = false) {
  let url;
  try {
    url = new URL(urlString);
  } catch {
    throw new Error(`Invalid URL: ${urlString}`);
  }
  if (!["http:", "https:"].includes(url.protocol)) {
    throw new Error(`Unsupported protocol: ${url.protocol}. Only HTTP(S) is allowed.`);
  }
  if (!allowInternal && isPrivateOrInternalIP(url.hostname)) {
    throw new Error(
      `SSRF protection: Blocked request to private/internal address: ${url.hostname}. Use { allowInternalRequests: true } to bypass (not recommended).`
    );
  }
  return url;
}
async function safeFetch(input, init) {
  const { allowInternalRequests = false, ...fetchInit } = init ?? {};
  let urlString;
  if (typeof input === "string") {
    urlString = input;
  } else if (input instanceof URL) {
    urlString = input.href;
  } else if (input instanceof Request) {
    urlString = input.url;
  } else {
    throw new Error("Invalid fetch input: expected string, URL, or Request");
  }
  const validatedUrl = validateURL(urlString, allowInternalRequests);
  return fetch(validatedUrl.href, fetchInit);
}
const DEFAULT_SECURITY_SETTINGS = {
  ssrf: true
};
class BaseAgent {
  constructor(config) {
    this.config = config;
    this.name = config.name;
    this.type = config.operation;
    this.security = {
      ...DEFAULT_SECURITY_SETTINGS,
      ...config.security
    };
  }
  /**
   * Execute the agent with given input and context
   * @param context - Execution context
   * @returns Agent response
   */
  async execute(context) {
    const startTime = Date.now();
    const enrichedContext = this.enrichContext(context);
    try {
      const result = await this.run(enrichedContext);
      const executionTime = Date.now() - startTime;
      return this.wrapSuccess(result, executionTime, false);
    } catch (error) {
      const executionTime = Date.now() - startTime;
      return this.wrapError(error, executionTime);
    }
  }
  /**
   * Enrich the execution context with automatic security features
   *
   * This method injects security utilities into the context based on
   * the agent's security settings. Developers don't need to remember
   * to add these - they're automatic.
   *
   * @param context - Original execution context
   * @returns Enriched context with security features
   */
  enrichContext(context) {
    const enriched = { ...context };
    if (this.security.ssrf && !context.fetch) {
      enriched.fetch = safeFetch;
    } else if (!this.security.ssrf && !context.fetch) {
      enriched.fetch = fetch;
    }
    return enriched;
  }
  /**
   * Wrap successful execution result
   * @param data - Result data
   * @param executionTime - Time taken in milliseconds
   * @param cached - Whether result was cached
   * @returns Wrapped response
   */
  wrapSuccess(data, executionTime, cached = false) {
    return {
      success: true,
      data,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      cached,
      executionTime,
      metadata: {
        agent: this.name,
        type: this.type
      }
    };
  }
  /**
   * Wrap error response
   * @param error - Error object
   * @param executionTime - Time taken in milliseconds
   * @returns Wrapped error response
   */
  wrapError(error, executionTime) {
    const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
    return {
      success: false,
      error: errorMessage,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      cached: false,
      executionTime,
      metadata: {
        agent: this.name,
        type: this.type
      }
    };
  }
  /**
   * Generate cache key for this agent's execution
   * @param input - Input data
   * @returns Cache key string
   */
  async generateCacheKey(input) {
    const inputString = JSON.stringify(this.sortObjectKeys(input));
    const hash = await this.hashString(inputString);
    return `agent:${this.name}:${hash}`;
  }
  /**
   * Sort object keys recursively for stable stringification
   * @param obj - Object to sort
   * @returns Sorted object
   */
  sortObjectKeys(obj) {
    if (typeof obj !== "object" || obj === null) {
      return obj;
    }
    if (Array.isArray(obj)) {
      return obj.map((item) => this.sortObjectKeys(item));
    }
    const sorted = {};
    const keys = Object.keys(obj).sort();
    for (const key of keys) {
      sorted[key] = this.sortObjectKeys(obj[key]);
    }
    return sorted;
  }
  /**
   * Cryptographically secure SHA-256 hash function
   * @param str - String to hash
   * @returns Hash value (hex string)
   */
  async hashString(str) {
    const encoder2 = new TextEncoder();
    const data = encoder2.encode(str);
    const hashBuffer = await crypto.subtle.digest("SHA-256", data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
    return hashHex.substring(0, 16);
  }
  /**
   * Get agent configuration
   * @returns Agent configuration
   */
  getConfig() {
    return this.config;
  }
  /**
   * Get agent name
   * @returns Agent name
   */
  getName() {
    return this.name;
  }
  /**
   * Get agent type
   * @returns Agent type
   */
  getType() {
    return this.type;
  }
}
class FunctionAgent extends BaseAgent {
  constructor(config, implementation) {
    super(config);
    if (typeof implementation !== "function") {
      throw new Error(`Function agent "${config.name}" requires a function implementation`);
    }
    this.implementation = implementation;
  }
  /**
   * Execute the user-provided function
   */
  async run(context) {
    try {
      const result = await this.implementation(context);
      return result;
    } catch (error) {
      throw new Error(
        `Function agent "${this.name}" execution failed: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }
  /**
   * Get the function implementation (for testing/inspection)
   */
  getImplementation() {
    return this.implementation;
  }
  /**
   * Create a FunctionAgent from a config with inline handler
   * Supports test-style handlers: (input, context?) => result
   */
  static fromConfig(config) {
    const agentConfig = config.config;
    const handler = agentConfig?.handler;
    if (typeof handler === "function") {
      const implementation = async (context) => {
        return await handler(context.input, context);
      };
      return new FunctionAgent(config, implementation);
    }
    return null;
  }
}
function parseScriptURI(uri) {
  let pathWithVersion;
  if (uri.startsWith("script://")) {
    pathWithVersion = uri.slice("script://".length);
  } else if (uri.startsWith("scripts/")) {
    pathWithVersion = uri.slice("scripts/".length);
  } else {
    throw new Error(
      `Invalid script reference: ${uri}
Expected formats:
  - script://transforms/csv (full URI)
  - scripts/transforms/csv (shorthand)
  - scripts/transforms/csv@v1.0.0 (with version)
Examples:
  - script://validators/email
  - scripts/health-check
  - scripts/auth/verify-token@v1.0.0`
    );
  }
  const [path] = pathWithVersion.split("@");
  if (!path) {
    throw new Error(`Script reference has empty path: ${uri}`);
  }
  return path;
}
function isScriptReference(value) {
  return typeof value === "string" && (value.startsWith("script://") || value.startsWith("scripts/"));
}
class CodeAgent extends BaseAgent {
  constructor(config) {
    super(config);
    this.codeConfig = config.config || {};
    if (!this.codeConfig.script && !this.codeConfig.handler) {
      throw new Error(`Code agent "${config.name}" requires either a script URI or inline handler`);
    }
    if (this.codeConfig.handler) {
      this.compiledFunction = this.codeConfig.handler;
    }
  }
  /**
   * Execute the code
   */
  async run(context) {
    try {
      if (!this.compiledFunction && this.codeConfig.script) {
        this.compiledFunction = this.loadScript(context);
      }
      if (!this.compiledFunction) {
        throw new Error("No code implementation available");
      }
      const result = await this.compiledFunction(context);
      return result;
    } catch (error) {
      throw new Error(
        `Code agent "${this.name}" execution failed: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }
  /**
   * Load script from bundled scripts
   *
   * Uses the global ScriptLoader which contains pre-bundled scripts
   * discovered at build time by vite-plugin-script-discovery.
   *
   * This approach works in Cloudflare Workers because it doesn't
   * use new Function() or eval() - scripts are statically imported.
   */
  loadScript(context) {
    const scriptUri = this.codeConfig.script;
    if (!scriptUri) {
      throw new Error("No script URI provided");
    }
    {
      throw new Error(
        `Cannot load script "${scriptUri}": Script loader not initialized.

For Cloudflare Workers, scripts must be bundled at build time:
1. Create your script in scripts/${scriptUri.replace("script://", "")}.ts
2. Export a default function: export default async function(context) { ... }
3. Initialize the script loader in your worker entry point:

   import { scriptsMap } from 'virtual:conductor-scripts'
   import { setGlobalScriptLoader, createScriptLoader } from '@ensemble-edge/conductor'
   setGlobalScriptLoader(createScriptLoader(scriptsMap))

Note: Dynamic script loading via KV is not supported in Workers due to
security restrictions (new Function() is blocked).`
      );
    }
  }
  /**
   * Create a CodeAgent from a config with script URI or handler
   */
  static fromConfig(config) {
    const codeConfig = config.config;
    if (codeConfig?.script || codeConfig?.handler) {
      return new CodeAgent(config);
    }
    return null;
  }
}
class BaseAIProvider {
  /**
   * Default validation checks for API key
   */
  validateConfig(config, env) {
    return this.getConfigError(config, env) === null;
  }
  /**
   * Helper to get API key from config or env
   */
  getApiKey(config, env, envVarName) {
    const envRecord = env;
    return config.apiKey || envRecord[envVarName] || null;
  }
  /**
   * Helper to make HTTP request
   */
  async makeRequest(endpoint, headers, body) {
    const response = await fetch(endpoint, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        ...headers
      },
      body: JSON.stringify(body)
    });
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`API request failed: ${response.status} ${response.statusText}
${errorText}`);
    }
    return await response.json();
  }
}
class OpenAIProvider extends BaseAIProvider {
  constructor() {
    super(...arguments);
    this.id = "openai";
    this.name = "OpenAI";
    this.defaultEndpoint = "https://api.openai.com/v1/chat/completions";
  }
  async execute(request) {
    const { messages, config, env } = request;
    const apiKey = this.getApiKey(config, env, "OPENAI_API_KEY");
    if (!apiKey) {
      throw new Error("OpenAI API key not found. Set OPENAI_API_KEY in env or config");
    }
    const endpoint = config.apiEndpoint || this.defaultEndpoint;
    const data = await this.makeRequest(
      endpoint,
      { Authorization: `Bearer ${apiKey}` },
      {
        model: config.model,
        messages,
        temperature: config.temperature,
        max_tokens: config.maxTokens
      }
    );
    return {
      content: data.choices[0]?.message?.content || "",
      model: config.model,
      tokensUsed: data.usage?.total_tokens,
      provider: this.id,
      metadata: {
        finishReason: data.choices[0]?.finish_reason,
        promptTokens: data.usage?.prompt_tokens,
        completionTokens: data.usage?.completion_tokens
      }
    };
  }
  getConfigError(config, env) {
    const apiKey = this.getApiKey(config, env, "OPENAI_API_KEY");
    if (!apiKey) {
      return "OpenAI API key not found. Set OPENAI_API_KEY in env or config.apiKey";
    }
    return null;
  }
}
class AnthropicProvider extends BaseAIProvider {
  constructor() {
    super(...arguments);
    this.id = "anthropic";
    this.name = "Anthropic";
    this.defaultEndpoint = "https://api.anthropic.com/v1/messages";
    this.defaultModel = "claude-3-sonnet-20240229";
  }
  async execute(request) {
    const { messages, config, env } = request;
    const apiKey = this.getApiKey(config, env, "ANTHROPIC_API_KEY");
    if (!apiKey) {
      throw new Error("Anthropic API key not found. Set ANTHROPIC_API_KEY in env or config");
    }
    const endpoint = config.apiEndpoint || this.defaultEndpoint;
    const anthropicMessages = messages.filter((m) => m.role !== "system");
    const systemMessage = messages.find((m) => m.role === "system")?.content || config.systemPrompt;
    const requestBody = {
      model: config.model || this.defaultModel,
      messages: anthropicMessages,
      system: systemMessage,
      temperature: config.temperature,
      max_tokens: config.maxTokens
    };
    if (config.schema) {
      const schema2 = typeof config.schema === "string" ? JSON.parse(config.schema) : config.schema;
      requestBody.response_format = {
        type: "json_schema",
        json_schema: schema2
      };
    }
    const data = await this.makeRequest(
      endpoint,
      {
        "x-api-key": apiKey,
        "anthropic-version": "2023-06-01"
      },
      requestBody
    );
    return {
      content: data.content[0]?.text || "",
      model: config.model || this.defaultModel,
      tokensUsed: (data.usage?.input_tokens || 0) + (data.usage?.output_tokens || 0),
      provider: this.id,
      metadata: {
        stopReason: data.stop_reason,
        inputTokens: data.usage?.input_tokens,
        outputTokens: data.usage?.output_tokens,
        schema: config.schema ? typeof config.schema === "string" ? config.schema : JSON.stringify(config.schema) : void 0
      }
    };
  }
  getConfigError(config, env) {
    const apiKey = this.getApiKey(config, env, "ANTHROPIC_API_KEY");
    if (!apiKey) {
      return "Anthropic API key not found. Set ANTHROPIC_API_KEY in env or config.apiKey";
    }
    return null;
  }
}
class CloudflareProvider extends BaseAIProvider {
  constructor() {
    super(...arguments);
    this.id = "workers-ai";
    this.name = "Cloudflare Workers AI";
    this.defaultModel = "@cf/meta/llama-2-7b-chat-int8";
  }
  async execute(request) {
    const { messages, config, env } = request;
    if (!env.AI) {
      throw new Error(
        'Cloudflare AI binding not available. Add [ai] binding = "AI" to wrangler.toml'
      );
    }
    const model = config.model || this.defaultModel;
    const response = await env.AI.run(model, {
      messages,
      temperature: config.temperature,
      max_tokens: config.maxTokens
    });
    return {
      content: response.response || response.result?.response || String(response),
      model,
      tokensUsed: response.tokens_used,
      provider: this.id,
      metadata: {
        raw: response
      }
    };
  }
  getConfigError(_config, env) {
    if (!env.AI) {
      return 'Cloudflare AI binding not found. Add [ai] binding = "AI" to wrangler.toml';
    }
    return null;
  }
}
class CustomProvider extends BaseAIProvider {
  constructor() {
    super(...arguments);
    this.id = "custom";
    this.name = "Custom API";
  }
  async execute(request) {
    const { messages, config, env } = request;
    if (!config.apiEndpoint) {
      throw new Error("Custom provider requires apiEndpoint in config");
    }
    const apiKey = this.getApiKey(config, env, "AI_API_KEY");
    const headers = {};
    if (apiKey) {
      headers["Authorization"] = `Bearer ${apiKey}`;
    }
    const data = await this.makeRequest(config.apiEndpoint, headers, {
      model: config.model,
      messages,
      temperature: config.temperature,
      max_tokens: config.maxTokens
    });
    const content = data.choices?.[0]?.message?.content || data.response || data.content || "";
    return {
      content,
      model: config.model,
      tokensUsed: data.usage?.total_tokens,
      provider: this.id,
      metadata: data
    };
  }
  getConfigError(config, _env) {
    if (!config.apiEndpoint) {
      return "Custom provider requires apiEndpoint in config";
    }
    return null;
  }
}
class ProviderRegistry {
  constructor() {
    this.providers = /* @__PURE__ */ new Map();
    this.registerDefaultProviders();
  }
  /**
   * Register default providers
   */
  registerDefaultProviders() {
    this.register(new OpenAIProvider());
    this.register(new AnthropicProvider());
    this.register(new CloudflareProvider());
    this.register(new CustomProvider());
  }
  /**
   * Register a provider
   */
  register(provider) {
    this.providers.set(provider.id, provider);
  }
  /**
   * Get provider by ID
   */
  get(providerId) {
    return this.providers.get(providerId) || null;
  }
  /**
   * Check if provider exists
   */
  has(providerId) {
    return this.providers.has(providerId);
  }
  /**
   * Get all registered provider IDs
   */
  getProviderIds() {
    return Array.from(this.providers.keys());
  }
  /**
   * Get all registered providers
   */
  getAllProviders() {
    return Array.from(this.providers.values());
  }
}
let globalRegistry = null;
function getProviderRegistry() {
  if (!globalRegistry) {
    globalRegistry = new ProviderRegistry();
  }
  return globalRegistry;
}
const logger$e = createLogger({ serviceName: "component-resolver" });
function isComponentReference(value) {
  const componentPattern = /^[a-z0-9-_]+\/[a-z0-9-_/]+@[a-z0-9.-]+$/i;
  return componentPattern.test(value);
}
function isUnversionedComponent(value) {
  const pathPattern = /^[a-z0-9-_]+\/[a-z0-9-_/]+$/i;
  return pathPattern.test(value) && !value.includes("@");
}
function isFilePath(value) {
  return /^\.{0,2}\//.test(value);
}
const pathUtils = {
  /**
   * Check if a path is absolute (starts with /)
   */
  isAbsolute(filePath) {
    return filePath.startsWith("/");
  },
  /**
   * Join path segments
   */
  join(...segments) {
    return segments.join("/").replace(/\/+/g, "/").replace(/\/$/, "");
  },
  /**
   * Get the basename of a path
   */
  basename(filePath) {
    const parts = filePath.split("/");
    return parts[parts.length - 1] || "";
  },
  /**
   * Normalize a path (resolve . and ..)
   */
  normalize(filePath) {
    const parts = filePath.split("/");
    const result = [];
    for (const part of parts) {
      if (part === "..") {
        result.pop();
      } else if (part !== "." && part !== "") {
        result.push(part);
      }
    }
    const normalized = result.join("/");
    return filePath.startsWith("/") ? "/" + normalized : normalized;
  }
};
async function loadFromKV(filePath, context) {
  const normalizedPath = pathUtils.normalize(filePath).replace(/^\.\//, "");
  const kv = context.env?.COMPONENTS || context.env?.EDGIT;
  if (!kv) {
    throw new Error(
      `Cannot load file "${filePath}" in Workers runtime without KV storage.
Configure COMPONENTS or EDGIT KV namespace, or use inline content instead.`
    );
  }
  try {
    const content = await kv.get(`files/${normalizedPath}`);
    if (content) {
      return content;
    }
    const contentAlt = await kv.get(normalizedPath);
    if (contentAlt) {
      return contentAlt;
    }
    throw new Error(`File not found in KV: ${normalizedPath}`);
  } catch (error) {
    throw new Error(
      `Failed to load file from KV: ${filePath}
Looked for keys: files/${normalizedPath}, ${normalizedPath}
Error: ${error instanceof Error ? error.message : String(error)}`
    );
  }
}
async function resolveComponentRef(ref2, context) {
  const [pathPart, version] = ref2.split("@");
  if (context.env?.EDGIT) {
    const edgitPath = `components/${pathPart}/${version}`;
    try {
      const content = await context.env.EDGIT.get(edgitPath);
      if (content) {
        try {
          return JSON.parse(content);
        } catch {
          return content;
        }
      }
    } catch (error) {
      logger$e.warn(`Failed to fetch from Edgit: ${edgitPath}`, { error: String(error) });
    }
  }
  if (context.env?.COMPONENTS) {
    const componentPath = `${pathPart}/${version}`;
    try {
      const content = await context.env.COMPONENTS.get(componentPath);
      if (content) {
        try {
          return JSON.parse(content);
        } catch {
          return content;
        }
      }
    } catch (error) {
      logger$e.warn(`Failed to fetch from COMPONENTS: ${componentPath}`, { error: String(error) });
    }
  }
  throw new Error(
    `Component not found: ${ref2}
Tried EDGIT: components/${pathPart}/${version}
Tried COMPONENTS: ${pathPart}/${version}
Make sure the component is stored in KV storage.`
  );
}
async function resolveValue(value, context) {
  if (typeof value !== "string") {
    return {
      content: value,
      source: "inline",
      originalRef: value
    };
  }
  if (value.includes("\n")) {
    return {
      content: value,
      source: "inline",
      originalRef: value
    };
  }
  if (isFilePath(value)) {
    const content = await loadFromKV(value, context);
    return {
      content,
      source: "file",
      originalRef: value
    };
  }
  if (isComponentReference(value)) {
    const content = await resolveComponentRef(value, context);
    const [pathPart, version] = value.split("@");
    return {
      content,
      source: "component",
      originalRef: value,
      metadata: {
        path: pathPart,
        version,
        fromEdgit: !!context.env?.EDGIT
      }
    };
  }
  if (isUnversionedComponent(value)) {
    const versionedRef = `${value}@latest`;
    const content = await resolveComponentRef(versionedRef, context);
    return {
      content,
      source: "component",
      originalRef: value,
      metadata: {
        path: value,
        version: "latest",
        fromEdgit: !!context.env?.EDGIT
      }
    };
  }
  return {
    content: value,
    source: "inline",
    originalRef: value
  };
}
class BaseTemplateEngine {
  /**
   * Compile a template for repeated use (optional optimization)
   */
  async compile(template2) {
    return template2;
  }
  /**
   * Register a helper function
   */
  registerHelper(name, fn) {
  }
  /**
   * Register a partial template
   */
  registerPartial(name, template2) {
  }
}
class SimpleTemplateEngine extends BaseTemplateEngine {
  constructor() {
    super(...arguments);
    this.name = "simple";
    this.partials = /* @__PURE__ */ new Map();
  }
  /**
   * Set the component loader for partial support
   */
  setComponentLoader(loader) {
    this.componentLoader = loader;
  }
  /**
   * Register a partial template
   */
  registerPartial(name, content) {
    this.partials.set(name, content);
  }
  /**
   * Render template with simple {{variable}} replacement
   */
  async render(template2, context) {
    let result = template2;
    const hasDataProperty = "data" in context && context.data !== void 0;
    const data = hasDataProperty ? context.data : context;
    const helpers = "helpers" in context ? context.helpers : void 0;
    result = await this.processConditionalsRecursive(result, data, context);
    result = await this.processLoopsRecursive(result, data, context);
    result = await this.processPartials(result, { ...context, data });
    result = result.replace(/\{\{(\s*[\w.]+\s*)\}\}/g, (match, key) => {
      const trimmedKey = key.trim();
      const value = this.resolveValue(data, trimmedKey);
      if (value === void 0) {
        return "";
      }
      if (value === null) {
        return "null";
      }
      return String(value);
    });
    if (helpers) {
      result = this.processHelpers(result, helpers);
    }
    return result;
  }
  /**
   * Validate template syntax
   */
  async validate(template2) {
    const errors = [];
    const openBraces = (template2.match(/\{\{/g) || []).length;
    const closeBraces = (template2.match(/\}\}/g) || []).length;
    if (openBraces !== closeBraces) {
      errors.push(`Unbalanced braces: ${openBraces} opening {{ but ${closeBraces} closing }}`);
    }
    const ifBlocks = (template2.match(/\{\{#if\s+\w+\}\}/g) || []).length;
    const endifBlocks = (template2.match(/\{\{\/if\}\}/g) || []).length;
    if (ifBlocks !== endifBlocks) {
      errors.push(`Unbalanced conditionals: ${ifBlocks} {{#if}} but ${endifBlocks} {{/if}}`);
    }
    const eachBlocks = (template2.match(/\{\{#each\s+\w+\}\}/g) || []).length;
    const endEachBlocks = (template2.match(/\{\{\/each\}\}/g) || []).length;
    if (eachBlocks !== endEachBlocks) {
      errors.push(`Unbalanced loops: ${eachBlocks} {{#each}} but ${endEachBlocks} {{/each}}`);
    }
    return {
      valid: errors.length === 0,
      errors: errors.length > 0 ? errors : void 0
    };
  }
  /**
   * Resolve nested object path (e.g., "user.name" -> context.user.name)
   */
  resolveValue(data, path) {
    const keys = path.split(".");
    let value = data;
    for (const key of keys) {
      if (value && typeof value === "object" && key in value) {
        value = value[key];
      } else {
        return void 0;
      }
    }
    return value;
  }
  /**
   * Process {{#if condition}}...{{else}}...{{/if}} blocks recursively
   * This allows conditionals to contain partials and other templates
   */
  async processConditionalsRecursive(template2, data, context) {
    const conditionalRegex = /\{\{#if\s+(\w+)\}\}([\s\S]*?)\{\{\/if\}\}/;
    let result = template2;
    let match;
    while ((match = conditionalRegex.exec(result)) !== null) {
      const [fullMatch, key, content] = match;
      const value = this.resolveValue(data, key);
      const elseMatch = content.match(/^([\s\S]*?)\{\{else\}\}([\s\S]*)$/);
      let selectedContent;
      if (elseMatch) {
        const [, ifContent, elseContent] = elseMatch;
        selectedContent = value ? ifContent : elseContent;
      } else {
        selectedContent = value ? content : "";
      }
      const rendered = await this.render(selectedContent, { ...context, data });
      result = result.replace(fullMatch, rendered);
    }
    return result;
  }
  /**
   * Process {{#each array}}...{{/each}} blocks recursively
   * This allows loops to contain partials with access to loop item data
   */
  async processLoopsRecursive(template2, data, context) {
    const loopRegex = /\{\{#each\s+(\w+)\}\}([\s\S]*?)\{\{\/each\}\}/;
    let result = template2;
    let match;
    while ((match = loopRegex.exec(result)) !== null) {
      const [fullMatch, key, content] = match;
      const array = this.resolveValue(data, key);
      if (!Array.isArray(array)) {
        result = result.replace(fullMatch, "");
        continue;
      }
      const renderedItems = await Promise.all(
        array.map(async (item, index) => {
          const itemData = typeof item === "object" && item !== null ? {
            ...data,
            ...item,
            "@index": index,
            "@first": index === 0,
            "@last": index === array.length - 1
          } : {
            ...data,
            this: item,
            "@index": index,
            "@first": index === 0,
            "@last": index === array.length - 1
          };
          return await this.render(content, { ...context, data: itemData });
        })
      );
      result = result.replace(fullMatch, renderedItems.join(""));
    }
    return result;
  }
  /**
   * Process {{#if condition}}...{{else}}...{{/if}} blocks (non-recursive, legacy)
   * @deprecated Use processConditionalsRecursive instead
   */
  processConditionals(template2, data) {
    return template2.replace(/\{\{#if\s+(\w+)\}\}([\s\S]*?)\{\{\/if\}\}/g, (match, key, content) => {
      const value = this.resolveValue(data, key);
      const elseMatch = content.match(/^([\s\S]*?)\{\{else\}\}([\s\S]*)$/);
      if (elseMatch) {
        const [, ifContent, elseContent] = elseMatch;
        return value ? ifContent : elseContent;
      }
      return value ? content : "";
    });
  }
  /**
   * Process {{#each array}}...{{/each}} blocks
   */
  processLoops(template2, data) {
    return template2.replace(
      /\{\{#each\s+(\w+)\}\}([\s\S]*?)\{\{\/each\}\}/g,
      (match, key, content) => {
        const array = this.resolveValue(data, key);
        if (!Array.isArray(array)) {
          return "";
        }
        return array.map((item, index) => {
          let itemContent = content;
          itemContent = itemContent.replace(/\{\{this\}\}/g, String(item));
          itemContent = itemContent.replace(/\{\{@index\}\}/g, String(index));
          itemContent = itemContent.replace(/\{\{@first\}\}/g, String(index === 0));
          itemContent = itemContent.replace(/\{\{@last\}\}/g, String(index === array.length - 1));
          if (typeof item === "object" && item !== null) {
            itemContent = itemContent.replace(/\{\{(\w+)\}\}/g, (m, k) => {
              const val = item[k];
              return val !== void 0 ? String(val) : m;
            });
          }
          return itemContent;
        }).join("");
      }
    );
  }
  /**
   * Process {{> partialName}} or {{> uri://path@version}} includes
   */
  async processPartials(template2, context) {
    const partialRegex = /\{\{>\s*([^}\s]+)(?:\s+([^}]+))?\s*\}\}/g;
    const matches = Array.from(template2.matchAll(partialRegex));
    if (matches.length === 0) {
      return template2;
    }
    let result = template2;
    for (const match of matches) {
      const [fullMatch, partialRef, argsStr] = match;
      const contextData = "data" in context && typeof context.data === "object" && context.data !== null ? context.data : {};
      const partialData = argsStr ? this.parsePartialArgs(argsStr, contextData) : contextData;
      try {
        let partialContent;
        if (partialRef.includes("://")) {
          if (!this.componentLoader) {
            throw new Error(
              `Component loader not configured. Cannot load component: ${partialRef}`
            );
          }
          partialContent = await this.componentLoader.load(partialRef);
        } else {
          partialContent = this.partials.get(partialRef) || "";
          if (!partialContent) {
            throw new Error(`Partial not found: ${partialRef}`);
          }
        }
        const rendered = await this.render(partialContent, {
          ...context,
          data: partialData
        });
        result = result.replace(fullMatch, rendered);
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        result = result.replace(fullMatch, `<!-- Partial error: ${errorMsg} -->`);
      }
    }
    return result;
  }
  /**
   * Parse partial arguments
   * Example: title="My Site" count=5 -> { title: "My Site", count: 5 }
   */
  parsePartialArgs(argsStr, contextData) {
    const args = { ...contextData };
    const argRegex = /(\w+)=(?:"([^"]*)"|'([^']*)'|(\S+))/g;
    let match;
    while ((match = argRegex.exec(argsStr)) !== null) {
      const [, key, quotedVal1, quotedVal2, unquotedVal] = match;
      const value = quotedVal1 || quotedVal2 || unquotedVal;
      if (value && !value.startsWith('"') && !value.startsWith("'")) {
        const contextValue = this.resolveValue(contextData, value);
        args[key] = contextValue !== void 0 ? contextValue : value;
      } else {
        args[key] = value;
      }
    }
    return args;
  }
  /**
   * Process helper functions {{helper arg1 arg2}}
   */
  processHelpers(template2, helpers) {
    return template2.replace(/\{\{(\w+)\s+([^}]+)\}\}/g, (match, helperName, args) => {
      const helper = helpers[helperName];
      if (!helper) {
        return match;
      }
      const parsedArgs = args.split(/\s+/);
      try {
        const result = helper(...parsedArgs);
        return String(result);
      } catch {
        return match;
      }
    });
  }
}
class Token {
  constructor(kind, input, begin, end, file) {
    this.kind = kind;
    this.input = input;
    this.begin = begin;
    this.end = end;
    this.file = file;
  }
  getText() {
    return this.input.slice(this.begin, this.end);
  }
  getPosition() {
    let [row, col] = [1, 1];
    for (let i = 0; i < this.begin; i++) {
      if (this.input[i] === "\n") {
        row++;
        col = 1;
      } else
        col++;
    }
    return [row, col];
  }
  size() {
    return this.end - this.begin;
  }
}
class Drop {
  liquidMethodMissing(key, context) {
    return void 0;
  }
}
const toString$1 = Object.prototype.toString;
const toLowerCase = String.prototype.toLowerCase;
const hasOwnProperty = Object.hasOwnProperty;
function isString(value) {
  return typeof value === "string";
}
function isFunction(value) {
  return typeof value === "function";
}
function isPromise(val) {
  return val && isFunction(val.then);
}
function isIterator(val) {
  return val && isFunction(val.next) && isFunction(val.throw) && isFunction(val.return);
}
function escapeRegex(str) {
  return str.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
}
function stringify(value) {
  value = toValue(value);
  if (isString(value))
    return value;
  if (isNil(value))
    return "";
  if (isArray(value))
    return value.map((x) => stringify(x)).join("");
  return String(value);
}
function toEnumerable(val) {
  val = toValue(val);
  if (isArray(val))
    return val;
  if (isString(val) && val.length > 0)
    return [val];
  if (isIterable(val))
    return Array.from(val);
  if (isObject$1(val))
    return Object.keys(val).map((key) => [key, val[key]]);
  return [];
}
function toArray(val) {
  val = toValue(val);
  if (isNil(val))
    return [];
  if (isArray(val))
    return val;
  return [val];
}
function toValue(value) {
  return value instanceof Drop && isFunction(value.valueOf) ? value.valueOf() : value;
}
function toNumber(value) {
  return +toValue(value) || 0;
}
function isNumber(value) {
  return typeof value === "number";
}
function toLiquid(value) {
  if (value && isFunction(value.toLiquid))
    return toLiquid(value.toLiquid());
  return value;
}
function isNil(value) {
  return value == null;
}
function isUndefined(value) {
  return value === void 0;
}
function isArray(value) {
  return toString$1.call(value) === "[object Array]";
}
function isArrayLike(value) {
  return value && isNumber(value.length);
}
function isIterable(value) {
  return isObject$1(value) && Symbol.iterator in value;
}
function forOwn(obj, iteratee) {
  obj = obj || {};
  for (const k in obj) {
    if (hasOwnProperty.call(obj, k)) {
      if (iteratee(obj[k], k, obj) === false)
        break;
    }
  }
  return obj;
}
function last(arr) {
  return arr[arr.length - 1];
}
function isObject$1(value) {
  const type = typeof value;
  return value !== null && (type === "object" || type === "function");
}
function range(start, stop, step2 = 1) {
  const arr = [];
  for (let i = start; i < stop; i += step2) {
    arr.push(i);
  }
  return arr;
}
function padStart(str, length, ch = " ") {
  return pad(str, length, ch, (str2, ch2) => ch2 + str2);
}
function padEnd(str, length, ch = " ") {
  return pad(str, length, ch, (str2, ch2) => str2 + ch2);
}
function pad(str, length, ch, add) {
  str = String(str);
  let n = length - str.length;
  while (n-- > 0)
    str = add(str, ch);
  return str;
}
function identify(val) {
  return val;
}
function changeCase(str) {
  const hasLowerCase = [...str].some((ch) => ch >= "a" && ch <= "z");
  return hasLowerCase ? str.toUpperCase() : str.toLowerCase();
}
function ellipsis(str, N) {
  return str.length > N ? str.slice(0, N - 3) + "..." : str;
}
function caseInsensitiveCompare(a, b) {
  if (a == null && b == null)
    return 0;
  if (a == null)
    return 1;
  if (b == null)
    return -1;
  a = toLowerCase.call(a);
  b = toLowerCase.call(b);
  if (a < b)
    return -1;
  if (a > b)
    return 1;
  return 0;
}
function argumentsToValue(fn) {
  return function(...args) {
    return fn.call(this, ...args.map(toValue));
  };
}
function argumentsToNumber(fn) {
  return function(...args) {
    return fn.call(this, ...args.map(toNumber));
  };
}
function escapeRegExp(text) {
  return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
}
function* strictUniq(array) {
  const seen = /* @__PURE__ */ new Set();
  for (const element of array) {
    const key = JSON.stringify(element);
    if (!seen.has(key)) {
      seen.add(key);
      yield element;
    }
  }
}
const TRAIT = "__liquidClass__";
class LiquidError extends Error {
  constructor(err, token) {
    super(typeof err === "string" ? err : err.message);
    this.context = "";
    if (typeof err !== "string")
      Object.defineProperty(this, "originalError", { value: err, enumerable: false });
    Object.defineProperty(this, "token", { value: token, enumerable: false });
    Object.defineProperty(this, TRAIT, { value: "LiquidError", enumerable: false });
  }
  update() {
    Object.defineProperty(this, "context", { value: mkContext(this.token), enumerable: false });
    this.message = mkMessage(this.message, this.token);
    this.stack = this.message + "\n" + this.context + "\n" + this.stack;
    if (this.originalError)
      this.stack += "\nFrom " + this.originalError.stack;
  }
  static is(obj) {
    return (obj === null || obj === void 0 ? void 0 : obj[TRAIT]) === "LiquidError";
  }
}
class TokenizationError extends LiquidError {
  constructor(message2, token) {
    super(message2, token);
    this.name = "TokenizationError";
    super.update();
  }
}
class ParseError extends LiquidError {
  constructor(err, token) {
    super(err, token);
    this.name = "ParseError";
    this.message = err.message;
    super.update();
  }
}
class RenderError extends LiquidError {
  constructor(err, tpl) {
    super(err, tpl.token);
    this.name = "RenderError";
    this.message = err.message;
    super.update();
  }
  static is(obj) {
    return obj.name === "RenderError";
  }
}
class LiquidErrors extends LiquidError {
  constructor(errors) {
    super(errors[0], errors[0].token);
    this.errors = errors;
    this.name = "LiquidErrors";
    const s = errors.length > 1 ? "s" : "";
    this.message = `${errors.length} error${s} found`;
    super.update();
  }
  static is(obj) {
    return obj.name === "LiquidErrors";
  }
}
class UndefinedVariableError extends LiquidError {
  constructor(err, token) {
    super(err, token);
    this.name = "UndefinedVariableError";
    this.message = err.message;
    super.update();
  }
}
class InternalUndefinedVariableError extends Error {
  constructor(variableName) {
    super(`undefined variable: ${variableName}`);
    this.name = "InternalUndefinedVariableError";
    this.variableName = variableName;
  }
}
class AssertionError extends Error {
  constructor(message2) {
    super(message2);
    this.name = "AssertionError";
    this.message = message2 + "";
  }
}
function mkContext(token) {
  const [line, col] = token.getPosition();
  const lines = token.input.split("\n");
  const begin = Math.max(line - 2, 1);
  const end = Math.min(line + 3, lines.length);
  const context = range(begin, end + 1).map((lineNumber) => {
    const rowIndicator = lineNumber === line ? ">> " : "   ";
    const num = padStart(String(lineNumber), String(end).length);
    let text = `${rowIndicator}${num}| `;
    const colIndicator = lineNumber === line ? "\n" + padStart("^", col + text.length) : "";
    text += lines[lineNumber - 1];
    text += colIndicator;
    return text;
  }).join("\n");
  return context;
}
function mkMessage(msg, token) {
  if (token.file)
    msg += `, file:${token.file}`;
  const [line, col] = token.getPosition();
  msg += `, line:${line}, col:${col}`;
  return msg;
}
const TYPES = [0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 4, 4, 4, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 20, 2, 8, 0, 0, 0, 0, 8, 0, 0, 0, 64, 0, 65, 0, 0, 33, 33, 33, 33, 33, 33, 33, 33, 33, 33, 0, 0, 2, 2, 2, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0];
const WORD = 1;
const BLANK = 4;
const QUOTE = 8;
const INLINE_BLANK = 16;
const NUMBER = 32;
const SIGN = 64;
const PUNCTUATION = 128;
function isWord(char) {
  const code = char.charCodeAt(0);
  return code >= 128 ? !TYPES[code] : !!(TYPES[code] & WORD);
}
TYPES[160] = TYPES[5760] = TYPES[6158] = TYPES[8192] = TYPES[8193] = TYPES[8194] = TYPES[8195] = TYPES[8196] = TYPES[8197] = TYPES[8198] = TYPES[8199] = TYPES[8200] = TYPES[8201] = TYPES[8202] = TYPES[8232] = TYPES[8233] = TYPES[8239] = TYPES[8287] = TYPES[12288] = BLANK;
TYPES[8220] = TYPES[8221] = PUNCTUATION;
function assert(predicate, message2) {
  if (!predicate) {
    const msg = typeof message2 === "function" ? message2() : message2 || `expect ${predicate} to be true`;
    throw new AssertionError(msg);
  }
}
function assertEmpty(predicate, message2 = `unexpected ${JSON.stringify(predicate)}`) {
  assert(!predicate, message2);
}
class NullDrop extends Drop {
  equals(value) {
    return isNil(toValue(value));
  }
  gt() {
    return false;
  }
  geq() {
    return false;
  }
  lt() {
    return false;
  }
  leq() {
    return false;
  }
  valueOf() {
    return null;
  }
}
class EmptyDrop extends Drop {
  equals(value) {
    if (value instanceof EmptyDrop)
      return false;
    value = toValue(value);
    if (isString(value) || isArray(value))
      return value.length === 0;
    if (isObject$1(value))
      return Object.keys(value).length === 0;
    return false;
  }
  gt() {
    return false;
  }
  geq() {
    return false;
  }
  lt() {
    return false;
  }
  leq() {
    return false;
  }
  valueOf() {
    return "";
  }
  static is(value) {
    return value instanceof EmptyDrop;
  }
}
class BlankDrop extends EmptyDrop {
  equals(value) {
    if (value === false)
      return true;
    if (isNil(toValue(value)))
      return true;
    if (isString(value))
      return /^\s*$/.test(value);
    return super.equals(value);
  }
  static is(value) {
    return value instanceof BlankDrop;
  }
}
class ForloopDrop extends Drop {
  constructor(length, collection, variable) {
    super();
    this.i = 0;
    this.length = length;
    this.name = `${variable}-${collection}`;
  }
  next() {
    this.i++;
  }
  index0() {
    return this.i;
  }
  index() {
    return this.i + 1;
  }
  first() {
    return this.i === 0;
  }
  last() {
    return this.i === this.length - 1;
  }
  rindex() {
    return this.length - this.i;
  }
  rindex0() {
    return this.length - this.i - 1;
  }
  valueOf() {
    return JSON.stringify(this);
  }
}
class SimpleEmitter {
  constructor() {
    this.buffer = "";
  }
  write(html) {
    this.buffer += stringify(html);
  }
}
class StreamedEmitter {
  constructor() {
    this.buffer = "";
    this.stream = null;
    throw new Error("streaming not supported in browser");
  }
}
class KeepingTypeEmitter {
  constructor() {
    this.buffer = "";
  }
  write(html) {
    html = toValue(html);
    if (typeof html !== "string" && this.buffer === "") {
      this.buffer = html;
    } else {
      this.buffer = stringify(this.buffer) + stringify(html);
    }
  }
}
class BlockDrop extends Drop {
  constructor(superBlockRender = () => "") {
    super();
    this.superBlockRender = superBlockRender;
  }
  /**
   * Provide parent access in child block by
   * {{ block.super }}
   */
  *super() {
    const emitter = new SimpleEmitter();
    yield this.superBlockRender(emitter);
    return emitter.buffer;
  }
}
function isComparable(arg) {
  return arg && isFunction(arg.equals) && isFunction(arg.gt) && isFunction(arg.geq) && isFunction(arg.lt) && isFunction(arg.leq);
}
const nil = new NullDrop();
const literalValues = {
  "true": true,
  "false": false,
  "nil": nil,
  "null": nil,
  "empty": new EmptyDrop(),
  "blank": new BlankDrop()
};
function createTrie(input) {
  const trie = {};
  for (const [name, data] of Object.entries(input)) {
    let node = trie;
    for (let i = 0; i < name.length; i++) {
      const c = name[i];
      node[c] = node[c] || {};
      if (i === name.length - 1 && isWord(name[i])) {
        node[c].needBoundary = true;
      }
      node = node[c];
    }
    node.data = data;
    node.end = true;
  }
  return trie;
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject2) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e) {
        reject2(e);
      }
    }
    function step2(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, [])).next());
  });
}
function toPromise(val) {
  return __awaiter(this, void 0, void 0, function* () {
    if (!isIterator(val))
      return val;
    let value;
    let done = false;
    let next = "next";
    do {
      const state = val[next](value);
      done = state.done;
      value = state.value;
      next = "next";
      try {
        if (isIterator(value))
          value = toPromise(value);
        if (isPromise(value))
          value = yield value;
      } catch (err) {
        next = "throw";
        value = err;
      }
    } while (!done);
    return value;
  });
}
function toValueSync(val) {
  if (!isIterator(val))
    return val;
  let value;
  let done = false;
  let next = "next";
  do {
    const state = val[next](value);
    done = state.done;
    value = state.value;
    next = "next";
    if (isIterator(value)) {
      try {
        value = toValueSync(value);
      } catch (err) {
        next = "throw";
        value = err;
      }
    }
  } while (!done);
  return value;
}
const rFormat = /%([-_0^#:]+)?(\d+)?([EO])?(.)/;
function daysInMonth(d) {
  const feb = isLeapYear(d) ? 29 : 28;
  return [31, feb, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
}
function getDayOfYear(d) {
  let num = 0;
  for (let i = 0; i < d.getMonth(); ++i) {
    num += daysInMonth(d)[i];
  }
  return num + d.getDate();
}
function getWeekOfYear(d, startDay) {
  const now = getDayOfYear(d) + (startDay - d.getDay());
  const jan1 = new Date(d.getFullYear(), 0, 1);
  const then = 7 - jan1.getDay() + startDay;
  return String(Math.floor((now - then) / 7) + 1);
}
function isLeapYear(d) {
  const year2 = d.getFullYear();
  return !!((year2 & 3) === 0 && (year2 % 100 || year2 % 400 === 0 && year2));
}
function ordinal(d) {
  const date2 = d.getDate();
  if ([11, 12, 13].includes(date2))
    return "th";
  switch (date2 % 10) {
    case 1:
      return "st";
    case 2:
      return "nd";
    case 3:
      return "rd";
    default:
      return "th";
  }
}
function century(d) {
  return parseInt(d.getFullYear().toString().substring(0, 2), 10);
}
const padWidths = {
  d: 2,
  e: 2,
  H: 2,
  I: 2,
  j: 3,
  k: 2,
  l: 2,
  L: 3,
  m: 2,
  M: 2,
  S: 2,
  U: 2,
  W: 2
};
const padSpaceChars = new Set("aAbBceklpP");
function getTimezoneOffset(d, opts) {
  const nOffset = Math.abs(d.getTimezoneOffset());
  const h = Math.floor(nOffset / 60);
  const m = nOffset % 60;
  return (d.getTimezoneOffset() > 0 ? "-" : "+") + padStart(h, 2, "0") + (opts.flags[":"] ? ":" : "") + padStart(m, 2, "0");
}
const formatCodes = {
  a: (d) => d.getShortWeekdayName(),
  A: (d) => d.getLongWeekdayName(),
  b: (d) => d.getShortMonthName(),
  B: (d) => d.getLongMonthName(),
  c: (d) => d.toLocaleString(),
  C: (d) => century(d),
  d: (d) => d.getDate(),
  e: (d) => d.getDate(),
  H: (d) => d.getHours(),
  I: (d) => String(d.getHours() % 12 || 12),
  j: (d) => getDayOfYear(d),
  k: (d) => d.getHours(),
  l: (d) => String(d.getHours() % 12 || 12),
  L: (d) => d.getMilliseconds(),
  m: (d) => d.getMonth() + 1,
  M: (d) => d.getMinutes(),
  N: (d, opts) => {
    const width = Number(opts.width) || 9;
    const str = String(d.getMilliseconds()).slice(0, width);
    return padEnd(str, width, "0");
  },
  p: (d) => d.getHours() < 12 ? "AM" : "PM",
  P: (d) => d.getHours() < 12 ? "am" : "pm",
  q: (d) => ordinal(d),
  s: (d) => Math.round(d.getTime() / 1e3),
  S: (d) => d.getSeconds(),
  u: (d) => d.getDay() || 7,
  U: (d) => getWeekOfYear(d, 0),
  w: (d) => d.getDay(),
  W: (d) => getWeekOfYear(d, 1),
  x: (d) => d.toLocaleDateString(),
  X: (d) => d.toLocaleTimeString(),
  y: (d) => d.getFullYear().toString().slice(2, 4),
  Y: (d) => d.getFullYear(),
  z: getTimezoneOffset,
  Z: (d, opts) => d.getTimeZoneName() || getTimezoneOffset(d, opts),
  "t": () => "	",
  "n": () => "\n",
  "%": () => "%"
};
formatCodes.h = formatCodes.b;
function strftime(d, formatStr) {
  let output = "";
  let remaining = formatStr;
  let match;
  while (match = rFormat.exec(remaining)) {
    output += remaining.slice(0, match.index);
    remaining = remaining.slice(match.index + match[0].length);
    output += format(d, match);
  }
  return output + remaining;
}
function format(d, match) {
  const [input, flagStr = "", width, modifier, conversion] = match;
  const convert = formatCodes[conversion];
  if (!convert)
    return input;
  const flags = {};
  for (const flag of flagStr)
    flags[flag] = true;
  let ret = String(convert(d, { flags, width, modifier }));
  let padChar = padSpaceChars.has(conversion) ? " " : "0";
  let padWidth = width || padWidths[conversion] || 0;
  if (flags["^"])
    ret = ret.toUpperCase();
  else if (flags["#"])
    ret = changeCase(ret);
  if (flags["_"])
    padChar = " ";
  else if (flags["0"])
    padChar = "0";
  if (flags["-"])
    padWidth = 0;
  return padStart(ret, padWidth, padChar);
}
function getDateTimeFormat() {
  return typeof Intl !== "undefined" ? Intl.DateTimeFormat : void 0;
}
const OneMinute = 6e4;
const TIMEZONE_PATTERN = /([zZ]|([+-])(\d{2}):?(\d{2}))$/;
const monthNames = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
const monthNamesShort = monthNames.map((name) => name.slice(0, 3));
const dayNames = [
  "Sunday",
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday"
];
const dayNamesShort = dayNames.map((name) => name.slice(0, 3));
class LiquidDate {
  constructor(init, locale, timezone) {
    this.locale = locale;
    this.DateTimeFormat = getDateTimeFormat();
    this.date = new Date(init);
    this.timezoneFixed = timezone !== void 0;
    if (timezone === void 0) {
      timezone = this.date.getTimezoneOffset();
    }
    this.timezoneOffset = isString(timezone) ? LiquidDate.getTimezoneOffset(timezone, this.date) : timezone;
    this.timezoneName = isString(timezone) ? timezone : "";
    const diff = (this.date.getTimezoneOffset() - this.timezoneOffset) * OneMinute;
    const time = this.date.getTime() + diff;
    this.displayDate = new Date(time);
  }
  getTime() {
    return this.displayDate.getTime();
  }
  getMilliseconds() {
    return this.displayDate.getMilliseconds();
  }
  getSeconds() {
    return this.displayDate.getSeconds();
  }
  getMinutes() {
    return this.displayDate.getMinutes();
  }
  getHours() {
    return this.displayDate.getHours();
  }
  getDay() {
    return this.displayDate.getDay();
  }
  getDate() {
    return this.displayDate.getDate();
  }
  getMonth() {
    return this.displayDate.getMonth();
  }
  getFullYear() {
    return this.displayDate.getFullYear();
  }
  toLocaleString(locale, init) {
    if (init === null || init === void 0 ? void 0 : init.timeZone) {
      return this.date.toLocaleString(locale, init);
    }
    return this.displayDate.toLocaleString(locale, init);
  }
  toLocaleTimeString(locale) {
    return this.displayDate.toLocaleTimeString(locale);
  }
  toLocaleDateString(locale) {
    return this.displayDate.toLocaleDateString(locale);
  }
  getTimezoneOffset() {
    return this.timezoneOffset;
  }
  getTimeZoneName() {
    if (this.timezoneFixed)
      return this.timezoneName;
    if (!this.DateTimeFormat)
      return;
    return this.DateTimeFormat().resolvedOptions().timeZone;
  }
  getLongMonthName() {
    var _a;
    return (_a = this.format({ month: "long" })) !== null && _a !== void 0 ? _a : monthNames[this.getMonth()];
  }
  getShortMonthName() {
    var _a;
    return (_a = this.format({ month: "short" })) !== null && _a !== void 0 ? _a : monthNamesShort[this.getMonth()];
  }
  getLongWeekdayName() {
    var _a;
    return (_a = this.format({ weekday: "long" })) !== null && _a !== void 0 ? _a : dayNames[this.displayDate.getDay()];
  }
  getShortWeekdayName() {
    var _a;
    return (_a = this.format({ weekday: "short" })) !== null && _a !== void 0 ? _a : dayNamesShort[this.displayDate.getDay()];
  }
  valid() {
    return !isNaN(this.getTime());
  }
  format(options) {
    return this.DateTimeFormat && this.DateTimeFormat(this.locale, options).format(this.displayDate);
  }
  /**
   * Create a Date object fixed to it's declared Timezone. Both
   * - 2021-08-06T02:29:00.000Z and
   * - 2021-08-06T02:29:00.000+08:00
   * will always be displayed as
   * - 2021-08-06 02:29:00
   * regardless timezoneOffset in JavaScript realm
   *
   * The implementation hack:
   * Instead of calling `.getMonth()`/`.getUTCMonth()` respect to `preserveTimezones`,
   * we create a different Date to trick strftime, it's both simpler and more performant.
   * Given that a template is expected to be parsed fewer times than rendered.
   */
  static createDateFixedToTimezone(dateString, locale) {
    const m = dateString.match(TIMEZONE_PATTERN);
    if (m && m[1] === "Z") {
      return new LiquidDate(+new Date(dateString), locale, 0);
    }
    if (m && m[2] && m[3] && m[4]) {
      const [, , sign, hours, minutes] = m;
      const offset2 = (sign === "+" ? -1 : 1) * (parseInt(hours, 10) * 60 + parseInt(minutes, 10));
      return new LiquidDate(+new Date(dateString), locale, offset2);
    }
    return new LiquidDate(dateString, locale);
  }
  static getTimezoneOffset(timezoneName, date2) {
    const localDateString = date2.toLocaleString("en-US", { timeZone: timezoneName });
    const utcDateString = date2.toLocaleString("en-US", { timeZone: "UTC" });
    const localDate = new Date(localDateString);
    const utcDate = new Date(utcDateString);
    return (+utcDate - +localDate) / (60 * 1e3);
  }
}
class Limiter {
  constructor(resource, limit2) {
    this.base = 0;
    this.message = `${resource} limit exceeded`;
    this.limit = limit2;
  }
  use(count) {
    count = +count || 0;
    assert(this.base + count <= this.limit, this.message);
    this.base += count;
  }
  check(count) {
    count = +count || 0;
    assert(count <= this.limit, this.message);
  }
}
class DelimitedToken extends Token {
  constructor(kind, [contentBegin, contentEnd], input, begin, end, trimLeft2, trimRight2, file) {
    super(kind, input, begin, end, file);
    this.trimLeft = false;
    this.trimRight = false;
    const tl = input[contentBegin] === "-";
    const tr = input[contentEnd - 1] === "-";
    let l = tl ? contentBegin + 1 : contentBegin;
    let r = tr ? contentEnd - 1 : contentEnd;
    while (l < r && TYPES[input.charCodeAt(l)] & BLANK)
      l++;
    while (r > l && TYPES[input.charCodeAt(r - 1)] & BLANK)
      r--;
    this.contentRange = [l, r];
    this.trimLeft = tl || trimLeft2;
    this.trimRight = tr || trimRight2;
  }
  get content() {
    return this.input.slice(this.contentRange[0], this.contentRange[1]);
  }
}
class TagToken extends DelimitedToken {
  constructor(input, begin, end, options, file) {
    const { trimTagLeft, trimTagRight, tagDelimiterLeft, tagDelimiterRight } = options;
    const [valueBegin, valueEnd] = [begin + tagDelimiterLeft.length, end - tagDelimiterRight.length];
    super(TokenKind.Tag, [valueBegin, valueEnd], input, begin, end, trimTagLeft, trimTagRight, file);
    this.tokenizer = new Tokenizer(input, options.operators, file, this.contentRange);
    this.name = this.tokenizer.readTagName();
    this.tokenizer.assert(this.name, `illegal tag syntax, tag name expected`);
    this.tokenizer.skipBlank();
    this.args = this.tokenizer.input.slice(this.tokenizer.p, this.contentRange[1]);
  }
}
class OutputToken extends DelimitedToken {
  constructor(input, begin, end, options, file) {
    const { trimOutputLeft, trimOutputRight, outputDelimiterLeft, outputDelimiterRight } = options;
    const valueRange = [begin + outputDelimiterLeft.length, end - outputDelimiterRight.length];
    super(TokenKind.Output, valueRange, input, begin, end, trimOutputLeft, trimOutputRight, file);
  }
}
class HTMLToken extends Token {
  constructor(input, begin, end, file) {
    super(TokenKind.HTML, input, begin, end, file);
    this.input = input;
    this.begin = begin;
    this.end = end;
    this.file = file;
    this.trimLeft = 0;
    this.trimRight = 0;
  }
  getContent() {
    return this.input.slice(this.begin + this.trimLeft, this.end - this.trimRight);
  }
}
class NumberToken extends Token {
  constructor(input, begin, end, file) {
    super(TokenKind.Number, input, begin, end, file);
    this.input = input;
    this.begin = begin;
    this.end = end;
    this.file = file;
    this.content = Number(this.getText());
  }
}
class IdentifierToken extends Token {
  constructor(input, begin, end, file) {
    super(TokenKind.Word, input, begin, end, file);
    this.input = input;
    this.begin = begin;
    this.end = end;
    this.file = file;
    this.content = this.getText();
  }
}
class LiteralToken extends Token {
  constructor(input, begin, end, file) {
    super(TokenKind.Literal, input, begin, end, file);
    this.input = input;
    this.begin = begin;
    this.end = end;
    this.file = file;
    this.literal = this.getText();
    this.content = literalValues[this.literal];
  }
}
const operatorPrecedences = {
  "==": 2,
  "!=": 2,
  ">": 2,
  "<": 2,
  ">=": 2,
  "<=": 2,
  "contains": 2,
  "not": 1,
  "and": 0,
  "or": 0
};
const operatorTypes = {
  "==": 0,
  "!=": 0,
  ">": 0,
  "<": 0,
  ">=": 0,
  "<=": 0,
  "contains": 0,
  "not": 1,
  "and": 0,
  "or": 0
  /* OperatorType.Binary */
};
class OperatorToken extends Token {
  constructor(input, begin, end, file) {
    super(TokenKind.Operator, input, begin, end, file);
    this.input = input;
    this.begin = begin;
    this.end = end;
    this.file = file;
    this.operator = this.getText();
  }
  getPrecedence() {
    const key = this.getText();
    return key in operatorPrecedences ? operatorPrecedences[key] : 1;
  }
}
class PropertyAccessToken extends Token {
  constructor(variable, props, input, begin, end, file) {
    super(TokenKind.PropertyAccess, input, begin, end, file);
    this.variable = variable;
    this.props = props;
  }
}
class FilterToken extends Token {
  constructor(name, args, input, begin, end, file) {
    super(TokenKind.Filter, input, begin, end, file);
    this.name = name;
    this.args = args;
  }
}
class HashToken extends Token {
  constructor(input, begin, end, name, value, file) {
    super(TokenKind.Hash, input, begin, end, file);
    this.input = input;
    this.begin = begin;
    this.end = end;
    this.name = name;
    this.value = value;
    this.file = file;
  }
}
const rHex = /[\da-fA-F]/;
const rOct = /[0-7]/;
const escapeChar = {
  b: "\b",
  f: "\f",
  n: "\n",
  r: "\r",
  t: "	",
  v: "\v"
};
function hexVal(c) {
  const code = c.charCodeAt(0);
  if (code >= 97)
    return code - 87;
  if (code >= 65)
    return code - 55;
  return code - 48;
}
function parseStringLiteral(str) {
  let ret = "";
  for (let i = 1; i < str.length - 1; i++) {
    if (str[i] !== "\\") {
      ret += str[i];
      continue;
    }
    if (escapeChar[str[i + 1]] !== void 0) {
      ret += escapeChar[str[++i]];
    } else if (str[i + 1] === "u") {
      let val = 0;
      let j = i + 2;
      while (j <= i + 5 && rHex.test(str[j])) {
        val = val * 16 + hexVal(str[j++]);
      }
      i = j - 1;
      ret += String.fromCharCode(val);
    } else if (!rOct.test(str[i + 1])) {
      ret += str[++i];
    } else {
      let j = i + 1;
      let val = 0;
      while (j <= i + 3 && rOct.test(str[j])) {
        val = val * 8 + hexVal(str[j++]);
      }
      i = j - 1;
      ret += String.fromCharCode(val);
    }
  }
  return ret;
}
class QuotedToken extends Token {
  constructor(input, begin, end, file) {
    super(TokenKind.Quoted, input, begin, end, file);
    this.input = input;
    this.begin = begin;
    this.end = end;
    this.file = file;
    this.content = parseStringLiteral(this.getText());
  }
}
class RangeToken extends Token {
  constructor(input, begin, end, lhs, rhs, file) {
    super(TokenKind.Range, input, begin, end, file);
    this.input = input;
    this.begin = begin;
    this.end = end;
    this.lhs = lhs;
    this.rhs = rhs;
    this.file = file;
  }
}
class LiquidTagToken extends DelimitedToken {
  constructor(input, begin, end, options, file) {
    super(TokenKind.Tag, [begin, end], input, begin, end, false, false, file);
    this.tokenizer = new Tokenizer(input, options.operators, file, this.contentRange);
    this.name = this.tokenizer.readTagName();
    this.tokenizer.assert(this.name, "illegal liquid tag syntax");
    this.tokenizer.skipBlank();
  }
  get args() {
    return this.tokenizer.input.slice(this.tokenizer.p, this.contentRange[1]);
  }
}
class FilteredValueToken extends Token {
  constructor(initial, filters2, input, begin, end, file) {
    super(TokenKind.FilteredValue, input, begin, end, file);
    this.initial = initial;
    this.filters = filters2;
    this.input = input;
    this.begin = begin;
    this.end = end;
    this.file = file;
  }
}
const polyfill = {
  now: () => Date.now()
};
function getPerformance() {
  return typeof global === "object" && global.performance || typeof window === "object" && window.performance || polyfill;
}
class Render {
  renderTemplatesToNodeStream(templates, ctx) {
    const emitter = new StreamedEmitter();
    Promise.resolve().then(() => toPromise(this.renderTemplates(templates, ctx, emitter))).then(() => emitter.end(), (err) => emitter.error(err));
    return emitter.stream;
  }
  *renderTemplates(templates, ctx, emitter) {
    if (!emitter) {
      emitter = ctx.opts.keepOutputType ? new KeepingTypeEmitter() : new SimpleEmitter();
    }
    const errors = [];
    for (const tpl of templates) {
      ctx.renderLimit.check(getPerformance().now());
      try {
        const html = yield tpl.render(ctx, emitter);
        html && emitter.write(html);
        if (ctx.breakCalled || ctx.continueCalled)
          break;
      } catch (e) {
        const err = LiquidError.is(e) ? e : new RenderError(e, tpl);
        if (ctx.opts.catchAllErrors)
          errors.push(err);
        else
          throw err;
      }
    }
    if (errors.length) {
      throw new LiquidErrors(errors);
    }
    return emitter.buffer;
  }
}
class Expression {
  constructor(tokens) {
    this.postfix = [...toPostfix(tokens)];
  }
  *evaluate(ctx, lenient) {
    assert(ctx, "unable to evaluate: context not defined");
    const operands = [];
    for (const token of this.postfix) {
      if (isOperatorToken(token)) {
        const r = operands.pop();
        let result;
        if (operatorTypes[token.operator] === 1) {
          result = yield ctx.opts.operators[token.operator](r, ctx);
        } else {
          const l = operands.pop();
          result = yield ctx.opts.operators[token.operator](l, r, ctx);
        }
        operands.push(result);
      } else {
        operands.push(yield evalToken(token, ctx, lenient));
      }
    }
    return operands[0];
  }
  valid() {
    return !!this.postfix.length;
  }
}
function* evalToken(token, ctx, lenient = false) {
  if (!token)
    return;
  if ("content" in token)
    return token.content;
  if (isPropertyAccessToken(token))
    return yield evalPropertyAccessToken(token, ctx, lenient);
  if (isRangeToken(token))
    return yield evalRangeToken(token, ctx);
}
function* evalPropertyAccessToken(token, ctx, lenient) {
  const props = [];
  for (const prop of token.props) {
    props.push(yield evalToken(prop, ctx, false));
  }
  try {
    if (token.variable) {
      const variable = yield evalToken(token.variable, ctx, lenient);
      return yield ctx._getFromScope(variable, props);
    } else {
      return yield ctx._get(props);
    }
  } catch (e) {
    if (lenient && e.name === "InternalUndefinedVariableError")
      return null;
    throw new UndefinedVariableError(e, token);
  }
}
function evalQuotedToken(token) {
  return token.content;
}
function* evalRangeToken(token, ctx) {
  const low = yield evalToken(token.lhs, ctx);
  const high = yield evalToken(token.rhs, ctx);
  ctx.memoryLimit.use(high - low + 1);
  return range(+low, +high + 1);
}
function* toPostfix(tokens) {
  const ops = [];
  for (const token of tokens) {
    if (isOperatorToken(token)) {
      while (ops.length && ops[ops.length - 1].getPrecedence() > token.getPrecedence()) {
        yield ops.pop();
      }
      ops.push(token);
    } else
      yield token;
  }
  while (ops.length) {
    yield ops.pop();
  }
}
function isTruthy(val, ctx) {
  return !isFalsy(val, ctx);
}
function isFalsy(val, ctx) {
  val = toValue(val);
  if (ctx.opts.jsTruthy) {
    return !val;
  } else {
    return val === false || void 0 === val || val === null;
  }
}
const defaultOperators = {
  "==": equals,
  "!=": (l, r) => !equals(l, r),
  ">": (l, r) => {
    if (isComparable(l))
      return l.gt(r);
    if (isComparable(r))
      return r.lt(l);
    return toValue(l) > toValue(r);
  },
  "<": (l, r) => {
    if (isComparable(l))
      return l.lt(r);
    if (isComparable(r))
      return r.gt(l);
    return toValue(l) < toValue(r);
  },
  ">=": (l, r) => {
    if (isComparable(l))
      return l.geq(r);
    if (isComparable(r))
      return r.leq(l);
    return toValue(l) >= toValue(r);
  },
  "<=": (l, r) => {
    if (isComparable(l))
      return l.leq(r);
    if (isComparable(r))
      return r.geq(l);
    return toValue(l) <= toValue(r);
  },
  "contains": (l, r) => {
    l = toValue(l);
    if (isArray(l))
      return l.some((i) => equals(i, r));
    if (isFunction(l === null || l === void 0 ? void 0 : l.indexOf))
      return l.indexOf(toValue(r)) > -1;
    return false;
  },
  "not": (v, ctx) => isFalsy(toValue(v), ctx),
  "and": (l, r, ctx) => isTruthy(toValue(l), ctx) && isTruthy(toValue(r), ctx),
  "or": (l, r, ctx) => isTruthy(toValue(l), ctx) || isTruthy(toValue(r), ctx)
};
function equals(lhs, rhs) {
  if (isComparable(lhs))
    return lhs.equals(rhs);
  if (isComparable(rhs))
    return rhs.equals(lhs);
  lhs = toValue(lhs);
  rhs = toValue(rhs);
  if (isArray(lhs)) {
    return isArray(rhs) && arrayEquals(lhs, rhs);
  }
  return lhs === rhs;
}
function arrayEquals(lhs, rhs) {
  if (lhs.length !== rhs.length)
    return false;
  return !lhs.some((value, i) => !equals(value, rhs[i]));
}
function arrayIncludes(arr, item) {
  return arr.some((value) => equals(value, item));
}
class Node {
  constructor(key, value, next, prev) {
    this.key = key;
    this.value = value;
    this.next = next;
    this.prev = prev;
  }
}
class LRU {
  constructor(limit2, size2 = 0) {
    this.limit = limit2;
    this.size = size2;
    this.cache = {};
    this.head = new Node("HEAD", null, null, null);
    this.tail = new Node("TAIL", null, null, null);
    this.head.next = this.tail;
    this.tail.prev = this.head;
  }
  write(key, value) {
    if (this.cache[key]) {
      this.cache[key].value = value;
    } else {
      const node = new Node(key, value, this.head.next, this.head);
      this.head.next.prev = node;
      this.head.next = node;
      this.cache[key] = node;
      this.size++;
      this.ensureLimit();
    }
  }
  read(key) {
    if (!this.cache[key])
      return;
    const { value } = this.cache[key];
    this.remove(key);
    this.write(key, value);
    return value;
  }
  remove(key) {
    const node = this.cache[key];
    node.prev.next = node.next;
    node.next.prev = node.prev;
    delete this.cache[key];
    this.size--;
  }
  clear() {
    this.head.next = this.tail;
    this.tail.prev = this.head;
    this.size = 0;
    this.cache = {};
  }
  ensureLimit() {
    if (this.size > this.limit)
      this.remove(this.tail.prev.key);
  }
}
function domResolve(root, path) {
  const base = document.createElement("base");
  base.href = root;
  const head = document.getElementsByTagName("head")[0];
  head.insertBefore(base, head.firstChild);
  const a = document.createElement("a");
  a.href = path;
  const resolved = a.href;
  head.removeChild(base);
  return resolved;
}
function resolve(root, filepath, ext) {
  if (root.length && last(root) !== "/")
    root += "/";
  const url = domResolve(root, filepath);
  return url.replace(/^(\w+:\/\/[^/]+)(\/[^?]+)/, (str, origin, path) => {
    const last2 = path.split("/").pop();
    if (/\.\w+$/.test(last2))
      return str;
    return origin + path + ext;
  });
}
function readFile(url) {
  return __awaiter(this, void 0, void 0, function* () {
    return new Promise((resolve2, reject2) => {
      const xhr = new XMLHttpRequest();
      xhr.onload = () => {
        if (xhr.status >= 200 && xhr.status < 300) {
          resolve2(xhr.responseText);
        } else {
          reject2(new Error(xhr.statusText));
        }
      };
      xhr.onerror = () => {
        reject2(new Error("An error occurred whilst receiving the response."));
      };
      xhr.open("GET", url);
      xhr.send();
    });
  });
}
function readFileSync(url) {
  const xhr = new XMLHttpRequest();
  xhr.open("GET", url, false);
  xhr.send();
  if (xhr.status < 200 || xhr.status >= 300) {
    throw new Error(xhr.statusText);
  }
  return xhr.responseText;
}
function exists(filepath) {
  return __awaiter(this, void 0, void 0, function* () {
    return true;
  });
}
function existsSync(filepath) {
  return true;
}
function dirname(filepath) {
  return domResolve(filepath, ".");
}
const sep = "/";
var fs = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  resolve,
  readFile,
  readFileSync,
  exists,
  existsSync,
  dirname,
  sep
});
function defaultFilter(value, defaultValue, ...args) {
  value = toValue(value);
  if (isArray(value) || isString(value))
    return value.length ? value : defaultValue;
  if (value === false && new Map(args).get("allow_false"))
    return false;
  return isFalsy(value, this.context) ? defaultValue : value;
}
function json(value, space = 0) {
  return JSON.stringify(value, null, space);
}
function inspect(value, space = 0) {
  const ancestors = [];
  return JSON.stringify(value, function(_key, value2) {
    if (typeof value2 !== "object" || value2 === null)
      return value2;
    while (ancestors.length > 0 && ancestors[ancestors.length - 1] !== this)
      ancestors.pop();
    if (ancestors.includes(value2))
      return "[Circular]";
    ancestors.push(value2);
    return value2;
  }, space);
}
function to_integer(value) {
  return Number(value);
}
const raw = {
  raw: true,
  handler: identify
};
var misc = {
  default: defaultFilter,
  raw,
  jsonify: json,
  to_integer,
  json,
  inspect
};
const escapeMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&#34;",
  "'": "&#39;"
};
const unescapeMap = {
  "&amp;": "&",
  "&lt;": "<",
  "&gt;": ">",
  "&#34;": '"',
  "&#39;": "'"
};
function escape(str) {
  str = stringify(str);
  this.context.memoryLimit.use(str.length);
  return str.replace(/&|<|>|"|'/g, (m) => escapeMap[m]);
}
function xml_escape(str) {
  return escape.call(this, str);
}
function unescape(str) {
  str = stringify(str);
  this.context.memoryLimit.use(str.length);
  return str.replace(/&(amp|lt|gt|#34|#39);/g, (m) => unescapeMap[m]);
}
function escape_once(str) {
  return escape.call(this, unescape.call(this, str));
}
function newline_to_br(v) {
  const str = stringify(v);
  this.context.memoryLimit.use(str.length);
  return str.replace(/\r?\n/gm, "<br />\n");
}
function strip_html(v) {
  const str = stringify(v);
  this.context.memoryLimit.use(str.length);
  return str.replace(/<script[\s\S]*?<\/script>|<style[\s\S]*?<\/style>|<.*?>|<!--[\s\S]*?-->/g, "");
}
var htmlFilters = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  escape,
  xml_escape,
  escape_once,
  newline_to_br,
  strip_html
});
class MapFS {
  constructor(mapping) {
    this.mapping = mapping;
    this.sep = "/";
  }
  exists(filepath) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.existsSync(filepath);
    });
  }
  existsSync(filepath) {
    return !isNil(this.mapping[filepath]);
  }
  readFile(filepath) {
    return __awaiter(this, void 0, void 0, function* () {
      return this.readFileSync(filepath);
    });
  }
  readFileSync(filepath) {
    const content = this.mapping[filepath];
    if (isNil(content))
      throw new Error(`ENOENT: ${filepath}`);
    return content;
  }
  dirname(filepath) {
    const segments = filepath.split(this.sep);
    segments.pop();
    return segments.join(this.sep);
  }
  resolve(dir, file, ext) {
    file += ext;
    if (dir === ".")
      return file;
    const segments = dir.split(/\/+/);
    for (const segment of file.split(this.sep)) {
      if (segment === "." || segment === "")
        continue;
      else if (segment === "..") {
        if (segments.length > 1 || segments[0] !== "")
          segments.pop();
      } else
        segments.push(segment);
    }
    return segments.join(this.sep);
  }
}
const defaultOptions = {
  root: ["."],
  layouts: ["."],
  partials: ["."],
  relativeReference: true,
  jekyllInclude: false,
  keyValueSeparator: ":",
  cache: void 0,
  extname: "",
  fs,
  dynamicPartials: true,
  jsTruthy: false,
  dateFormat: "%A, %B %-e, %Y at %-l:%M %P %z",
  locale: "",
  trimTagRight: false,
  trimTagLeft: false,
  trimOutputRight: false,
  trimOutputLeft: false,
  greedy: true,
  tagDelimiterLeft: "{%",
  tagDelimiterRight: "%}",
  outputDelimiterLeft: "{{",
  outputDelimiterRight: "}}",
  preserveTimezones: false,
  strictFilters: false,
  strictVariables: false,
  ownPropertyOnly: true,
  lenientIf: false,
  globals: {},
  keepOutputType: false,
  operators: defaultOperators,
  memoryLimit: Infinity,
  parseLimit: Infinity,
  renderLimit: Infinity
};
function normalize(options) {
  var _a, _b;
  if (options.hasOwnProperty("root")) {
    if (!options.hasOwnProperty("partials"))
      options.partials = options.root;
    if (!options.hasOwnProperty("layouts"))
      options.layouts = options.root;
  }
  if (options.hasOwnProperty("cache")) {
    let cache2;
    if (typeof options.cache === "number")
      cache2 = options.cache > 0 ? new LRU(options.cache) : void 0;
    else if (typeof options.cache === "object")
      cache2 = options.cache;
    else
      cache2 = options.cache ? new LRU(1024) : void 0;
    options.cache = cache2;
  }
  options = Object.assign(Object.assign(Object.assign({}, defaultOptions), options.jekyllInclude ? { dynamicPartials: false } : {}), options);
  if ((!options.fs.dirname || !options.fs.sep) && options.relativeReference) {
    console.warn("[LiquidJS] `fs.dirname` and `fs.sep` are required for relativeReference, set relativeReference to `false` to suppress this warning");
    options.relativeReference = false;
  }
  options.root = normalizeDirectoryList(options.root);
  options.partials = normalizeDirectoryList(options.partials);
  options.layouts = normalizeDirectoryList(options.layouts);
  options.outputEscape = options.outputEscape && getOutputEscapeFunction(options.outputEscape);
  if (!options.locale) {
    options.locale = (_b = (_a = getDateTimeFormat()) === null || _a === void 0 ? void 0 : _a().resolvedOptions().locale) !== null && _b !== void 0 ? _b : "en-US";
  }
  if (options.templates) {
    options.fs = new MapFS(options.templates);
    options.relativeReference = true;
    options.root = options.partials = options.layouts = ".";
  }
  return options;
}
function getOutputEscapeFunction(nameOrFunction) {
  if (nameOrFunction === "escape")
    return escape;
  if (nameOrFunction === "json")
    return misc.json;
  assert(isFunction(nameOrFunction), "`outputEscape` need to be of type string or function");
  return nameOrFunction;
}
function normalizeDirectoryList(value) {
  let list = [];
  if (isArray(value))
    list = value;
  if (isString(value))
    list = [value];
  return list;
}
function whiteSpaceCtrl(tokens, options) {
  let inRaw = false;
  for (let i = 0; i < tokens.length; i++) {
    const token = tokens[i];
    if (!isDelimitedToken(token))
      continue;
    if (!inRaw && token.trimLeft) {
      trimLeft(tokens[i - 1], options.greedy);
    }
    if (isTagToken(token)) {
      if (token.name === "raw")
        inRaw = true;
      else if (token.name === "endraw")
        inRaw = false;
    }
    if (!inRaw && token.trimRight) {
      trimRight(tokens[i + 1], options.greedy);
    }
  }
}
function trimLeft(token, greedy) {
  if (!token || !isHTMLToken(token))
    return;
  const mask = greedy ? BLANK : INLINE_BLANK;
  while (TYPES[token.input.charCodeAt(token.end - 1 - token.trimRight)] & mask)
    token.trimRight++;
}
function trimRight(token, greedy) {
  if (!token || !isHTMLToken(token))
    return;
  const mask = greedy ? BLANK : INLINE_BLANK;
  while (TYPES[token.input.charCodeAt(token.begin + token.trimLeft)] & mask)
    token.trimLeft++;
  if (token.input.charAt(token.begin + token.trimLeft) === "\n")
    token.trimLeft++;
}
class Tokenizer {
  constructor(input, operators = defaultOptions.operators, file, range2) {
    this.input = input;
    this.file = file;
    this.rawBeginAt = -1;
    this.p = range2 ? range2[0] : 0;
    this.N = range2 ? range2[1] : input.length;
    this.opTrie = createTrie(operators);
    this.literalTrie = createTrie(literalValues);
  }
  readExpression() {
    return new Expression(this.readExpressionTokens());
  }
  *readExpressionTokens() {
    while (this.p < this.N) {
      const operator = this.readOperator();
      if (operator) {
        yield operator;
        continue;
      }
      const operand = this.readValue();
      if (operand) {
        yield operand;
        continue;
      }
      return;
    }
  }
  readOperator() {
    this.skipBlank();
    const end = this.matchTrie(this.opTrie);
    if (end === -1)
      return;
    return new OperatorToken(this.input, this.p, this.p = end, this.file);
  }
  matchTrie(trie) {
    let node = trie;
    let i = this.p;
    let info;
    while (node[this.input[i]] && i < this.N) {
      node = node[this.input[i++]];
      if (node["end"])
        info = node;
    }
    if (!info)
      return -1;
    if (info["needBoundary"] && isWord(this.peek(i - this.p)))
      return -1;
    return i;
  }
  readFilteredValue() {
    const begin = this.p;
    const initial = this.readExpression();
    this.assert(initial.valid(), `invalid value expression: ${this.snapshot()}`);
    const filters2 = this.readFilters();
    return new FilteredValueToken(initial, filters2, this.input, begin, this.p, this.file);
  }
  readFilters() {
    const filters2 = [];
    while (true) {
      const filter2 = this.readFilter();
      if (!filter2)
        return filters2;
      filters2.push(filter2);
    }
  }
  readFilter() {
    this.skipBlank();
    if (this.end())
      return null;
    this.assert(this.read() === "|", `expected "|" before filter`);
    const name = this.readIdentifier();
    if (!name.size()) {
      this.assert(this.end(), `expected filter name`);
      return null;
    }
    const args = [];
    this.skipBlank();
    if (this.peek() === ":") {
      do {
        ++this.p;
        const arg = this.readFilterArg();
        arg && args.push(arg);
        this.skipBlank();
        this.assert(this.end() || this.peek() === "," || this.peek() === "|", () => `unexpected character ${this.snapshot()}`);
      } while (this.peek() === ",");
    } else if (this.peek() === "|" || this.end()) ;
    else {
      throw this.error('expected ":" after filter name');
    }
    return new FilterToken(name.getText(), args, this.input, name.begin, this.p, this.file);
  }
  readFilterArg() {
    const key = this.readValue();
    if (!key)
      return;
    this.skipBlank();
    if (this.peek() !== ":")
      return key;
    ++this.p;
    const value = this.readValue();
    return [key.getText(), value];
  }
  readTopLevelTokens(options = defaultOptions) {
    const tokens = [];
    while (this.p < this.N) {
      const token = this.readTopLevelToken(options);
      tokens.push(token);
    }
    whiteSpaceCtrl(tokens, options);
    return tokens;
  }
  readTopLevelToken(options) {
    const { tagDelimiterLeft, outputDelimiterLeft } = options;
    if (this.rawBeginAt > -1)
      return this.readEndrawOrRawContent(options);
    if (this.match(tagDelimiterLeft))
      return this.readTagToken(options);
    if (this.match(outputDelimiterLeft))
      return this.readOutputToken(options);
    return this.readHTMLToken([tagDelimiterLeft, outputDelimiterLeft]);
  }
  readHTMLToken(stopStrings) {
    const begin = this.p;
    while (this.p < this.N) {
      if (stopStrings.some((str) => this.match(str)))
        break;
      ++this.p;
    }
    return new HTMLToken(this.input, begin, this.p, this.file);
  }
  readTagToken(options) {
    const { file, input } = this;
    const begin = this.p;
    if (this.readToDelimiter(options.tagDelimiterRight) === -1) {
      throw this.error(`tag ${this.snapshot(begin)} not closed`, begin);
    }
    const token = new TagToken(input, begin, this.p, options, file);
    if (token.name === "raw")
      this.rawBeginAt = begin;
    return token;
  }
  readToDelimiter(delimiter, respectQuoted = false) {
    this.skipBlank();
    while (this.p < this.N) {
      if (respectQuoted && this.peekType() & QUOTE) {
        this.readQuoted();
        continue;
      }
      ++this.p;
      if (this.rmatch(delimiter))
        return this.p;
    }
    return -1;
  }
  readOutputToken(options = defaultOptions) {
    const { file, input } = this;
    const { outputDelimiterRight } = options;
    const begin = this.p;
    if (this.readToDelimiter(outputDelimiterRight, true) === -1) {
      throw this.error(`output ${this.snapshot(begin)} not closed`, begin);
    }
    return new OutputToken(input, begin, this.p, options, file);
  }
  readEndrawOrRawContent(options) {
    const { tagDelimiterLeft, tagDelimiterRight } = options;
    const begin = this.p;
    let leftPos = this.readTo(tagDelimiterLeft) - tagDelimiterLeft.length;
    while (this.p < this.N) {
      if (this.readIdentifier().getText() !== "endraw") {
        leftPos = this.readTo(tagDelimiterLeft) - tagDelimiterLeft.length;
        continue;
      }
      while (this.p <= this.N) {
        if (this.rmatch(tagDelimiterRight)) {
          const end = this.p;
          if (begin === leftPos) {
            this.rawBeginAt = -1;
            return new TagToken(this.input, begin, end, options, this.file);
          } else {
            this.p = leftPos;
            return new HTMLToken(this.input, begin, leftPos, this.file);
          }
        }
        if (this.rmatch(tagDelimiterLeft))
          break;
        this.p++;
      }
    }
    throw this.error(`raw ${this.snapshot(this.rawBeginAt)} not closed`, begin);
  }
  readLiquidTagTokens(options = defaultOptions) {
    const tokens = [];
    while (this.p < this.N) {
      const token = this.readLiquidTagToken(options);
      token && tokens.push(token);
    }
    return tokens;
  }
  readLiquidTagToken(options) {
    this.skipBlank();
    if (this.end())
      return;
    const begin = this.p;
    this.readToDelimiter("\n");
    const end = this.p;
    return new LiquidTagToken(this.input, begin, end, options, this.file);
  }
  error(msg, pos = this.p) {
    return new TokenizationError(msg, new IdentifierToken(this.input, pos, this.N, this.file));
  }
  assert(pred, msg, pos) {
    if (!pred)
      throw this.error(typeof msg === "function" ? msg() : msg, pos);
  }
  snapshot(begin = this.p) {
    return JSON.stringify(ellipsis(this.input.slice(begin, this.N), 32));
  }
  /**
   * @deprecated use #readIdentifier instead
   */
  readWord() {
    return this.readIdentifier();
  }
  readIdentifier() {
    this.skipBlank();
    const begin = this.p;
    while (!this.end() && isWord(this.peek()))
      ++this.p;
    return new IdentifierToken(this.input, begin, this.p, this.file);
  }
  readNonEmptyIdentifier() {
    const id = this.readIdentifier();
    return id.size() ? id : void 0;
  }
  readTagName() {
    this.skipBlank();
    if (this.input[this.p] === "#")
      return this.input.slice(this.p, ++this.p);
    return this.readIdentifier().getText();
  }
  readHashes(jekyllStyle) {
    const hashes = [];
    while (true) {
      const hash = this.readHash(jekyllStyle);
      if (!hash)
        return hashes;
      hashes.push(hash);
    }
  }
  readHash(jekyllStyle) {
    this.skipBlank();
    if (this.peek() === ",")
      ++this.p;
    const begin = this.p;
    const name = this.readNonEmptyIdentifier();
    if (!name)
      return;
    let value;
    this.skipBlank();
    const sep2 = isString(jekyllStyle) ? jekyllStyle : jekyllStyle ? "=" : ":";
    if (this.peek() === sep2) {
      ++this.p;
      value = this.readValue();
    }
    return new HashToken(this.input, begin, this.p, name, value, this.file);
  }
  remaining() {
    return this.input.slice(this.p, this.N);
  }
  advance(step2 = 1) {
    this.p += step2;
  }
  end() {
    return this.p >= this.N;
  }
  read() {
    return this.input[this.p++];
  }
  readTo(end) {
    while (this.p < this.N) {
      ++this.p;
      if (this.rmatch(end))
        return this.p;
    }
    return -1;
  }
  readValue() {
    this.skipBlank();
    const begin = this.p;
    const variable = this.readLiteral() || this.readQuoted() || this.readRange() || this.readNumber();
    const props = this.readProperties(!variable);
    if (!props.length)
      return variable;
    return new PropertyAccessToken(variable, props, this.input, begin, this.p);
  }
  readScopeValue() {
    this.skipBlank();
    const begin = this.p;
    const props = this.readProperties();
    if (!props.length)
      return void 0;
    return new PropertyAccessToken(void 0, props, this.input, begin, this.p);
  }
  readProperties(isBegin = true) {
    const props = [];
    while (true) {
      if (this.peek() === "[") {
        this.p++;
        const prop = this.readValue() || new IdentifierToken(this.input, this.p, this.p, this.file);
        this.assert(this.readTo("]") !== -1, "[ not closed");
        props.push(prop);
        continue;
      }
      if (isBegin && !props.length) {
        const prop = this.readNonEmptyIdentifier();
        if (prop) {
          props.push(prop);
          continue;
        }
      }
      if (this.peek() === "." && this.peek(1) !== ".") {
        this.p++;
        const prop = this.readNonEmptyIdentifier();
        if (!prop)
          break;
        props.push(prop);
        continue;
      }
      break;
    }
    return props;
  }
  readNumber() {
    this.skipBlank();
    let decimalFound = false;
    let digitFound = false;
    let n = 0;
    if (this.peekType() & SIGN)
      n++;
    while (this.p + n <= this.N) {
      if (this.peekType(n) & NUMBER) {
        digitFound = true;
        n++;
      } else if (this.peek(n) === "." && this.peek(n + 1) !== ".") {
        if (decimalFound || !digitFound)
          return;
        decimalFound = true;
        n++;
      } else
        break;
    }
    if (digitFound && !isWord(this.peek(n))) {
      const num = new NumberToken(this.input, this.p, this.p + n, this.file);
      this.advance(n);
      return num;
    }
  }
  readLiteral() {
    this.skipBlank();
    const end = this.matchTrie(this.literalTrie);
    if (end === -1)
      return;
    const literal = new LiteralToken(this.input, this.p, end, this.file);
    this.p = end;
    return literal;
  }
  readRange() {
    this.skipBlank();
    const begin = this.p;
    if (this.peek() !== "(")
      return;
    ++this.p;
    const lhs = this.readValueOrThrow();
    this.skipBlank();
    this.assert(this.read() === "." && this.read() === ".", "invalid range syntax");
    const rhs = this.readValueOrThrow();
    this.skipBlank();
    this.assert(this.read() === ")", "invalid range syntax");
    return new RangeToken(this.input, begin, this.p, lhs, rhs, this.file);
  }
  readValueOrThrow() {
    const value = this.readValue();
    this.assert(value, () => `unexpected token ${this.snapshot()}, value expected`);
    return value;
  }
  readQuoted() {
    this.skipBlank();
    const begin = this.p;
    if (!(this.peekType() & QUOTE))
      return;
    ++this.p;
    let escaped = false;
    while (this.p < this.N) {
      ++this.p;
      if (this.input[this.p - 1] === this.input[begin] && !escaped)
        break;
      if (escaped)
        escaped = false;
      else if (this.input[this.p - 1] === "\\")
        escaped = true;
    }
    return new QuotedToken(this.input, begin, this.p, this.file);
  }
  *readFileNameTemplate(options) {
    const { outputDelimiterLeft } = options;
    const htmlStopStrings = [",", " ", outputDelimiterLeft];
    const htmlStopStringSet = new Set(htmlStopStrings);
    while (this.p < this.N && !htmlStopStringSet.has(this.peek())) {
      yield this.match(outputDelimiterLeft) ? this.readOutputToken(options) : this.readHTMLToken(htmlStopStrings);
    }
  }
  match(word) {
    for (let i = 0; i < word.length; i++) {
      if (word[i] !== this.input[this.p + i])
        return false;
    }
    return true;
  }
  rmatch(pattern) {
    for (let i = 0; i < pattern.length; i++) {
      if (pattern[pattern.length - 1 - i] !== this.input[this.p - 1 - i])
        return false;
    }
    return true;
  }
  peekType(n = 0) {
    return this.p + n >= this.N ? 0 : TYPES[this.input.charCodeAt(this.p + n)];
  }
  peek(n = 0) {
    return this.p + n >= this.N ? "" : this.input[this.p + n];
  }
  skipBlank() {
    while (this.peekType() & BLANK)
      ++this.p;
  }
}
class ParseStream {
  constructor(tokens, parseToken) {
    this.handlers = {};
    this.stopRequested = false;
    this.tokens = tokens;
    this.parseToken = parseToken;
  }
  on(name, cb) {
    this.handlers[name] = cb;
    return this;
  }
  trigger(event, arg) {
    const h = this.handlers[event];
    return h ? (h.call(this, arg), true) : false;
  }
  start() {
    this.trigger("start");
    let token;
    while (!this.stopRequested && (token = this.tokens.shift())) {
      if (this.trigger("token", token))
        continue;
      if (isTagToken(token) && this.trigger(`tag:${token.name}`, token)) {
        continue;
      }
      const template2 = this.parseToken(token, this.tokens);
      this.trigger("template", template2);
    }
    if (!this.stopRequested)
      this.trigger("end");
    return this;
  }
  stop() {
    this.stopRequested = true;
    return this;
  }
}
class TemplateImpl {
  constructor(token) {
    this.token = token;
  }
}
class Tag extends TemplateImpl {
  constructor(token, remainTokens, liquid) {
    super(token);
    this.name = token.name;
    this.liquid = liquid;
    this.tokenizer = token.tokenizer;
  }
}
class Hash {
  constructor(input, jekyllStyle) {
    this.hash = {};
    const tokenizer = input instanceof Tokenizer ? input : new Tokenizer(input, {});
    for (const hash of tokenizer.readHashes(jekyllStyle)) {
      this.hash[hash.name.content] = hash.value;
    }
  }
  *render(ctx) {
    const hash = {};
    for (const key of Object.keys(this.hash)) {
      hash[key] = this.hash[key] === void 0 ? true : yield evalToken(this.hash[key], ctx);
    }
    return hash;
  }
}
function createTagClass(options) {
  return class extends Tag {
    constructor(token, tokens, liquid) {
      super(token, tokens, liquid);
      if (isFunction(options.parse)) {
        options.parse.call(this, token, tokens);
      }
    }
    *render(ctx, emitter) {
      const hash = yield new Hash(this.token.args, ctx.opts.keyValueSeparator).render(ctx);
      return yield options.render.call(this, ctx, emitter, hash);
    }
  };
}
function isKeyValuePair(arr) {
  return isArray(arr);
}
class Filter {
  constructor(token, options, liquid) {
    this.token = token;
    this.name = token.name;
    this.handler = isFunction(options) ? options : isFunction(options === null || options === void 0 ? void 0 : options.handler) ? options.handler : identify;
    this.raw = !isFunction(options) && !!(options === null || options === void 0 ? void 0 : options.raw);
    this.args = token.args;
    this.liquid = liquid;
  }
  *render(value, context) {
    const argv = [];
    for (const arg of this.args) {
      if (isKeyValuePair(arg))
        argv.push([arg[0], yield evalToken(arg[1], context)]);
      else
        argv.push(yield evalToken(arg, context));
    }
    return yield this.handler.apply({ context, token: this.token, liquid: this.liquid }, [value, ...argv]);
  }
}
class Value {
  /**
   * @param str the value to be valuated, eg.: "foobar" | truncate: 3
   */
  constructor(input, liquid) {
    this.filters = [];
    const token = typeof input === "string" ? new Tokenizer(input, liquid.options.operators).readFilteredValue() : input;
    this.initial = token.initial;
    this.filters = token.filters.map((token2) => new Filter(token2, this.getFilter(liquid, token2.name), liquid));
  }
  *value(ctx, lenient) {
    lenient = lenient || ctx.opts.lenientIf && this.filters.length > 0 && this.filters[0].name === "default";
    let val = yield this.initial.evaluate(ctx, lenient);
    for (const filter2 of this.filters) {
      val = yield filter2.render(val, ctx);
    }
    return val;
  }
  getFilter(liquid, name) {
    const impl = liquid.filters[name];
    assert(impl || !liquid.options.strictFilters, () => `undefined filter: ${name}`);
    return impl;
  }
}
class Output extends TemplateImpl {
  constructor(token, liquid) {
    var _a;
    super(token);
    const tokenizer = new Tokenizer(token.input, liquid.options.operators, token.file, token.contentRange);
    this.value = new Value(tokenizer.readFilteredValue(), liquid);
    const filters2 = this.value.filters;
    const outputEscape = liquid.options.outputEscape;
    if (!((_a = filters2[filters2.length - 1]) === null || _a === void 0 ? void 0 : _a.raw) && outputEscape) {
      const token2 = new FilterToken(toString.call(outputEscape), [], "", 0, 0);
      filters2.push(new Filter(token2, outputEscape, liquid));
    }
  }
  *render(ctx, emitter) {
    const val = yield this.value.value(ctx, false);
    emitter.write(val);
  }
  *arguments() {
    yield this.value;
  }
}
class HTML extends TemplateImpl {
  constructor(token) {
    super(token);
    this.str = token.getContent();
  }
  *render(ctx, emitter) {
    emitter.write(this.str);
  }
}
class Variable {
  constructor(segments, location) {
    this.segments = segments;
    this.location = location;
  }
  toString() {
    return segmentsString(this.segments, true);
  }
  /** Return this variable's segments as an array, possibly with nested arrays for nested paths. */
  toArray() {
    function* _visit(...segments) {
      for (const segment of segments) {
        if (segment instanceof Variable) {
          yield Array.from(_visit(...segment.segments));
        } else {
          yield segment;
        }
      }
    }
    return Array.from(_visit(...this.segments));
  }
}
class VariableMap {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  get(key) {
    const k = segmentsString([key.segments[0]]);
    if (!this.map.has(k)) {
      this.map.set(k, []);
    }
    return this.map.get(k);
  }
  has(key) {
    return this.map.has(segmentsString([key.segments[0]]));
  }
  push(variable) {
    this.get(variable).push(variable);
  }
  asObject() {
    return Object.fromEntries(this.map);
  }
}
const defaultStaticAnalysisOptions = {
  partials: true
};
function* _analyze(templates, partials, sync) {
  const variables = new VariableMap();
  const globals = new VariableMap();
  const locals = new VariableMap();
  const rootScope = new DummyScope(/* @__PURE__ */ new Set());
  const seen = /* @__PURE__ */ new Set();
  function updateVariables(variable, scope) {
    variables.push(variable);
    const aliased = scope.alias(variable);
    if (aliased !== void 0) {
      const root = aliased.segments[0];
      if (isString(root) && !rootScope.has(root)) {
        globals.push(aliased);
      }
    } else {
      const root = variable.segments[0];
      if (isString(root) && !scope.has(root)) {
        globals.push(variable);
      }
    }
    for (const segment of variable.segments) {
      if (segment instanceof Variable) {
        updateVariables(segment, scope);
      }
    }
  }
  function* visit2(template2, scope) {
    if (template2.arguments) {
      for (const arg of template2.arguments()) {
        for (const variable of extractVariables(arg)) {
          updateVariables(variable, scope);
        }
      }
    }
    if (template2.localScope) {
      for (const ident of template2.localScope()) {
        scope.add(ident.content);
        scope.deleteAlias(ident.content);
        const [row, col] = ident.getPosition();
        locals.push(new Variable([ident.content], { row, col, file: ident.file }));
      }
    }
    if (template2.children) {
      if (template2.partialScope) {
        const partial = template2.partialScope();
        if (partial === void 0) {
          for (const child of yield template2.children(partials, sync)) {
            yield visit2(child, scope);
          }
          return;
        }
        if (seen.has(partial.name))
          return;
        const partialScopeNames = /* @__PURE__ */ new Set();
        const partialScope = partial.isolated ? new DummyScope(partialScopeNames) : scope.push(partialScopeNames);
        for (const name of partial.scope) {
          if (isString(name)) {
            partialScopeNames.add(name);
          } else {
            const [alias, argument] = name;
            partialScopeNames.add(alias);
            const variables2 = Array.from(extractVariables(argument));
            if (variables2.length) {
              partialScope.setAlias(alias, variables2[0].segments);
            }
          }
        }
        for (const child of yield template2.children(partials, sync)) {
          yield visit2(child, partialScope);
          seen.add(partial.name);
        }
        partialScope.pop();
      } else {
        if (template2.blockScope) {
          scope.push(new Set(template2.blockScope()));
        }
        for (const child of yield template2.children(partials, sync)) {
          yield visit2(child, scope);
        }
        if (template2.blockScope) {
          scope.pop();
        }
      }
    }
  }
  for (const template2 of templates) {
    yield visit2(template2, rootScope);
  }
  return {
    variables: variables.asObject(),
    globals: globals.asObject(),
    locals: locals.asObject()
  };
}
function analyze(template2, options = {}) {
  const opts = Object.assign(Object.assign({}, defaultStaticAnalysisOptions), options);
  return toPromise(_analyze(template2, opts.partials, false));
}
function analyzeSync(template2, options = {}) {
  const opts = Object.assign(Object.assign({}, defaultStaticAnalysisOptions), options);
  return toValueSync(_analyze(template2, opts.partials, true));
}
class DummyScope {
  constructor(globals) {
    this.stack = [{ names: globals, aliases: /* @__PURE__ */ new Map() }];
  }
  /** Return true if `name` is in scope.  */
  has(name) {
    for (const scope of this.stack) {
      if (scope.names.has(name)) {
        return true;
      }
    }
    return false;
  }
  push(scope) {
    this.stack.push({ names: scope, aliases: /* @__PURE__ */ new Map() });
    return this;
  }
  pop() {
    var _a;
    return (_a = this.stack.pop()) === null || _a === void 0 ? void 0 : _a.names;
  }
  // Add a name to the template scope.
  add(name) {
    this.stack[0].names.add(name);
  }
  /** Return the variable that `variable` aliases, or `variable` if it doesn't alias anything. */
  alias(variable) {
    const root = variable.segments[0];
    if (!isString(root))
      return void 0;
    const alias = this.getAlias(root);
    if (alias === void 0)
      return void 0;
    return new Variable([...alias, ...variable.segments.slice(1)], variable.location);
  }
  // TODO: `from` could be a path with multiple segments, like `include.x`.
  setAlias(from, to) {
    this.stack[this.stack.length - 1].aliases.set(from, to);
  }
  deleteAlias(name) {
    this.stack[this.stack.length - 1].aliases.delete(name);
  }
  getAlias(name) {
    for (const scope of this.stack) {
      if (scope.aliases.has(name)) {
        return scope.aliases.get(name);
      }
      if (scope.names.has(name)) {
        return void 0;
      }
    }
    return void 0;
  }
}
function* extractVariables(value) {
  if (isValueToken(value)) {
    yield* extractValueTokenVariables(value);
  } else if (value instanceof Value) {
    yield* extractFilteredValueVariables(value);
  }
}
function* extractFilteredValueVariables(value) {
  for (const token of value.initial.postfix) {
    if (isValueToken(token)) {
      yield* extractValueTokenVariables(token);
    }
  }
  for (const filter2 of value.filters) {
    for (const arg of filter2.args) {
      if (isKeyValuePair(arg) && arg[1]) {
        yield* extractValueTokenVariables(arg[1]);
      } else if (isValueToken(arg)) {
        yield* extractValueTokenVariables(arg);
      }
    }
  }
}
function* extractValueTokenVariables(token) {
  if (isRangeToken(token)) {
    yield* extractValueTokenVariables(token.lhs);
    yield* extractValueTokenVariables(token.rhs);
  } else if (isPropertyAccessToken(token)) {
    yield extractPropertyAccessVariable(token);
  }
}
function extractPropertyAccessVariable(token) {
  const segments = [];
  let file = token.file;
  const root = token.props[0];
  file = file || root.file;
  if (isQuotedToken(root) || isNumberToken(root) || isWordToken(root)) {
    segments.push(root.content);
  } else if (isPropertyAccessToken(root)) {
    segments.push(...extractPropertyAccessVariable(root).segments);
  }
  for (const prop of token.props.slice(1)) {
    file = file || prop.file;
    if (isQuotedToken(prop) || isNumberToken(prop) || isWordToken(prop)) {
      segments.push(prop.content);
    } else if (isPropertyAccessToken(prop)) {
      segments.push(extractPropertyAccessVariable(prop));
    }
  }
  const [row, col] = token.getPosition();
  return new Variable(segments, {
    row,
    col,
    file
  });
}
const RE_PROPERTY = /^[\u0080-\uFFFFa-zA-Z_][\u0080-\uFFFFa-zA-Z0-9_-]*$/;
function segmentsString(segments, bracketedRoot = false) {
  const buf = [];
  const root = segments[0];
  if (isString(root)) {
    if (!bracketedRoot || root.match(RE_PROPERTY)) {
      buf.push(`${root}`);
    } else {
      buf.push(`['${root}']`);
    }
  }
  for (const segment of segments.slice(1)) {
    if (segment instanceof Variable) {
      buf.push(`[${segmentsString(segment.segments)}]`);
    } else if (isString(segment)) {
      if (segment.match(RE_PROPERTY)) {
        buf.push(`.${segment}`);
      } else {
        buf.push(`['${segment}']`);
      }
    } else {
      buf.push(`[${segment}]`);
    }
  }
  return buf.join("");
}
var LookupType;
(function(LookupType2) {
  LookupType2["Partials"] = "partials";
  LookupType2["Layouts"] = "layouts";
  LookupType2["Root"] = "root";
})(LookupType || (LookupType = {}));
class Loader {
  constructor(options) {
    this.options = options;
    if (options.relativeReference) {
      const sep2 = options.fs.sep;
      assert(sep2, "`fs.sep` is required for relative reference");
      const rRelativePath = new RegExp(["." + sep2, ".." + sep2, "./", "../"].map((prefix) => escapeRegex(prefix)).join("|"));
      this.shouldLoadRelative = (referencedFile) => rRelativePath.test(referencedFile);
    } else {
      this.shouldLoadRelative = (_referencedFile) => false;
    }
    this.contains = this.options.fs.contains || (() => true);
  }
  *lookup(file, type, sync, currentFile) {
    const { fs: fs2 } = this.options;
    const dirs = this.options[type];
    for (const filepath of this.candidates(file, dirs, currentFile, type !== LookupType.Root)) {
      if (sync ? fs2.existsSync(filepath) : yield fs2.exists(filepath))
        return filepath;
    }
    throw this.lookupError(file, dirs);
  }
  *candidates(file, dirs, currentFile, enforceRoot) {
    const { fs: fs2, extname } = this.options;
    if (this.shouldLoadRelative(file) && currentFile) {
      const referenced = fs2.resolve(this.dirname(currentFile), file, extname);
      for (const dir of dirs) {
        if (!enforceRoot || this.contains(dir, referenced)) {
          yield referenced;
          break;
        }
      }
    }
    for (const dir of dirs) {
      const referenced = fs2.resolve(dir, file, extname);
      if (!enforceRoot || this.contains(dir, referenced)) {
        yield referenced;
      }
    }
    if (fs2.fallback !== void 0) {
      const filepath = fs2.fallback(file);
      if (filepath !== void 0)
        yield filepath;
    }
  }
  dirname(path) {
    const fs2 = this.options.fs;
    assert(fs2.dirname, "`fs.dirname` is required for relative reference");
    return fs2.dirname(path);
  }
  lookupError(file, roots) {
    const err = new Error("ENOENT");
    err.message = `ENOENT: Failed to lookup "${file}" in "${roots}"`;
    err.code = "ENOENT";
    return err;
  }
}
class Parser3 {
  constructor(liquid) {
    this.liquid = liquid;
    this.cache = this.liquid.options.cache;
    this.fs = this.liquid.options.fs;
    this.parseFile = this.cache ? this._parseFileCached : this._parseFile;
    this.loader = new Loader(this.liquid.options);
    this.parseLimit = new Limiter("parse length", liquid.options.parseLimit);
  }
  parse(html, filepath) {
    html = String(html);
    this.parseLimit.use(html.length);
    const tokenizer = new Tokenizer(html, this.liquid.options.operators, filepath);
    const tokens = tokenizer.readTopLevelTokens(this.liquid.options);
    return this.parseTokens(tokens);
  }
  parseTokens(tokens) {
    let token;
    const templates = [];
    const errors = [];
    while (token = tokens.shift()) {
      try {
        templates.push(this.parseToken(token, tokens));
      } catch (err) {
        if (this.liquid.options.catchAllErrors)
          errors.push(err);
        else
          throw err;
      }
    }
    if (errors.length)
      throw new LiquidErrors(errors);
    return templates;
  }
  parseToken(token, remainTokens) {
    try {
      if (isTagToken(token)) {
        const TagClass = this.liquid.tags[token.name];
        assert(TagClass, `tag "${token.name}" not found`);
        return new TagClass(token, remainTokens, this.liquid, this);
      }
      if (isOutputToken(token)) {
        return new Output(token, this.liquid);
      }
      return new HTML(token);
    } catch (e) {
      if (LiquidError.is(e))
        throw e;
      throw new ParseError(e, token);
    }
  }
  parseStream(tokens) {
    return new ParseStream(tokens, (token, tokens2) => this.parseToken(token, tokens2));
  }
  *_parseFileCached(file, sync, type = LookupType.Root, currentFile) {
    const cache2 = this.cache;
    const key = this.loader.shouldLoadRelative(file) ? currentFile + "," + file : type + ":" + file;
    const tpls = yield cache2.read(key);
    if (tpls)
      return tpls;
    const task = this._parseFile(file, sync, type, currentFile);
    const taskOrTpl = sync ? yield task : toPromise(task);
    cache2.write(key, taskOrTpl);
    try {
      return yield taskOrTpl;
    } catch (err) {
      cache2.remove(key);
      throw err;
    }
  }
  *_parseFile(file, sync, type = LookupType.Root, currentFile) {
    const filepath = yield this.loader.lookup(file, type, sync, currentFile);
    return this.parse(sync ? this.fs.readFileSync(filepath) : yield this.fs.readFile(filepath), filepath);
  }
}
var TokenKind;
(function(TokenKind2) {
  TokenKind2[TokenKind2["Number"] = 1] = "Number";
  TokenKind2[TokenKind2["Literal"] = 2] = "Literal";
  TokenKind2[TokenKind2["Tag"] = 4] = "Tag";
  TokenKind2[TokenKind2["Output"] = 8] = "Output";
  TokenKind2[TokenKind2["HTML"] = 16] = "HTML";
  TokenKind2[TokenKind2["Filter"] = 32] = "Filter";
  TokenKind2[TokenKind2["Hash"] = 64] = "Hash";
  TokenKind2[TokenKind2["PropertyAccess"] = 128] = "PropertyAccess";
  TokenKind2[TokenKind2["Word"] = 256] = "Word";
  TokenKind2[TokenKind2["Range"] = 512] = "Range";
  TokenKind2[TokenKind2["Quoted"] = 1024] = "Quoted";
  TokenKind2[TokenKind2["Operator"] = 2048] = "Operator";
  TokenKind2[TokenKind2["FilteredValue"] = 4096] = "FilteredValue";
  TokenKind2[TokenKind2["Delimited"] = 12] = "Delimited";
})(TokenKind || (TokenKind = {}));
function isDelimitedToken(val) {
  return !!(getKind(val) & TokenKind.Delimited);
}
function isOperatorToken(val) {
  return getKind(val) === TokenKind.Operator;
}
function isHTMLToken(val) {
  return getKind(val) === TokenKind.HTML;
}
function isOutputToken(val) {
  return getKind(val) === TokenKind.Output;
}
function isTagToken(val) {
  return getKind(val) === TokenKind.Tag;
}
function isQuotedToken(val) {
  return getKind(val) === TokenKind.Quoted;
}
function isNumberToken(val) {
  return getKind(val) === TokenKind.Number;
}
function isPropertyAccessToken(val) {
  return getKind(val) === TokenKind.PropertyAccess;
}
function isWordToken(val) {
  return getKind(val) === TokenKind.Word;
}
function isRangeToken(val) {
  return getKind(val) === TokenKind.Range;
}
function isValueToken(val) {
  return (getKind(val) & 1667) > 0;
}
function getKind(val) {
  return val ? val.kind : -1;
}
class Context {
  constructor(env = {}, opts = defaultOptions, renderOptions = {}, { memoryLimit, renderLimit } = {}) {
    var _a, _b, _c, _d, _e;
    this.scopes = [{}];
    this.registers = {};
    this.breakCalled = false;
    this.continueCalled = false;
    this.sync = !!renderOptions.sync;
    this.opts = opts;
    this.globals = (_a = renderOptions.globals) !== null && _a !== void 0 ? _a : opts.globals;
    this.environments = isObject$1(env) ? env : Object(env);
    this.strictVariables = (_b = renderOptions.strictVariables) !== null && _b !== void 0 ? _b : this.opts.strictVariables;
    this.ownPropertyOnly = (_c = renderOptions.ownPropertyOnly) !== null && _c !== void 0 ? _c : opts.ownPropertyOnly;
    this.memoryLimit = memoryLimit !== null && memoryLimit !== void 0 ? memoryLimit : new Limiter("memory alloc", (_d = renderOptions.memoryLimit) !== null && _d !== void 0 ? _d : opts.memoryLimit);
    this.renderLimit = renderLimit !== null && renderLimit !== void 0 ? renderLimit : new Limiter("template render", getPerformance().now() + ((_e = renderOptions.renderLimit) !== null && _e !== void 0 ? _e : opts.renderLimit));
  }
  getRegister(key) {
    return this.registers[key] = this.registers[key] || {};
  }
  setRegister(key, value) {
    return this.registers[key] = value;
  }
  saveRegister(...keys) {
    return keys.map((key) => [key, this.getRegister(key)]);
  }
  restoreRegister(keyValues) {
    return keyValues.forEach(([key, value]) => this.setRegister(key, value));
  }
  getAll() {
    return [this.globals, this.environments, ...this.scopes].reduce((ctx, val) => __assign(ctx, val), {});
  }
  /**
   * @deprecated use `_get()` or `getSync()` instead
   */
  get(paths) {
    return this.getSync(paths);
  }
  getSync(paths) {
    return toValueSync(this._get(paths));
  }
  *_get(paths) {
    const scope = this.findScope(paths[0]);
    return yield this._getFromScope(scope, paths);
  }
  /**
   * @deprecated use `_get()` instead
   */
  getFromScope(scope, paths) {
    return toValueSync(this._getFromScope(scope, paths));
  }
  *_getFromScope(scope, paths, strictVariables = this.strictVariables) {
    if (isString(paths))
      paths = paths.split(".");
    for (let i = 0; i < paths.length; i++) {
      scope = yield this.readProperty(scope, paths[i]);
      if (strictVariables && isUndefined(scope)) {
        throw new InternalUndefinedVariableError(paths.slice(0, i + 1).join("."));
      }
    }
    return scope;
  }
  push(ctx) {
    return this.scopes.push(ctx);
  }
  pop() {
    return this.scopes.pop();
  }
  bottom() {
    return this.scopes[0];
  }
  spawn(scope = {}) {
    return new Context(scope, this.opts, {
      sync: this.sync,
      globals: this.globals,
      strictVariables: this.strictVariables
    }, {
      renderLimit: this.renderLimit,
      memoryLimit: this.memoryLimit
    });
  }
  findScope(key) {
    for (let i = this.scopes.length - 1; i >= 0; i--) {
      const candidate = this.scopes[i];
      if (key in candidate)
        return candidate;
    }
    if (key in this.environments)
      return this.environments;
    return this.globals;
  }
  readProperty(obj, key) {
    obj = toLiquid(obj);
    key = toValue(key);
    if (isNil(obj))
      return obj;
    if (isArray(obj) && key < 0)
      return obj[obj.length + +key];
    const value = readJSProperty(obj, key, this.ownPropertyOnly);
    if (value === void 0 && obj instanceof Drop)
      return obj.liquidMethodMissing(key, this);
    if (isFunction(value))
      return value.call(obj);
    if (key === "size")
      return readSize(obj);
    else if (key === "first")
      return readFirst(obj);
    else if (key === "last")
      return readLast(obj);
    return value;
  }
}
function readJSProperty(obj, key, ownPropertyOnly) {
  if (ownPropertyOnly && !hasOwnProperty.call(obj, key) && !(obj instanceof Drop))
    return void 0;
  return obj[key];
}
function readFirst(obj) {
  if (isArray(obj))
    return obj[0];
  return obj["first"];
}
function readLast(obj) {
  if (isArray(obj))
    return obj[obj.length - 1];
  return obj["last"];
}
function readSize(obj) {
  if (hasOwnProperty.call(obj, "size") || obj["size"] !== void 0)
    return obj["size"];
  if (isArray(obj) || isString(obj))
    return obj.length;
  if (typeof obj === "object")
    return Object.keys(obj).length;
}
var BlockMode;
(function(BlockMode2) {
  BlockMode2[BlockMode2["OUTPUT"] = 0] = "OUTPUT";
  BlockMode2[BlockMode2["STORE"] = 1] = "STORE";
})(BlockMode || (BlockMode = {}));
const abs = argumentsToNumber(Math.abs);
const at_least = argumentsToNumber(Math.max);
const at_most = argumentsToNumber(Math.min);
const ceil = argumentsToNumber(Math.ceil);
const divided_by = argumentsToNumber((dividend, divisor, integerArithmetic = false) => integerArithmetic ? Math.floor(dividend / divisor) : dividend / divisor);
const floor = argumentsToNumber(Math.floor);
const minus = argumentsToNumber((v, arg) => v - arg);
const plus = argumentsToNumber((lhs, rhs) => lhs + rhs);
const modulo = argumentsToNumber((v, arg) => v % arg);
const times = argumentsToNumber((v, arg) => v * arg);
function round(v, arg = 0) {
  v = toNumber(v);
  arg = toNumber(arg);
  const amp = Math.pow(10, arg);
  return Math.round(v * amp) / amp;
}
var mathFilters = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  abs,
  at_least,
  at_most,
  ceil,
  divided_by,
  floor,
  minus,
  plus,
  modulo,
  times,
  round
});
const url_decode = (x) => decodeURIComponent(stringify(x)).replace(/\+/g, " ");
const url_encode = (x) => encodeURIComponent(stringify(x)).replace(/%20/g, "+");
const cgi_escape = (x) => encodeURIComponent(stringify(x)).replace(/%20/g, "+").replace(/[!'()*]/g, (c) => "%" + c.charCodeAt(0).toString(16).toUpperCase());
const uri_escape = (x) => encodeURI(stringify(x)).replace(/%5B/g, "[").replace(/%5D/g, "]");
const rSlugifyDefault = /[^\p{M}\p{L}\p{Nd}]+/ug;
const rSlugifyReplacers = {
  "raw": /\s+/g,
  "default": rSlugifyDefault,
  "pretty": /[^\p{M}\p{L}\p{Nd}._~!$&'()+,;=@]+/ug,
  "ascii": /[^A-Za-z0-9]+/g,
  "latin": rSlugifyDefault,
  "none": null
};
function slugify(str, mode = "default", cased = false) {
  str = stringify(str);
  const replacer = rSlugifyReplacers[mode];
  if (replacer) {
    if (mode === "latin")
      str = removeAccents(str);
    str = str.replace(replacer, "-").replace(/^-|-$/g, "");
  }
  return cased ? str : str.toLowerCase();
}
function removeAccents(str) {
  return str.replace(/[]/g, "a").replace(/[]/g, "ae").replace(/[]/g, "c").replace(/[]/g, "e").replace(/[]/g, "i").replace(/[]/g, "d").replace(/[]/g, "n").replace(/[]/g, "o").replace(/[]/g, "u").replace(/[]/g, "y").replace(/[]/g, "ss").replace(/[]/g, "oe").replace(/[]/g, "th").replace(/[]/g, "SS").replace(/[]/g, "OE").replace(/[]/g, "TH");
}
var urlFilters = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  url_decode,
  url_encode,
  cgi_escape,
  uri_escape,
  slugify
});
const join = argumentsToValue(function(v, arg) {
  const array = toArray(v);
  const sep2 = isNil(arg) ? " " : stringify(arg);
  const complexity = array.length * (1 + sep2.length);
  this.context.memoryLimit.use(complexity);
  return array.join(sep2);
});
const last$1 = argumentsToValue((v) => isArrayLike(v) ? last(v) : "");
const first = argumentsToValue((v) => isArrayLike(v) ? v[0] : "");
const reverse = argumentsToValue(function(v) {
  const array = toArray(v);
  this.context.memoryLimit.use(array.length);
  return [...array].reverse();
});
function* sort(arr, property) {
  const values = [];
  const array = toArray(arr);
  this.context.memoryLimit.use(array.length);
  for (const item of array) {
    values.push([
      item,
      property ? yield this.context._getFromScope(item, stringify(property).split("."), false) : item
    ]);
  }
  return values.sort((lhs, rhs) => {
    const lvalue = lhs[1];
    const rvalue = rhs[1];
    return lvalue < rvalue ? -1 : lvalue > rvalue ? 1 : 0;
  }).map((tuple) => tuple[0]);
}
function sort_natural(input, property) {
  const propertyString = stringify(property);
  const compare = property === void 0 ? caseInsensitiveCompare : (lhs, rhs) => caseInsensitiveCompare(lhs[propertyString], rhs[propertyString]);
  const array = toArray(input);
  this.context.memoryLimit.use(array.length);
  return [...array].sort(compare);
}
const size = (v) => v && v.length || 0;
function* map$1(arr, property) {
  const results = [];
  const array = toArray(arr);
  this.context.memoryLimit.use(array.length);
  for (const item of array) {
    results.push(yield this.context._getFromScope(item, stringify(property), false));
  }
  return results;
}
function* sum(arr, property) {
  let sum2 = 0;
  const array = toArray(arr);
  for (const item of array) {
    const data = Number(property ? yield this.context._getFromScope(item, stringify(property), false) : item);
    sum2 += Number.isNaN(data) ? 0 : data;
  }
  return sum2;
}
function compact(arr) {
  const array = toArray(arr);
  this.context.memoryLimit.use(array.length);
  return array.filter((x) => !isNil(toValue(x)));
}
function concat$1(v, arg = []) {
  const lhs = toArray(v);
  const rhs = toArray(arg);
  this.context.memoryLimit.use(lhs.length + rhs.length);
  return lhs.concat(rhs);
}
function push(v, arg) {
  return concat$1.call(this, v, [arg]);
}
function unshift(v, arg) {
  const array = toArray(v);
  this.context.memoryLimit.use(array.length);
  const clone = [...array];
  clone.unshift(arg);
  return clone;
}
function pop(v) {
  const clone = [...toArray(v)];
  clone.pop();
  return clone;
}
function shift(v) {
  const array = toArray(v);
  this.context.memoryLimit.use(array.length);
  const clone = [...array];
  clone.shift();
  return clone;
}
function slice(v, begin, length = 1) {
  v = toValue(v);
  if (isNil(v))
    return [];
  if (!isArray(v))
    v = stringify(v);
  begin = begin < 0 ? v.length + begin : begin;
  this.context.memoryLimit.use(length);
  return v.slice(begin, begin + length);
}
function expectedMatcher(expected) {
  if (this.context.opts.jekyllWhere) {
    return (v) => EmptyDrop.is(expected) ? equals(v, expected) : isArray(v) ? arrayIncludes(v, expected) : equals(v, expected);
  } else if (expected === void 0) {
    return (v) => isTruthy(v, this.context);
  } else {
    return (v) => equals(v, expected);
  }
}
function* filter(include, arr, property, expected) {
  const values = [];
  arr = toArray(arr);
  this.context.memoryLimit.use(arr.length);
  const token = new Tokenizer(stringify(property)).readScopeValue();
  for (const item of arr) {
    values.push(yield evalToken(token, this.context.spawn(item)));
  }
  const matcher = expectedMatcher.call(this, expected);
  return arr.filter((_, i) => matcher(values[i]) === include);
}
function* filter_exp(include, arr, itemName, exp) {
  const filtered = [];
  const keyTemplate = new Value(stringify(exp), this.liquid);
  const array = toArray(arr);
  this.context.memoryLimit.use(array.length);
  for (const item of array) {
    this.context.push({ [itemName]: item });
    const value = yield keyTemplate.value(this.context);
    this.context.pop();
    if (value === include)
      filtered.push(item);
  }
  return filtered;
}
function* where(arr, property, expected) {
  return yield* filter.call(this, true, arr, property, expected);
}
function* reject(arr, property, expected) {
  return yield* filter.call(this, false, arr, property, expected);
}
function* where_exp(arr, itemName, exp) {
  return yield* filter_exp.call(this, true, arr, itemName, exp);
}
function* reject_exp(arr, itemName, exp) {
  return yield* filter_exp.call(this, false, arr, itemName, exp);
}
function* group_by(arr, property) {
  const map2 = /* @__PURE__ */ new Map();
  arr = toEnumerable(arr);
  const token = new Tokenizer(stringify(property)).readScopeValue();
  this.context.memoryLimit.use(arr.length);
  for (const item of arr) {
    const key = yield evalToken(token, this.context.spawn(item));
    if (!map2.has(key))
      map2.set(key, []);
    map2.get(key).push(item);
  }
  return [...map2.entries()].map(([name, items]) => ({ name, items }));
}
function* group_by_exp(arr, itemName, exp) {
  const map2 = /* @__PURE__ */ new Map();
  const keyTemplate = new Value(stringify(exp), this.liquid);
  arr = toEnumerable(arr);
  this.context.memoryLimit.use(arr.length);
  for (const item of arr) {
    this.context.push({ [itemName]: item });
    const key = yield keyTemplate.value(this.context);
    this.context.pop();
    if (!map2.has(key))
      map2.set(key, []);
    map2.get(key).push(item);
  }
  return [...map2.entries()].map(([name, items]) => ({ name, items }));
}
function* search(arr, property, expected) {
  const token = new Tokenizer(stringify(property)).readScopeValue();
  const array = toArray(arr);
  const matcher = expectedMatcher.call(this, expected);
  for (let index = 0; index < array.length; index++) {
    const value = yield evalToken(token, this.context.spawn(array[index]));
    if (matcher(value))
      return [index, array[index]];
  }
}
function* search_exp(arr, itemName, exp) {
  const predicate = new Value(stringify(exp), this.liquid);
  const array = toArray(arr);
  for (let index = 0; index < array.length; index++) {
    this.context.push({ [itemName]: array[index] });
    const value = yield predicate.value(this.context);
    this.context.pop();
    if (value)
      return [index, array[index]];
  }
}
function* has(arr, property, expected) {
  const result = yield* search.call(this, arr, property, expected);
  return !!result;
}
function* has_exp(arr, itemName, exp) {
  const result = yield* search_exp.call(this, arr, itemName, exp);
  return !!result;
}
function* find_index(arr, property, expected) {
  const result = yield* search.call(this, arr, property, expected);
  return result ? result[0] : void 0;
}
function* find_index_exp(arr, itemName, exp) {
  const result = yield* search_exp.call(this, arr, itemName, exp);
  return result ? result[0] : void 0;
}
function* find(arr, property, expected) {
  const result = yield* search.call(this, arr, property, expected);
  return result ? result[1] : void 0;
}
function* find_exp(arr, itemName, exp) {
  const result = yield* search_exp.call(this, arr, itemName, exp);
  return result ? result[1] : void 0;
}
function uniq(arr) {
  arr = toArray(arr);
  this.context.memoryLimit.use(arr.length);
  return [...new Set(arr)];
}
function sample(v, count = 1) {
  v = toValue(v);
  if (isNil(v))
    return [];
  if (!isArray(v))
    v = stringify(v);
  this.context.memoryLimit.use(count);
  const shuffled = [...v].sort(() => Math.random() - 0.5);
  if (count === 1)
    return shuffled[0];
  return shuffled.slice(0, count);
}
var arrayFilters = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  join,
  last: last$1,
  first,
  reverse,
  sort,
  sort_natural,
  size,
  map: map$1,
  sum,
  compact,
  concat: concat$1,
  push,
  unshift,
  pop,
  shift,
  slice,
  where,
  reject,
  where_exp,
  reject_exp,
  group_by,
  group_by_exp,
  has,
  has_exp,
  find_index,
  find_index_exp,
  find,
  find_exp,
  uniq,
  sample
});
function date(v, format2, timezoneOffset) {
  var _a, _b, _c;
  const size2 = ((_a = v === null || v === void 0 ? void 0 : v.length) !== null && _a !== void 0 ? _a : 0) + ((_b = format2 === null || format2 === void 0 ? void 0 : format2.length) !== null && _b !== void 0 ? _b : 0) + ((_c = timezoneOffset === null || timezoneOffset === void 0 ? void 0 : timezoneOffset.length) !== null && _c !== void 0 ? _c : 0);
  this.context.memoryLimit.use(size2);
  const date2 = parseDate(v, this.context.opts, timezoneOffset);
  if (!date2)
    return v;
  format2 = toValue(format2);
  format2 = isNil(format2) ? this.context.opts.dateFormat : stringify(format2);
  return strftime(date2, format2);
}
function date_to_xmlschema(v) {
  return date.call(this, v, "%Y-%m-%dT%H:%M:%S%:z");
}
function date_to_rfc822(v) {
  return date.call(this, v, "%a, %d %b %Y %H:%M:%S %z");
}
function date_to_string(v, type, style) {
  return stringify_date.call(this, v, "%b", type, style);
}
function date_to_long_string(v, type, style) {
  return stringify_date.call(this, v, "%B", type, style);
}
function stringify_date(v, month_type, type, style) {
  const date2 = parseDate(v, this.context.opts);
  if (!date2)
    return v;
  if (type === "ordinal") {
    const d = date2.getDate();
    return style === "US" ? strftime(date2, `${month_type} ${d}%q, %Y`) : strftime(date2, `${d}%q ${month_type} %Y`);
  }
  return strftime(date2, `%d ${month_type} %Y`);
}
function parseDate(v, opts, timezoneOffset) {
  let date2;
  const defaultTimezoneOffset = timezoneOffset !== null && timezoneOffset !== void 0 ? timezoneOffset : opts.timezoneOffset;
  const locale = opts.locale;
  v = toValue(v);
  if (v === "now" || v === "today") {
    date2 = new LiquidDate(Date.now(), locale, defaultTimezoneOffset);
  } else if (isNumber(v)) {
    date2 = new LiquidDate(v * 1e3, locale, defaultTimezoneOffset);
  } else if (isString(v)) {
    if (/^\d+$/.test(v)) {
      date2 = new LiquidDate(+v * 1e3, locale, defaultTimezoneOffset);
    } else if (opts.preserveTimezones && timezoneOffset === void 0) {
      date2 = LiquidDate.createDateFixedToTimezone(v, locale);
    } else {
      date2 = new LiquidDate(v, locale, defaultTimezoneOffset);
    }
  } else {
    date2 = new LiquidDate(v, locale, defaultTimezoneOffset);
  }
  return date2.valid() ? date2 : void 0;
}
var dateFilters = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  date,
  date_to_xmlschema,
  date_to_rfc822,
  date_to_string,
  date_to_long_string
});
const rCJKWord = /[\u4E00-\u9FFF\uF900-\uFAFF\u3400-\u4DBF\u3040-\u309F\u30A0-\u30FF\uAC00-\uD7AF]/gu;
const rNonCJKWord = /[^\u4E00-\u9FFF\uF900-\uFAFF\u3400-\u4DBF\u3040-\u309F\u30A0-\u30FF\uAC00-\uD7AF\s]+/gu;
function append(v, arg) {
  assert(arguments.length === 2, "append expect 2 arguments");
  const lhs = stringify(v);
  const rhs = stringify(arg);
  this.context.memoryLimit.use(lhs.length + rhs.length);
  return lhs + rhs;
}
function prepend(v, arg) {
  assert(arguments.length === 2, "prepend expect 2 arguments");
  const lhs = stringify(v);
  const rhs = stringify(arg);
  this.context.memoryLimit.use(lhs.length + rhs.length);
  return rhs + lhs;
}
function lstrip(v, chars) {
  const str = stringify(v);
  this.context.memoryLimit.use(str.length);
  if (chars) {
    chars = escapeRegExp(stringify(chars));
    return str.replace(new RegExp(`^[${chars}]+`, "g"), "");
  }
  return str.replace(/^\s+/, "");
}
function downcase(v) {
  const str = stringify(v);
  this.context.memoryLimit.use(str.length);
  return str.toLowerCase();
}
function upcase(v) {
  const str = stringify(v);
  this.context.memoryLimit.use(str.length);
  return stringify(str).toUpperCase();
}
function remove(v, arg) {
  const str = stringify(v);
  this.context.memoryLimit.use(str.length);
  return str.split(stringify(arg)).join("");
}
function remove_first(v, l) {
  const str = stringify(v);
  this.context.memoryLimit.use(str.length);
  return str.replace(stringify(l), "");
}
function remove_last(v, l) {
  const str = stringify(v);
  this.context.memoryLimit.use(str.length);
  const pattern = stringify(l);
  const index = str.lastIndexOf(pattern);
  if (index === -1)
    return str;
  return str.substring(0, index) + str.substring(index + pattern.length);
}
function rstrip(str, chars) {
  str = stringify(str);
  this.context.memoryLimit.use(str.length);
  if (chars) {
    chars = escapeRegExp(stringify(chars));
    return str.replace(new RegExp(`[${chars}]+$`, "g"), "");
  }
  return str.replace(/\s+$/, "");
}
function split(v, arg) {
  const str = stringify(v);
  this.context.memoryLimit.use(str.length);
  const arr = str.split(stringify(arg));
  while (arr.length && arr[arr.length - 1] === "")
    arr.pop();
  return arr;
}
function strip(v, chars) {
  const str = stringify(v);
  this.context.memoryLimit.use(str.length);
  if (chars) {
    chars = escapeRegExp(stringify(chars));
    return str.replace(new RegExp(`^[${chars}]+`, "g"), "").replace(new RegExp(`[${chars}]+$`, "g"), "");
  }
  return str.trim();
}
function strip_newlines(v) {
  const str = stringify(v);
  this.context.memoryLimit.use(str.length);
  return str.replace(/\r?\n/gm, "");
}
function capitalize(str) {
  str = stringify(str);
  this.context.memoryLimit.use(str.length);
  return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
}
function replace(v, pattern, replacement) {
  const str = stringify(v);
  this.context.memoryLimit.use(str.length);
  return str.split(stringify(pattern)).join(replacement);
}
function replace_first(v, arg1, arg2) {
  const str = stringify(v);
  this.context.memoryLimit.use(str.length);
  return str.replace(stringify(arg1), arg2);
}
function replace_last(v, arg1, arg2) {
  const str = stringify(v);
  this.context.memoryLimit.use(str.length);
  const pattern = stringify(arg1);
  const index = str.lastIndexOf(pattern);
  if (index === -1)
    return str;
  const replacement = stringify(arg2);
  return str.substring(0, index) + replacement + str.substring(index + pattern.length);
}
function truncate(v, l = 50, o = "...") {
  const str = stringify(v);
  this.context.memoryLimit.use(str.length);
  if (str.length <= l)
    return v;
  return str.substring(0, l - o.length) + o;
}
function truncatewords(v, words = 15, o = "...") {
  const str = stringify(v);
  this.context.memoryLimit.use(str.length);
  const arr = str.split(/\s+/);
  if (words <= 0)
    words = 1;
  let ret = arr.slice(0, words).join(" ");
  if (arr.length >= words)
    ret += o;
  return ret;
}
function normalize_whitespace(v) {
  const str = stringify(v);
  this.context.memoryLimit.use(str.length);
  return str.replace(/\s+/g, " ");
}
function number_of_words(input, mode) {
  const str = stringify(input);
  this.context.memoryLimit.use(str.length);
  input = str.trim();
  if (!input)
    return 0;
  switch (mode) {
    case "cjk":
      return (input.match(rCJKWord) || []).length + (input.match(rNonCJKWord) || []).length;
    case "auto":
      return rCJKWord.test(input) ? input.match(rCJKWord).length + (input.match(rNonCJKWord) || []).length : input.split(/\s+/).length;
    default:
      return input.split(/\s+/).length;
  }
}
function array_to_sentence_string(array, connector = "and") {
  this.context.memoryLimit.use(array.length);
  switch (array.length) {
    case 0:
      return "";
    case 1:
      return array[0];
    case 2:
      return `${array[0]} ${connector} ${array[1]}`;
    default:
      return `${array.slice(0, -1).join(", ")}, ${connector} ${array[array.length - 1]}`;
  }
}
var stringFilters = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  append,
  prepend,
  lstrip,
  downcase,
  upcase,
  remove,
  remove_first,
  remove_last,
  rstrip,
  split,
  strip,
  strip_newlines,
  capitalize,
  replace,
  replace_first,
  replace_last,
  truncate,
  truncatewords,
  normalize_whitespace,
  number_of_words,
  array_to_sentence_string
});
function base64Encode(str) {
  return btoa(String.fromCharCode(...new TextEncoder().encode(str)));
}
function base64Decode(str) {
  return new TextDecoder().decode(Uint8Array.from(atob(str), (c) => c.charCodeAt(0)));
}
function base64_encode(value) {
  const str = stringify(value);
  this.context.memoryLimit.use(str.length);
  return base64Encode(str);
}
function base64_decode(value) {
  const str = stringify(value);
  this.context.memoryLimit.use(str.length);
  return base64Decode(str);
}
var base64Filters = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  base64_encode,
  base64_decode
});
const filters = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, htmlFilters), mathFilters), urlFilters), arrayFilters), dateFilters), stringFilters), base64Filters), misc);
class AssignTag extends Tag {
  constructor(token, remainTokens, liquid) {
    super(token, remainTokens, liquid);
    this.identifier = this.tokenizer.readIdentifier();
    this.key = this.identifier.content;
    this.tokenizer.assert(this.key, "expected variable name");
    this.tokenizer.skipBlank();
    this.tokenizer.assert(this.tokenizer.peek() === "=", 'expected "="');
    this.tokenizer.advance();
    this.value = new Value(this.tokenizer.readFilteredValue(), this.liquid);
  }
  *render(ctx) {
    ctx.bottom()[this.key] = yield this.value.value(ctx, this.liquid.options.lenientIf);
  }
  *arguments() {
    yield this.value;
  }
  *localScope() {
    yield this.identifier;
  }
}
const MODIFIERS = ["offset", "limit", "reversed"];
class ForTag extends Tag {
  constructor(token, remainTokens, liquid, parser) {
    super(token, remainTokens, liquid);
    const variable = this.tokenizer.readIdentifier();
    const inStr = this.tokenizer.readIdentifier();
    const collection = this.tokenizer.readValue();
    if (!variable.size() || inStr.content !== "in" || !collection) {
      throw new Error(`illegal tag: ${token.getText()}`);
    }
    this.variable = variable.content;
    this.collection = collection;
    this.hash = new Hash(this.tokenizer, liquid.options.keyValueSeparator);
    this.templates = [];
    this.elseTemplates = [];
    let p;
    const stream = parser.parseStream(remainTokens).on("start", () => p = this.templates).on("tag:else", (tag2) => {
      assertEmpty(tag2.args);
      p = this.elseTemplates;
    }).on("tag:endfor", (tag2) => {
      assertEmpty(tag2.args);
      stream.stop();
    }).on("template", (tpl) => p.push(tpl)).on("end", () => {
      throw new Error(`tag ${token.getText()} not closed`);
    });
    stream.start();
  }
  *render(ctx, emitter) {
    const r = this.liquid.renderer;
    let collection = toEnumerable(yield evalToken(this.collection, ctx));
    if (!collection.length) {
      yield r.renderTemplates(this.elseTemplates, ctx, emitter);
      return;
    }
    const continueKey = "continue-" + this.variable + "-" + this.collection.getText();
    ctx.push({ continue: ctx.getRegister(continueKey) });
    const hash = yield this.hash.render(ctx);
    ctx.pop();
    const modifiers = this.liquid.options.orderedFilterParameters ? Object.keys(hash).filter((x) => MODIFIERS.includes(x)) : MODIFIERS.filter((x) => hash[x] !== void 0);
    collection = modifiers.reduce((collection2, modifier) => {
      if (modifier === "offset")
        return offset(collection2, hash["offset"]);
      if (modifier === "limit")
        return limit(collection2, hash["limit"]);
      return reversed(collection2);
    }, collection);
    ctx.setRegister(continueKey, (hash["offset"] || 0) + collection.length);
    const scope = { forloop: new ForloopDrop(collection.length, this.collection.getText(), this.variable) };
    ctx.push(scope);
    for (const item of collection) {
      scope[this.variable] = item;
      ctx.continueCalled = ctx.breakCalled = false;
      yield r.renderTemplates(this.templates, ctx, emitter);
      if (ctx.breakCalled)
        break;
      scope.forloop.next();
    }
    ctx.continueCalled = ctx.breakCalled = false;
    ctx.pop();
  }
  *children() {
    const templates = this.templates.slice();
    if (this.elseTemplates) {
      templates.push(...this.elseTemplates);
    }
    return templates;
  }
  *arguments() {
    yield this.collection;
    for (const v of Object.values(this.hash.hash)) {
      if (isValueToken(v)) {
        yield v;
      }
    }
  }
  blockScope() {
    return [this.variable, "forloop"];
  }
}
function reversed(arr) {
  return [...arr].reverse();
}
function offset(arr, count) {
  return arr.slice(count);
}
function limit(arr, count) {
  return arr.slice(0, count);
}
class CaptureTag extends Tag {
  constructor(tagToken, remainTokens, liquid, parser) {
    super(tagToken, remainTokens, liquid);
    this.templates = [];
    this.identifier = this.readVariable();
    this.variable = this.identifier.content;
    while (remainTokens.length) {
      const token = remainTokens.shift();
      if (isTagToken(token) && token.name === "endcapture")
        return;
      this.templates.push(parser.parseToken(token, remainTokens));
    }
    throw new Error(`tag ${tagToken.getText()} not closed`);
  }
  readVariable() {
    let ident = this.tokenizer.readIdentifier();
    if (ident.content)
      return ident;
    ident = this.tokenizer.readQuoted();
    if (ident)
      return ident;
    throw this.tokenizer.error("invalid capture name");
  }
  *render(ctx) {
    const r = this.liquid.renderer;
    const html = yield r.renderTemplates(this.templates, ctx);
    ctx.bottom()[this.variable] = html;
  }
  *children() {
    return this.templates;
  }
  *localScope() {
    yield this.identifier;
  }
}
class CaseTag extends Tag {
  constructor(tagToken, remainTokens, liquid, parser) {
    super(tagToken, remainTokens, liquid);
    this.branches = [];
    this.elseTemplates = [];
    this.value = new Value(this.tokenizer.readFilteredValue(), this.liquid);
    this.elseTemplates = [];
    let p = [];
    let elseCount = 0;
    const stream = parser.parseStream(remainTokens).on("tag:when", (token) => {
      if (elseCount > 0) {
        return;
      }
      p = [];
      const values = [];
      while (!token.tokenizer.end()) {
        values.push(token.tokenizer.readValueOrThrow());
        token.tokenizer.skipBlank();
        if (token.tokenizer.peek() === ",") {
          token.tokenizer.readTo(",");
        } else {
          token.tokenizer.readTo("or");
        }
      }
      this.branches.push({
        values,
        templates: p
      });
    }).on("tag:else", () => {
      elseCount++;
      p = this.elseTemplates;
    }).on("tag:endcase", () => stream.stop()).on("template", (tpl) => {
      if (p !== this.elseTemplates || elseCount === 1) {
        p.push(tpl);
      }
    }).on("end", () => {
      throw new Error(`tag ${tagToken.getText()} not closed`);
    });
    stream.start();
  }
  *render(ctx, emitter) {
    const r = this.liquid.renderer;
    const target = toValue(yield this.value.value(ctx, ctx.opts.lenientIf));
    let branchHit = false;
    for (const branch2 of this.branches) {
      for (const valueToken of branch2.values) {
        const value = yield evalToken(valueToken, ctx, ctx.opts.lenientIf);
        if (equals(target, value)) {
          yield r.renderTemplates(branch2.templates, ctx, emitter);
          branchHit = true;
          break;
        }
      }
    }
    if (!branchHit) {
      yield r.renderTemplates(this.elseTemplates, ctx, emitter);
    }
  }
  *arguments() {
    yield this.value;
    yield* this.branches.flatMap((b) => b.values);
  }
  *children() {
    const templates = this.branches.flatMap((b) => b.templates);
    if (this.elseTemplates) {
      templates.push(...this.elseTemplates);
    }
    return templates;
  }
}
class CommentTag extends Tag {
  constructor(tagToken, remainTokens, liquid) {
    super(tagToken, remainTokens, liquid);
    while (remainTokens.length) {
      const token = remainTokens.shift();
      if (isTagToken(token) && token.name === "endcomment")
        return;
    }
    throw new Error(`tag ${tagToken.getText()} not closed`);
  }
  render() {
  }
}
class RenderTag extends Tag {
  constructor(token, remainTokens, liquid, parser) {
    super(token, remainTokens, liquid);
    const tokenizer = this.tokenizer;
    this.file = parseFilePath(tokenizer, this.liquid, parser);
    this.currentFile = token.file;
    while (!tokenizer.end()) {
      tokenizer.skipBlank();
      const begin = tokenizer.p;
      const keyword = tokenizer.readIdentifier();
      if (keyword.content === "with" || keyword.content === "for") {
        tokenizer.skipBlank();
        if (tokenizer.peek() !== ":") {
          const value = tokenizer.readValue();
          if (value) {
            const beforeAs = tokenizer.p;
            const asStr = tokenizer.readIdentifier();
            let alias;
            if (asStr.content === "as")
              alias = tokenizer.readIdentifier();
            else
              tokenizer.p = beforeAs;
            this[keyword.content] = { value, alias: alias && alias.content };
            tokenizer.skipBlank();
            if (tokenizer.peek() === ",")
              tokenizer.advance();
            continue;
          }
        }
      }
      tokenizer.p = begin;
      break;
    }
    this.hash = new Hash(tokenizer, liquid.options.keyValueSeparator);
  }
  *render(ctx, emitter) {
    const { liquid, hash } = this;
    const filepath = yield renderFilePath(this["file"], ctx, liquid);
    assert(filepath, () => `illegal file path "${filepath}"`);
    const childCtx = ctx.spawn();
    const scope = childCtx.bottom();
    __assign(scope, yield hash.render(ctx));
    if (this["with"]) {
      const { value, alias } = this["with"];
      scope[alias || filepath] = yield evalToken(value, ctx);
    }
    if (this["for"]) {
      const { value, alias } = this["for"];
      const collection = toEnumerable(yield evalToken(value, ctx));
      scope["forloop"] = new ForloopDrop(collection.length, value.getText(), alias);
      for (const item of collection) {
        scope[alias] = item;
        const templates = yield liquid._parsePartialFile(filepath, childCtx.sync, this["currentFile"]);
        yield liquid.renderer.renderTemplates(templates, childCtx, emitter);
        scope["forloop"].next();
      }
    } else {
      const templates = yield liquid._parsePartialFile(filepath, childCtx.sync, this["currentFile"]);
      yield liquid.renderer.renderTemplates(templates, childCtx, emitter);
    }
  }
  *children(partials, sync) {
    if (partials && isString(this["file"])) {
      return yield this.liquid._parsePartialFile(this["file"], sync, this["currentFile"]);
    }
    return [];
  }
  partialScope() {
    if (isString(this["file"])) {
      const names = Object.keys(this.hash.hash);
      if (this["with"]) {
        const { value, alias } = this["with"];
        if (isString(alias)) {
          names.push([alias, value]);
        } else if (isString(this.file)) {
          names.push([this.file, value]);
        }
      }
      if (this["for"]) {
        const { value, alias } = this["for"];
        if (isString(alias)) {
          names.push([alias, value]);
        } else if (isString(this.file)) {
          names.push([this.file, value]);
        }
      }
      return { name: this["file"], isolated: true, scope: names };
    }
  }
  *arguments() {
    for (const v of Object.values(this.hash.hash)) {
      if (isValueToken(v)) {
        yield v;
      }
    }
    if (this["with"]) {
      const { value } = this["with"];
      if (isValueToken(value)) {
        yield value;
      }
    }
    if (this["for"]) {
      const { value } = this["for"];
      if (isValueToken(value)) {
        yield value;
      }
    }
  }
}
function parseFilePath(tokenizer, liquid, parser) {
  if (liquid.options.dynamicPartials) {
    const file = tokenizer.readValue();
    tokenizer.assert(file, "illegal file path");
    if (file.getText() === "none")
      return;
    if (isQuotedToken(file)) {
      const templates2 = parser.parse(evalQuotedToken(file));
      return optimize(templates2);
    }
    return file;
  }
  const tokens = [...tokenizer.readFileNameTemplate(liquid.options)];
  const templates = optimize(parser.parseTokens(tokens));
  return templates === "none" ? void 0 : templates;
}
function optimize(templates) {
  if (templates.length === 1 && isHTMLToken(templates[0].token))
    return templates[0].token.getContent();
  return templates;
}
function* renderFilePath(file, ctx, liquid) {
  if (typeof file === "string")
    return file;
  if (Array.isArray(file))
    return liquid.renderer.renderTemplates(file, ctx);
  return yield evalToken(file, ctx);
}
class IncludeTag extends Tag {
  constructor(token, remainTokens, liquid, parser) {
    super(token, remainTokens, liquid);
    const { tokenizer } = token;
    this["file"] = parseFilePath(tokenizer, this.liquid, parser);
    this["currentFile"] = token.file;
    const begin = tokenizer.p;
    const withStr = tokenizer.readIdentifier();
    if (withStr.content === "with") {
      tokenizer.skipBlank();
      if (tokenizer.peek() !== ":") {
        this.withVar = tokenizer.readValue();
      } else
        tokenizer.p = begin;
    } else
      tokenizer.p = begin;
    this.hash = new Hash(tokenizer, liquid.options.jekyllInclude || liquid.options.keyValueSeparator);
  }
  *render(ctx, emitter) {
    const { liquid, hash, withVar } = this;
    const { renderer } = liquid;
    const filepath = yield renderFilePath(this["file"], ctx, liquid);
    assert(filepath, () => `illegal file path "${filepath}"`);
    const saved = ctx.saveRegister("blocks", "blockMode");
    ctx.setRegister("blocks", {});
    ctx.setRegister("blockMode", BlockMode.OUTPUT);
    const scope = yield hash.render(ctx);
    if (withVar)
      scope[filepath] = yield evalToken(withVar, ctx);
    const templates = yield liquid._parsePartialFile(filepath, ctx.sync, this["currentFile"]);
    ctx.push(ctx.opts.jekyllInclude ? { include: scope } : scope);
    yield renderer.renderTemplates(templates, ctx, emitter);
    ctx.pop();
    ctx.restoreRegister(saved);
  }
  *children(partials, sync) {
    if (partials && isString(this["file"])) {
      return yield this.liquid._parsePartialFile(this["file"], sync, this["currentFile"]);
    }
    return [];
  }
  partialScope() {
    if (isString(this["file"])) {
      let names;
      if (this.liquid.options.jekyllInclude) {
        names = ["include"];
      } else {
        names = Object.keys(this.hash.hash);
        if (this.withVar) {
          names.push([this["file"], this.withVar]);
        }
      }
      return { name: this["file"], isolated: false, scope: names };
    }
  }
  *arguments() {
    yield* Object.values(this.hash.hash).filter(isValueToken);
    if (isValueToken(this["file"])) {
      yield this["file"];
    }
    if (isValueToken(this.withVar)) {
      yield this.withVar;
    }
  }
}
class DecrementTag extends Tag {
  constructor(token, remainTokens, liquid) {
    super(token, remainTokens, liquid);
    this.identifier = this.tokenizer.readIdentifier();
    this.variable = this.identifier.content;
  }
  render(context, emitter) {
    const scope = context.environments;
    if (!isNumber(scope[this.variable])) {
      scope[this.variable] = 0;
    }
    emitter.write(stringify(--scope[this.variable]));
  }
  *localScope() {
    yield this.identifier;
  }
}
class CycleTag extends Tag {
  constructor(token, remainTokens, liquid) {
    super(token, remainTokens, liquid);
    this.candidates = [];
    const group = this.tokenizer.readValue();
    this.tokenizer.skipBlank();
    if (group) {
      if (this.tokenizer.peek() === ":") {
        this.group = group;
        this.tokenizer.advance();
      } else
        this.candidates.push(group);
    }
    while (!this.tokenizer.end()) {
      const value = this.tokenizer.readValue();
      if (value)
        this.candidates.push(value);
      this.tokenizer.readTo(",");
    }
    this.tokenizer.assert(this.candidates.length, () => `empty candidates: "${token.getText()}"`);
  }
  *render(ctx, emitter) {
    const group = yield evalToken(this.group, ctx);
    const fingerprint = `cycle:${group}:` + this.candidates.join(",");
    const groups = ctx.getRegister("cycle");
    let idx = groups[fingerprint];
    if (idx === void 0) {
      idx = groups[fingerprint] = 0;
    }
    const candidate = this.candidates[idx];
    idx = (idx + 1) % this.candidates.length;
    groups[fingerprint] = idx;
    return yield evalToken(candidate, ctx);
  }
  *arguments() {
    yield* this.candidates;
    if (this.group) {
      yield this.group;
    }
  }
}
class IfTag extends Tag {
  constructor(tagToken, remainTokens, liquid, parser) {
    super(tagToken, remainTokens, liquid);
    this.branches = [];
    let p = [];
    parser.parseStream(remainTokens).on("start", () => this.branches.push({
      value: new Value(tagToken.tokenizer.readFilteredValue(), this.liquid),
      templates: p = []
    })).on("tag:elsif", (token) => {
      assert(!this.elseTemplates, "unexpected elsif after else");
      this.branches.push({
        value: new Value(token.tokenizer.readFilteredValue(), this.liquid),
        templates: p = []
      });
    }).on("tag:else", (tag2) => {
      assertEmpty(tag2.args);
      assert(!this.elseTemplates, "duplicated else");
      p = this.elseTemplates = [];
    }).on("tag:endif", function(tag2) {
      assertEmpty(tag2.args);
      this.stop();
    }).on("template", (tpl) => p.push(tpl)).on("end", () => {
      throw new Error(`tag ${tagToken.getText()} not closed`);
    }).start();
  }
  *render(ctx, emitter) {
    const r = this.liquid.renderer;
    for (const { value, templates } of this.branches) {
      const v = yield value.value(ctx, ctx.opts.lenientIf);
      if (isTruthy(v, ctx)) {
        yield r.renderTemplates(templates, ctx, emitter);
        return;
      }
    }
    yield r.renderTemplates(this.elseTemplates || [], ctx, emitter);
  }
  *children() {
    const templates = this.branches.flatMap((b) => b.templates);
    if (this.elseTemplates) {
      templates.push(...this.elseTemplates);
    }
    return templates;
  }
  arguments() {
    return this.branches.map((b) => b.value);
  }
}
class IncrementTag extends Tag {
  constructor(token, remainTokens, liquid) {
    super(token, remainTokens, liquid);
    this.identifier = this.tokenizer.readIdentifier();
    this.variable = this.identifier.content;
  }
  render(context, emitter) {
    const scope = context.environments;
    if (!isNumber(scope[this.variable])) {
      scope[this.variable] = 0;
    }
    const val = scope[this.variable];
    scope[this.variable]++;
    emitter.write(stringify(val));
  }
  *localScope() {
    yield this.identifier;
  }
}
class LayoutTag extends Tag {
  constructor(token, remainTokens, liquid, parser) {
    super(token, remainTokens, liquid);
    this.file = parseFilePath(this.tokenizer, this.liquid, parser);
    this["currentFile"] = token.file;
    this.args = new Hash(this.tokenizer, liquid.options.keyValueSeparator);
    this.templates = parser.parseTokens(remainTokens);
  }
  *render(ctx, emitter) {
    const { liquid, args, file } = this;
    const { renderer } = liquid;
    if (file === void 0) {
      ctx.setRegister("blockMode", BlockMode.OUTPUT);
      yield renderer.renderTemplates(this.templates, ctx, emitter);
      return;
    }
    const filepath = yield renderFilePath(this.file, ctx, liquid);
    assert(filepath, () => `illegal file path "${filepath}"`);
    const templates = yield liquid._parseLayoutFile(filepath, ctx.sync, this["currentFile"]);
    ctx.setRegister("blockMode", BlockMode.STORE);
    const html = yield renderer.renderTemplates(this.templates, ctx);
    const blocks = ctx.getRegister("blocks");
    if (blocks[""] === void 0)
      blocks[""] = (parent, emitter2) => emitter2.write(html);
    ctx.setRegister("blockMode", BlockMode.OUTPUT);
    ctx.push(yield args.render(ctx));
    yield renderer.renderTemplates(templates, ctx, emitter);
    ctx.pop();
  }
  *children(partials) {
    const templates = this.templates.slice();
    if (partials && isString(this.file)) {
      templates.push(...yield this.liquid._parsePartialFile(this.file, true, this["currentFile"]));
    }
    return templates;
  }
  *arguments() {
    for (const v of Object.values(this.args.hash)) {
      if (isValueToken(v)) {
        yield v;
      }
    }
    if (isValueToken(this.file)) {
      yield this.file;
    }
  }
  partialScope() {
    if (isString(this.file)) {
      return { name: this.file, isolated: false, scope: Object.keys(this.args.hash) };
    }
  }
}
class BlockTag extends Tag {
  constructor(token, remainTokens, liquid, parser) {
    super(token, remainTokens, liquid);
    this.templates = [];
    const match = /\w+/.exec(token.args);
    this.block = match ? match[0] : "";
    while (remainTokens.length) {
      const token2 = remainTokens.shift();
      if (isTagToken(token2) && token2.name === "endblock")
        return;
      const template2 = parser.parseToken(token2, remainTokens);
      this.templates.push(template2);
    }
    throw new Error(`tag ${token.getText()} not closed`);
  }
  *render(ctx, emitter) {
    const blockRender = this.getBlockRender(ctx);
    if (ctx.getRegister("blockMode") === BlockMode.STORE) {
      ctx.getRegister("blocks")[this.block] = blockRender;
    } else {
      yield blockRender(new BlockDrop(), emitter);
    }
  }
  getBlockRender(ctx) {
    const { liquid, templates } = this;
    const renderChild = ctx.getRegister("blocks")[this.block];
    const renderCurrent = function* (superBlock, emitter) {
      ctx.push({ block: superBlock });
      yield liquid.renderer.renderTemplates(templates, ctx, emitter);
      ctx.pop();
    };
    return renderChild ? (superBlock, emitter) => renderChild(new BlockDrop((emitter2) => renderCurrent(superBlock, emitter2)), emitter) : renderCurrent;
  }
  *children() {
    return this.templates;
  }
  blockScope() {
    return ["block"];
  }
}
class RawTag extends Tag {
  constructor(tagToken, remainTokens, liquid) {
    super(tagToken, remainTokens, liquid);
    this.tokens = [];
    while (remainTokens.length) {
      const token = remainTokens.shift();
      if (isTagToken(token) && token.name === "endraw")
        return;
      this.tokens.push(token);
    }
    throw new Error(`tag ${tagToken.getText()} not closed`);
  }
  render() {
    return this.tokens.map((token) => token.getText()).join("");
  }
}
class TablerowloopDrop extends ForloopDrop {
  constructor(length, cols, collection, variable) {
    super(length, collection, variable);
    this.length = length;
    this.cols = cols;
  }
  row() {
    return Math.floor(this.i / this.cols) + 1;
  }
  col0() {
    return this.i % this.cols;
  }
  col() {
    return this.col0() + 1;
  }
  col_first() {
    return this.col0() === 0;
  }
  col_last() {
    return this.col() === this.cols;
  }
}
class TablerowTag extends Tag {
  constructor(tagToken, remainTokens, liquid, parser) {
    super(tagToken, remainTokens, liquid);
    const variable = this.tokenizer.readIdentifier();
    this.tokenizer.skipBlank();
    const predicate = this.tokenizer.readIdentifier();
    const collectionToken = this.tokenizer.readValue();
    if (predicate.content !== "in" || !collectionToken) {
      throw new Error(`illegal tag: ${tagToken.getText()}`);
    }
    this.variable = variable.content;
    this.collection = collectionToken;
    this.args = new Hash(this.tokenizer, liquid.options.keyValueSeparator);
    this.templates = [];
    let p;
    const stream = parser.parseStream(remainTokens).on("start", () => p = this.templates).on("tag:endtablerow", () => stream.stop()).on("template", (tpl) => p.push(tpl)).on("end", () => {
      throw new Error(`tag ${tagToken.getText()} not closed`);
    });
    stream.start();
  }
  *render(ctx, emitter) {
    let collection = toEnumerable(yield evalToken(this.collection, ctx));
    const args = yield this.args.render(ctx);
    const offset2 = args.offset || 0;
    const limit2 = args.limit === void 0 ? collection.length : args.limit;
    collection = collection.slice(offset2, offset2 + limit2);
    const cols = args.cols || collection.length;
    const r = this.liquid.renderer;
    const tablerowloop = new TablerowloopDrop(collection.length, cols, this.collection.getText(), this.variable);
    const scope = { tablerowloop };
    ctx.push(scope);
    for (let idx = 0; idx < collection.length; idx++, tablerowloop.next()) {
      scope[this.variable] = collection[idx];
      if (tablerowloop.col0() === 0) {
        if (tablerowloop.row() !== 1)
          emitter.write("</tr>");
        emitter.write(`<tr class="row${tablerowloop.row()}">`);
      }
      emitter.write(`<td class="col${tablerowloop.col()}">`);
      yield r.renderTemplates(this.templates, ctx, emitter);
      emitter.write("</td>");
    }
    if (collection.length)
      emitter.write("</tr>");
    ctx.pop();
  }
  *children() {
    return this.templates;
  }
  *arguments() {
    yield this.collection;
    for (const v of Object.values(this.args.hash)) {
      if (isValueToken(v)) {
        yield v;
      }
    }
  }
  blockScope() {
    return [this.variable, "tablerowloop"];
  }
}
class UnlessTag extends Tag {
  constructor(tagToken, remainTokens, liquid, parser) {
    super(tagToken, remainTokens, liquid);
    this.branches = [];
    this.elseTemplates = [];
    let p = [];
    let elseCount = 0;
    parser.parseStream(remainTokens).on("start", () => this.branches.push({
      value: new Value(tagToken.tokenizer.readFilteredValue(), this.liquid),
      test: isFalsy,
      templates: p = []
    })).on("tag:elsif", (token) => {
      if (elseCount > 0) {
        p = [];
        return;
      }
      this.branches.push({
        value: new Value(token.tokenizer.readFilteredValue(), this.liquid),
        test: isTruthy,
        templates: p = []
      });
    }).on("tag:else", () => {
      elseCount++;
      p = this.elseTemplates;
    }).on("tag:endunless", function() {
      this.stop();
    }).on("template", (tpl) => {
      if (p !== this.elseTemplates || elseCount === 1) {
        p.push(tpl);
      }
    }).on("end", () => {
      throw new Error(`tag ${tagToken.getText()} not closed`);
    }).start();
  }
  *render(ctx, emitter) {
    const r = this.liquid.renderer;
    for (const { value, test, templates } of this.branches) {
      const v = yield value.value(ctx, ctx.opts.lenientIf);
      if (test(v, ctx)) {
        yield r.renderTemplates(templates, ctx, emitter);
        return;
      }
    }
    yield r.renderTemplates(this.elseTemplates, ctx, emitter);
  }
  *children() {
    const children = this.branches.flatMap((b) => b.templates);
    if (this.elseTemplates) {
      children.push(...this.elseTemplates);
    }
    return children;
  }
  arguments() {
    return this.branches.map((b) => b.value);
  }
}
class BreakTag extends Tag {
  render(ctx, _emitter) {
    ctx.breakCalled = true;
  }
}
class ContinueTag extends Tag {
  render(ctx, _emitter) {
    ctx.continueCalled = true;
  }
}
class EchoTag extends Tag {
  constructor(token, remainTokens, liquid) {
    super(token, remainTokens, liquid);
    this.tokenizer.skipBlank();
    if (!this.tokenizer.end()) {
      this.value = new Value(this.tokenizer.readFilteredValue(), this.liquid);
    }
  }
  *render(ctx, emitter) {
    if (!this.value)
      return;
    const val = yield this.value.value(ctx, false);
    emitter.write(val);
  }
  *arguments() {
    if (this.value) {
      yield this.value;
    }
  }
}
class LiquidTag extends Tag {
  constructor(token, remainTokens, liquid, parser) {
    super(token, remainTokens, liquid);
    const tokens = this.tokenizer.readLiquidTagTokens(this.liquid.options);
    this.templates = parser.parseTokens(tokens);
  }
  *render(ctx, emitter) {
    yield this.liquid.renderer.renderTemplates(this.templates, ctx, emitter);
  }
  *children() {
    return this.templates;
  }
}
class InlineCommentTag extends Tag {
  constructor(tagToken, remainTokens, liquid) {
    super(tagToken, remainTokens, liquid);
    if (tagToken.args.search(/\n\s*[^#\s]/g) !== -1) {
      throw new Error("every line of an inline comment must start with a '#' character");
    }
  }
  render() {
  }
}
const tags = {
  assign: AssignTag,
  "for": ForTag,
  capture: CaptureTag,
  "case": CaseTag,
  comment: CommentTag,
  include: IncludeTag,
  render: RenderTag,
  decrement: DecrementTag,
  increment: IncrementTag,
  cycle: CycleTag,
  "if": IfTag,
  layout: LayoutTag,
  block: BlockTag,
  raw: RawTag,
  tablerow: TablerowTag,
  unless: UnlessTag,
  "break": BreakTag,
  "continue": ContinueTag,
  echo: EchoTag,
  liquid: LiquidTag,
  "#": InlineCommentTag
};
class Liquid {
  constructor(opts = {}) {
    this.renderer = new Render();
    this.filters = {};
    this.tags = {};
    this.options = normalize(opts);
    this.parser = new Parser3(this);
    forOwn(tags, (conf, name) => this.registerTag(name, conf));
    forOwn(filters, (handler, name) => this.registerFilter(name, handler));
  }
  parse(html, filepath) {
    const parser = new Parser3(this);
    return parser.parse(html, filepath);
  }
  _render(tpl, scope, renderOptions) {
    const ctx = scope instanceof Context ? scope : new Context(scope, this.options, renderOptions);
    return this.renderer.renderTemplates(tpl, ctx);
  }
  render(tpl, scope, renderOptions) {
    return __awaiter(this, void 0, void 0, function* () {
      return toPromise(this._render(tpl, scope, Object.assign(Object.assign({}, renderOptions), { sync: false })));
    });
  }
  renderSync(tpl, scope, renderOptions) {
    return toValueSync(this._render(tpl, scope, Object.assign(Object.assign({}, renderOptions), { sync: true })));
  }
  renderToNodeStream(tpl, scope, renderOptions = {}) {
    const ctx = new Context(scope, this.options, renderOptions);
    return this.renderer.renderTemplatesToNodeStream(tpl, ctx);
  }
  _parseAndRender(html, scope, renderOptions) {
    const tpl = this.parse(html);
    return this._render(tpl, scope, renderOptions);
  }
  parseAndRender(html, scope, renderOptions) {
    return __awaiter(this, void 0, void 0, function* () {
      return toPromise(this._parseAndRender(html, scope, Object.assign(Object.assign({}, renderOptions), { sync: false })));
    });
  }
  parseAndRenderSync(html, scope, renderOptions) {
    return toValueSync(this._parseAndRender(html, scope, Object.assign(Object.assign({}, renderOptions), { sync: true })));
  }
  _parsePartialFile(file, sync, currentFile) {
    return new Parser3(this).parseFile(file, sync, LookupType.Partials, currentFile);
  }
  _parseLayoutFile(file, sync, currentFile) {
    return new Parser3(this).parseFile(file, sync, LookupType.Layouts, currentFile);
  }
  _parseFile(file, sync, lookupType, currentFile) {
    return new Parser3(this).parseFile(file, sync, lookupType, currentFile);
  }
  parseFile(file, lookupType) {
    return __awaiter(this, void 0, void 0, function* () {
      return toPromise(new Parser3(this).parseFile(file, false, lookupType));
    });
  }
  parseFileSync(file, lookupType) {
    return toValueSync(new Parser3(this).parseFile(file, true, lookupType));
  }
  *_renderFile(file, ctx, renderFileOptions) {
    const templates = yield this._parseFile(file, renderFileOptions.sync, renderFileOptions.lookupType);
    return yield this._render(templates, ctx, renderFileOptions);
  }
  renderFile(file, ctx, renderFileOptions) {
    return __awaiter(this, void 0, void 0, function* () {
      return toPromise(this._renderFile(file, ctx, Object.assign(Object.assign({}, renderFileOptions), { sync: false })));
    });
  }
  renderFileSync(file, ctx, renderFileOptions) {
    return toValueSync(this._renderFile(file, ctx, Object.assign(Object.assign({}, renderFileOptions), { sync: true })));
  }
  renderFileToNodeStream(file, scope, renderOptions) {
    return __awaiter(this, void 0, void 0, function* () {
      const templates = yield this.parseFile(file);
      return this.renderToNodeStream(templates, scope, renderOptions);
    });
  }
  _evalValue(str, scope) {
    const value = new Value(str, this);
    const ctx = scope instanceof Context ? scope : new Context(scope, this.options);
    return value.value(ctx);
  }
  evalValue(str, scope) {
    return __awaiter(this, void 0, void 0, function* () {
      return toPromise(this._evalValue(str, scope));
    });
  }
  evalValueSync(str, scope) {
    return toValueSync(this._evalValue(str, scope));
  }
  registerFilter(name, filter2) {
    this.filters[name] = filter2;
  }
  registerTag(name, tag2) {
    this.tags[name] = isFunction(tag2) ? tag2 : createTagClass(tag2);
  }
  plugin(plugin) {
    return plugin.call(this, Liquid);
  }
  express() {
    const self2 = this;
    let firstCall = true;
    return function(filePath, ctx, callback) {
      if (firstCall) {
        firstCall = false;
        const dirs = normalizeDirectoryList(this.root);
        self2.options.root.unshift(...dirs);
        self2.options.layouts.unshift(...dirs);
        self2.options.partials.unshift(...dirs);
      }
      self2.renderFile(filePath, ctx).then((html) => callback(null, html), callback);
    };
  }
  analyze(template2, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      return analyze(template2, options);
    });
  }
  analyzeSync(template2, options = {}) {
    return analyzeSync(template2, options);
  }
  parseAndAnalyze(html, filename, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      return analyze(this.parse(html, filename), options);
    });
  }
  parseAndAnalyzeSync(html, filename, options = {}) {
    return analyzeSync(this.parse(html, filename), options);
  }
  /** Return an array of all variables without their properties. */
  variables(template2, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const analysis = yield analyze(isString(template2) ? this.parse(template2) : template2, options);
      return Object.keys(analysis.variables);
    });
  }
  /** Return an array of all variables without their properties. */
  variablesSync(template2, options = {}) {
    const analysis = analyzeSync(isString(template2) ? this.parse(template2) : template2, options);
    return Object.keys(analysis.variables);
  }
  /** Return an array of all variables including their properties/paths. */
  fullVariables(template2, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const analysis = yield analyze(isString(template2) ? this.parse(template2) : template2, options);
      return Array.from(new Set(Object.values(analysis.variables).flatMap((a) => a.map((v) => String(v)))));
    });
  }
  /** Return an array of all variables including their properties/paths. */
  fullVariablesSync(template2, options = {}) {
    const analysis = analyzeSync(isString(template2) ? this.parse(template2) : template2, options);
    return Array.from(new Set(Object.values(analysis.variables).flatMap((a) => a.map((v) => String(v)))));
  }
  /** Return an array of all variables, each as an array of properties/segments. */
  variableSegments(template2, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const analysis = yield analyze(isString(template2) ? this.parse(template2) : template2, options);
      return Array.from(strictUniq(Object.values(analysis.variables).flatMap((a) => a.map((v) => v.toArray()))));
    });
  }
  /** Return an array of all variables, each as an array of properties/segments. */
  variableSegmentsSync(template2, options = {}) {
    const analysis = analyzeSync(isString(template2) ? this.parse(template2) : template2, options);
    return Array.from(strictUniq(Object.values(analysis.variables).flatMap((a) => a.map((v) => v.toArray()))));
  }
  /** Return an array of all expected context variables without their properties. */
  globalVariables(template2, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const analysis = yield analyze(isString(template2) ? this.parse(template2) : template2, options);
      return Object.keys(analysis.globals);
    });
  }
  /** Return an array of all expected context variables without their properties. */
  globalVariablesSync(template2, options = {}) {
    const analysis = analyzeSync(isString(template2) ? this.parse(template2) : template2, options);
    return Object.keys(analysis.globals);
  }
  /** Return an array of all expected context variables including their properties/paths. */
  globalFullVariables(template2, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const analysis = yield analyze(isString(template2) ? this.parse(template2) : template2, options);
      return Array.from(new Set(Object.values(analysis.globals).flatMap((a) => a.map((v) => String(v)))));
    });
  }
  /** Return an array of all expected context variables including their properties/paths. */
  globalFullVariablesSync(template2, options = {}) {
    const analysis = analyzeSync(isString(template2) ? this.parse(template2) : template2, options);
    return Array.from(new Set(Object.values(analysis.globals).flatMap((a) => a.map((v) => String(v)))));
  }
  /** Return an array of all expected context variables, each as an array of properties/segments. */
  globalVariableSegments(template2, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      const analysis = yield analyze(isString(template2) ? this.parse(template2) : template2, options);
      return Array.from(strictUniq(Object.values(analysis.globals).flatMap((a) => a.map((v) => v.toArray()))));
    });
  }
  /** Return an array of all expected context variables, each as an array of properties/segments. */
  globalVariableSegmentsSync(template2, options = {}) {
    const analysis = analyzeSync(isString(template2) ? this.parse(template2) : template2, options);
    return Array.from(strictUniq(Object.values(analysis.globals).flatMap((a) => a.map((v) => v.toArray()))));
  }
}
class LiquidTemplateEngine extends BaseTemplateEngine {
  constructor() {
    super();
    this.name = "liquid";
    this.compiledTemplates = /* @__PURE__ */ new Map();
    this.liquid = new Liquid({
      cache: true,
      strictFilters: false,
      // Allow undefined filters to fail gracefully
      strictVariables: false,
      // Allow undefined variables
      trimTagLeft: false,
      trimTagRight: false,
      trimOutputLeft: false,
      trimOutputRight: false
    });
    this.registerDefaultFilters();
  }
  /**
   * Render a template with Liquid
   */
  async render(template2, context) {
    try {
      let compiledTemplate = this.compiledTemplates.get(template2);
      if (!compiledTemplate) {
        compiledTemplate = this.liquid.parse(template2);
        this.compiledTemplates.set(template2, compiledTemplate);
      }
      const hasDataProperty = "data" in context && context.data !== void 0;
      const data = hasDataProperty ? context.data : context;
      return await this.liquid.render(compiledTemplate, data);
    } catch (error) {
      throw new Error(
        `Liquid render error: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
  /**
   * Validate template syntax
   */
  async validate(template2) {
    try {
      this.liquid.parse(template2);
      return { valid: true };
    } catch (error) {
      return {
        valid: false,
        errors: [error instanceof Error ? error.message : String(error)]
      };
    }
  }
  /**
   * Compile a template for repeated use
   */
  async compile(template2) {
    const compiled = this.liquid.parse(template2);
    this.compiledTemplates.set(template2, compiled);
    return compiled;
  }
  /**
   * Register a helper function (Liquid calls them filters)
   */
  registerHelper(name, fn) {
    this.liquid.registerFilter(name, fn);
  }
  /**
   * Register default filters
   */
  registerDefaultFilters() {
    this.liquid.registerFilter("money", (value) => {
      const num = parseFloat(value);
      if (isNaN(num)) return value;
      return `$${num.toFixed(2)}`;
    });
    this.liquid.registerFilter("money_with_currency", (value, currency = "USD") => {
      const num = parseFloat(value);
      if (isNaN(num)) return value;
      return new Intl.NumberFormat("en-US", {
        style: "currency",
        currency
      }).format(num);
    });
    this.liquid.registerFilter("phone", (value) => {
      const cleaned = value.replace(/\D/g, "");
      if (cleaned.length === 10) {
        return `(${cleaned.slice(0, 3)}) ${cleaned.slice(3, 6)}-${cleaned.slice(6)}`;
      }
      return value;
    });
    this.liquid.registerFilter("pluralize", (count, singular, plural) => {
      if (count === 1) return singular;
      return plural || `${singular}s`;
    });
    this.liquid.registerFilter("default", (value, defaultValue) => {
      return value ?? defaultValue;
    });
    this.liquid.registerFilter("json", (obj) => {
      try {
        return JSON.stringify(obj, null, 2);
      } catch {
        return String(obj);
      }
    });
    this.liquid.registerFilter("excerpt", (text, length = 200) => {
      if (typeof text !== "string") return text;
      if (text.length <= length) return text;
      return text.substring(0, length).trim() + "...";
    });
    this.liquid.registerFilter("strip_html", (text) => {
      if (typeof text !== "string") return text;
      return text.replace(/<[^>]*>/g, "");
    });
    this.liquid.registerFilter("highlight", (text, term) => {
      if (!text || !term) return text;
      const regex = new RegExp(`(${term})`, "gi");
      return text.replace(regex, "<mark>$1</mark>");
    });
    this.liquid.registerFilter("file_size", (bytes) => {
      if (bytes === 0) return "0 Bytes";
      const k = 1024;
      const sizes = ["Bytes", "KB", "MB", "GB"];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return Math.round(bytes / Math.pow(k, i) * 100) / 100 + " " + sizes[i];
    });
    this.liquid.registerFilter("time_ago", (date2) => {
      const d = date2 instanceof Date ? date2 : new Date(date2);
      const now = /* @__PURE__ */ new Date();
      const seconds = Math.floor((now.getTime() - d.getTime()) / 1e3);
      const intervals = [
        { label: "year", seconds: 31536e3 },
        { label: "month", seconds: 2592e3 },
        { label: "week", seconds: 604800 },
        { label: "day", seconds: 86400 },
        { label: "hour", seconds: 3600 },
        { label: "minute", seconds: 60 },
        { label: "second", seconds: 1 }
      ];
      for (const interval of intervals) {
        const count = Math.floor(seconds / interval.seconds);
        if (count >= 1) {
          return `${count} ${interval.label}${count > 1 ? "s" : ""} ago`;
        }
      }
      return "just now";
    });
  }
  /**
   * Clear the template cache
   */
  clearCache() {
    this.compiledTemplates.clear();
  }
}
class ThinkAgent extends BaseAgent {
  constructor(config, providerRegistry) {
    super(config);
    this.providerRegistry = providerRegistry || getProviderRegistry();
    const cfg = config.config;
    const engineType = cfg?.templateEngine || "simple";
    switch (engineType) {
      case "simple":
        this.templateEngine = new SimpleTemplateEngine();
        break;
      case "liquid":
        this.templateEngine = new LiquidTemplateEngine();
        break;
      default:
        this.templateEngine = new SimpleTemplateEngine();
        break;
    }
    const model = cfg?.model || "claude-3-5-haiku-20241022";
    const provider = cfg?.provider || this.detectProvider(model);
    this.thinkConfig = {
      model,
      provider,
      temperature: cfg?.temperature || 0.7,
      maxTokens: cfg?.maxTokens || 1e3,
      apiKey: cfg?.apiKey,
      apiEndpoint: cfg?.apiEndpoint,
      systemPrompt: cfg?.systemPrompt,
      prompt: cfg?.prompt,
      schema: cfg?.schema
    };
  }
  /**
   * Auto-detect AI provider from model name
   */
  detectProvider(model) {
    if (model.startsWith("@cf/")) {
      return AIProvider.Cloudflare;
    }
    if (model.startsWith("gpt-") || model.startsWith("o1-") || model.startsWith("text-")) {
      return AIProvider.OpenAI;
    }
    if (model.startsWith("claude-")) {
      return AIProvider.Anthropic;
    }
    return AIProvider.Anthropic;
  }
  /**
   * Execute AI reasoning via provider system
   *
   * Output Design Philosophy:
   * 
   * Think agents return output that's intuitive to use in ensembles:
   *
   * 1. If schema defines output fields  AI response maps to those fields
   *    Schema: { output: { greeting: string } }
   *    Output: { greeting: "Hello!", _meta: { model, provider, tokens } }
   *    Usage:  ${agent.output.greeting}
   *
   * 2. If no schema  AI response is the direct output value
   *    Output: "Hello!"  (string, not wrapped in object)
   *    Usage:  ${agent.output}
   *
   * 3. If AI returns JSON  parsed and spread as output fields
   *    Output: { name: "John", age: 30, _meta: {...} }
   *    Usage:  ${agent.output.name}, ${agent.output.age}
   *
   * The _meta field contains provider details (model, tokens, etc.)
   * for debugging/logging, but user data is always top-level.
   */
  async run(context) {
    const { input, env } = context;
    await this.resolvePrompt(env);
    if (this.thinkConfig.systemPrompt) {
      const logger2 = context.logger;
      logger2?.debug("Template rendering started", {
        agentName: this.getName(),
        templateLength: this.thinkConfig.systemPrompt.length
      });
      try {
        this.thinkConfig.systemPrompt = await this.templateEngine.render(
          this.thinkConfig.systemPrompt,
          {
            input,
            env,
            context
          }
        );
        logger2?.debug("Template rendering completed", {
          agentName: this.getName(),
          renderedLength: this.thinkConfig.systemPrompt.length
        });
      } catch (error) {
        logger2?.error("Template rendering failed", error instanceof Error ? error : void 0, {
          agentName: this.getName()
        });
        throw new Error(
          `Failed to render systemPrompt template: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    }
    await this.resolveSchema(env);
    const providerId = this.thinkConfig.provider || AIProvider.Anthropic;
    const provider = this.providerRegistry.get(providerId);
    if (!provider) {
      throw new Error(
        `Unknown AI provider: ${providerId}. Available providers: ${this.providerRegistry.getProviderIds().join(", ")}`
      );
    }
    const providerConfig = {
      model: this.thinkConfig.model || "claude-3-5-haiku-20241022",
      temperature: this.thinkConfig.temperature,
      maxTokens: this.thinkConfig.maxTokens,
      apiKey: this.thinkConfig.apiKey,
      apiEndpoint: this.thinkConfig.apiEndpoint,
      systemPrompt: this.thinkConfig.systemPrompt,
      schema: this.thinkConfig.schema
    };
    const configError = provider.getConfigError(providerConfig, env);
    if (configError) {
      throw new Error(configError);
    }
    const messages = this.buildMessages(input);
    const response = await provider.execute({
      messages,
      config: providerConfig,
      env
    });
    return this.buildOutput(response);
  }
  /**
   * Build user-friendly output from AI provider response
   *
   * Design Goals:
   * 1. Schema-defined fields are top-level (not nested under 'content')
   * 2. Metadata is accessible but doesn't pollute user data
   * 3. Works intuitively with ${agent.output.fieldName} syntax
   */
  buildOutput(response) {
    const outputSchema = this.config.schema?.output;
    const meta = {
      model: response.model,
      provider: response.provider,
      tokensUsed: response.tokensUsed,
      ...response.metadata || {}
    };
    let parsedContent = null;
    try {
      parsedContent = JSON.parse(response.content);
    } catch {
    }
    if (parsedContent && typeof parsedContent === "object" && !Array.isArray(parsedContent)) {
      return {
        ...parsedContent,
        _meta: meta
      };
    }
    if (outputSchema && typeof outputSchema === "object") {
      const schemaFields = Object.keys(outputSchema);
      if (schemaFields.length === 1) {
        const fieldName = schemaFields[0];
        return {
          [fieldName]: parsedContent ?? response.content,
          _meta: meta
        };
      } else if (schemaFields.length > 1) {
        const fieldName = schemaFields[0];
        return {
          [fieldName]: parsedContent ?? response.content,
          _meta: meta
        };
      }
    }
    if (Array.isArray(parsedContent)) {
      return {
        items: parsedContent,
        _meta: meta
      };
    }
    return {
      content: response.content,
      _meta: meta
    };
  }
  /**
   * Resolve prompt from Edgit if needed
   */
  async resolvePrompt(env) {
    if (this.thinkConfig.systemPrompt) return;
    if (this.thinkConfig.prompt) {
      const context = {
        env,
        baseDir: process.cwd()
      };
      try {
        const resolved = await resolveValue(this.thinkConfig.prompt, context);
        if (typeof resolved.content === "string") {
          this.thinkConfig.systemPrompt = resolved.content;
        } else {
          throw new Error(`Prompt must resolve to a string, got ${typeof resolved.content}`);
        }
      } catch (error) {
        throw new Error(
          `Failed to resolve prompt "${this.thinkConfig.prompt}": ${error instanceof Error ? error.message : String(error)}`
        );
      }
    }
  }
  /**
   * Resolve schema from Edgit if needed
   */
  async resolveSchema(env) {
    if (!this.thinkConfig.schema) return;
    if (typeof this.thinkConfig.schema !== "string") return;
    const context = {
      env,
      baseDir: process.cwd()
    };
    try {
      const resolved = await resolveValue(this.thinkConfig.schema, context);
      if (typeof resolved.content === "object" && resolved.content !== null) {
        this.thinkConfig.schema = resolved.content;
      } else if (typeof resolved.content === "string") {
        try {
          this.thinkConfig.schema = JSON.parse(resolved.content);
        } catch {
          throw new Error(`Schema must be valid JSON, got invalid string`);
        }
      } else {
        throw new Error(
          `Schema must resolve to an object or JSON string, got ${typeof resolved.content}`
        );
      }
    } catch (error) {
      throw new Error(
        `Failed to resolve schema "${this.thinkConfig.schema}": ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
  /**
   * Build messages array from input
   */
  buildMessages(input) {
    const messages = [];
    if (this.thinkConfig.systemPrompt) {
      messages.push({
        role: "system",
        content: this.thinkConfig.systemPrompt
      });
    }
    if (input.messages && Array.isArray(input.messages)) {
      messages.push(...input.messages);
    } else if (input.prompt) {
      messages.push({
        role: "user",
        content: input.prompt
      });
    } else {
      const promptParts = [];
      for (const [key, value] of Object.entries(input)) {
        if (typeof value === "string") {
          promptParts.push(`${key}: ${value}`);
        } else {
          promptParts.push(`${key}: ${JSON.stringify(value, null, 2)}`);
        }
      }
      messages.push({
        role: "user",
        content: promptParts.join("\n\n")
      });
    }
    return messages;
  }
  /**
   * Get Think configuration
   */
  getThinkConfig() {
    return { ...this.thinkConfig };
  }
}
class JSONSerializer {
  serialize(value) {
    return JSON.stringify(value);
  }
  deserialize(raw2) {
    return JSON.parse(raw2);
  }
}
class KVRepository {
  constructor(binding, serializer = new JSONSerializer()) {
    this.binding = binding;
    this.serializer = serializer;
  }
  /**
   * Get a value from KV
   */
  async get(key) {
    try {
      const raw2 = await this.binding.get(key);
      if (raw2 === null) {
        return Result.err(Errors.storageNotFound(key, "KV"));
      }
      const value = this.serializer.deserialize(raw2);
      return Result.ok(value);
    } catch (error) {
      return Result.err(
        Errors.internal(
          `KV get operation failed for key "${key}"`,
          error instanceof Error ? error : void 0
        )
      );
    }
  }
  /**
   * Store a value in KV
   */
  async put(key, value, options) {
    try {
      const serialized = this.serializer.serialize(value);
      const kvOptions = {};
      if (options?.ttl) {
        kvOptions.expirationTtl = options.ttl;
      }
      if (options?.expiration) {
        kvOptions.expiration = options.expiration;
      }
      if (options?.metadata) {
        kvOptions.metadata = options.metadata;
      }
      await this.binding.put(key, serialized, kvOptions);
      return Result.ok(void 0);
    } catch (error) {
      return Result.err(
        Errors.internal(
          `KV put operation failed for key "${key}"`,
          error instanceof Error ? error : void 0
        )
      );
    }
  }
  /**
   * Delete a value from KV
   */
  async delete(key) {
    try {
      await this.binding.delete(key);
      return Result.ok(void 0);
    } catch (error) {
      return Result.err(
        Errors.internal(
          `KV delete operation failed for key "${key}"`,
          error instanceof Error ? error : void 0
        )
      );
    }
  }
  /**
   * List keys in KV
   */
  async list(options) {
    try {
      const listOptions = {};
      if (options?.prefix) {
        listOptions.prefix = options.prefix;
      }
      if (options?.limit) {
        listOptions.limit = options.limit;
      }
      if (options?.cursor) {
        listOptions.cursor = options.cursor;
      }
      const result = await this.binding.list(listOptions);
      const BATCH_SIZE = 10;
      const keys = result.keys;
      const values = [];
      for (let i = 0; i < keys.length; i += BATCH_SIZE) {
        const batch = keys.slice(i, i + BATCH_SIZE);
        const batchResults = await Promise.all(batch.map((key) => this.get(key.name)));
        for (const getResult of batchResults) {
          if (getResult.success) {
            values.push(getResult.value);
          }
        }
      }
      return Result.ok(values);
    } catch (error) {
      return Result.err(
        Errors.internal("KV list operation failed", error instanceof Error ? error : void 0)
      );
    }
  }
  /**
   * Check if a key exists in KV
   */
  async has(key) {
    try {
      const value = await this.binding.get(key);
      return Result.ok(value !== null);
    } catch (error) {
      return Result.err(
        Errors.internal(
          `KV has operation failed for key "${key}"`,
          error instanceof Error ? error : void 0
        )
      );
    }
  }
  /**
   * Get value with metadata
   */
  async getWithMetadata(key) {
    try {
      const result = await this.binding.getWithMetadata(key);
      if (result.value === null) {
        return Result.err(Errors.storageNotFound(key, "KV"));
      }
      const value = this.serializer.deserialize(result.value);
      return Result.ok({
        value,
        metadata: result.metadata
      });
    } catch (error) {
      return Result.err(
        Errors.internal(
          `KV getWithMetadata operation failed for key "${key}"`,
          error instanceof Error ? error : void 0
        )
      );
    }
  }
}
function validateSqlIdentifier(identifier, type) {
  if (!identifier || typeof identifier !== "string") {
    throw new Error(`Invalid ${type} name: must be a non-empty string`);
  }
  if (identifier.length > 128) {
    throw new Error(`Invalid ${type} name "${identifier}": exceeds maximum length of 128 characters`);
  }
  const validIdentifierPattern = /^[a-zA-Z_][a-zA-Z0-9_]*$/;
  if (!validIdentifierPattern.test(identifier)) {
    throw new Error(
      `Invalid ${type} name "${identifier}": must start with a letter or underscore and contain only letters, numbers, and underscores`
    );
  }
  return identifier;
}
class D1Repository {
  constructor(binding, config, serializer = new JSONSerializer()) {
    this.binding = binding;
    this.serializer = serializer;
    this.tableName = validateSqlIdentifier(config.tableName, "table");
    this.idColumn = validateSqlIdentifier(config.idColumn || "id", "column");
    this.valueColumn = validateSqlIdentifier(config.valueColumn || "value", "column");
    this.createdAtColumn = validateSqlIdentifier(config.createdAtColumn || "created_at", "column");
    this.updatedAtColumn = validateSqlIdentifier(config.updatedAtColumn || "updated_at", "column");
    this.expirationColumn = config.expirationColumn ? validateSqlIdentifier(config.expirationColumn, "column") : void 0;
  }
  /**
   * Get a value from D1
   */
  async get(id) {
    try {
      const query = `
				SELECT ${this.valueColumn}, ${this.expirationColumn || "NULL as expiration"}
				FROM ${this.tableName}
				WHERE ${this.idColumn} = ?
			`;
      const result = await this.binding.prepare(query).bind(id).first();
      if (!result) {
        return Result.err(Errors.storageNotFound(id, "D1"));
      }
      if (this.expirationColumn && result.expiration) {
        const expiration = new Date(result.expiration).getTime();
        if (expiration < Date.now()) {
          await this.delete(id);
          return Result.err(Errors.storageNotFound(id, "D1"));
        }
      }
      const value = this.serializer.deserialize(result[this.valueColumn]);
      return Result.ok(value);
    } catch (error) {
      return Result.err(
        Errors.internal(
          `D1 get operation failed for id "${id}"`,
          error instanceof Error ? error : void 0
        )
      );
    }
  }
  /**
   * Store a value in D1
   */
  async put(id, value, options) {
    try {
      const serialized = this.serializer.serialize(value);
      const now = (/* @__PURE__ */ new Date()).toISOString();
      let query;
      let params;
      if (this.expirationColumn && (options?.ttl || options?.expiration)) {
        const expiration = options.expiration ? new Date(options.expiration * 1e3).toISOString() : new Date(Date.now() + options.ttl * 1e3).toISOString();
        query = `
					INSERT INTO ${this.tableName}
					(${this.idColumn}, ${this.valueColumn}, ${this.createdAtColumn}, ${this.updatedAtColumn}, ${this.expirationColumn})
					VALUES (?, ?, ?, ?, ?)
					ON CONFLICT(${this.idColumn})
					DO UPDATE SET
						${this.valueColumn} = excluded.${this.valueColumn},
						${this.updatedAtColumn} = excluded.${this.updatedAtColumn},
						${this.expirationColumn} = excluded.${this.expirationColumn}
				`;
        params = [id, serialized, now, now, expiration];
      } else {
        query = `
					INSERT INTO ${this.tableName}
					(${this.idColumn}, ${this.valueColumn}, ${this.createdAtColumn}, ${this.updatedAtColumn})
					VALUES (?, ?, ?, ?)
					ON CONFLICT(${this.idColumn})
					DO UPDATE SET
						${this.valueColumn} = excluded.${this.valueColumn},
						${this.updatedAtColumn} = excluded.${this.updatedAtColumn}
				`;
        params = [id, serialized, now, now];
      }
      await this.binding.prepare(query).bind(...params).run();
      return Result.ok(void 0);
    } catch (error) {
      return Result.err(
        Errors.internal(
          `D1 put operation failed for id "${id}"`,
          error instanceof Error ? error : void 0
        )
      );
    }
  }
  /**
   * Delete a value from D1
   */
  async delete(id) {
    try {
      const query = `DELETE FROM ${this.tableName} WHERE ${this.idColumn} = ?`;
      await this.binding.prepare(query).bind(id).run();
      return Result.ok(void 0);
    } catch (error) {
      return Result.err(
        Errors.internal(
          `D1 delete operation failed for id "${id}"`,
          error instanceof Error ? error : void 0
        )
      );
    }
  }
  /**
   * List values from D1
   */
  async list(options) {
    try {
      let query = `SELECT ${this.valueColumn} FROM ${this.tableName}`;
      const params = [];
      if (options?.prefix) {
        query += ` WHERE ${this.idColumn} LIKE ?`;
        params.push(`${options.prefix}%`);
      }
      if (this.expirationColumn) {
        const whereOrAnd = options?.prefix ? "AND" : "WHERE";
        query += ` ${whereOrAnd} (${this.expirationColumn} IS NULL OR ${this.expirationColumn} > datetime('now'))`;
      }
      query += ` ORDER BY ${this.createdAtColumn} DESC`;
      if (options?.limit) {
        query += ` LIMIT ?`;
        params.push(options.limit);
      }
      const result = await this.binding.prepare(query).bind(...params).all();
      const values = result.results.map(
        (row) => this.serializer.deserialize(row[this.valueColumn])
      );
      return Result.ok(values);
    } catch (error) {
      return Result.err(
        Errors.internal("D1 list operation failed", error instanceof Error ? error : void 0)
      );
    }
  }
  /**
   * Check if an ID exists in D1
   */
  async has(id) {
    try {
      const query = `SELECT 1 FROM ${this.tableName} WHERE ${this.idColumn} = ? LIMIT 1`;
      const result = await this.binding.prepare(query).bind(id).first();
      return Result.ok(result !== null);
    } catch (error) {
      return Result.err(
        Errors.internal(
          `D1 has operation failed for id "${id}"`,
          error instanceof Error ? error : void 0
        )
      );
    }
  }
  /**
   * Clean up expired entries
   */
  async cleanExpired() {
    if (!this.expirationColumn) {
      return Result.ok(0);
    }
    try {
      const query = `
				DELETE FROM ${this.tableName}
				WHERE ${this.expirationColumn} IS NOT NULL
				AND ${this.expirationColumn} <= datetime('now')
			`;
      const result = await this.binding.prepare(query).run();
      return Result.ok(result.meta.changes || 0);
    } catch (error) {
      return Result.err(
        Errors.internal(
          "D1 cleanExpired operation failed",
          error instanceof Error ? error : void 0
        )
      );
    }
  }
}
class R2Repository {
  constructor(binding, serializer = new JSONSerializer()) {
    this.binding = binding;
    this.serializer = serializer;
  }
  /**
   * Get an object from R2
   */
  async get(key) {
    try {
      const object = await this.binding.get(key);
      if (object === null) {
        return Result.err(Errors.storageNotFound(key, "R2"));
      }
      const text = await object.text();
      const value = this.serializer.deserialize(text);
      return Result.ok(value);
    } catch (error) {
      return Result.err(
        Errors.internal(
          `R2 get operation failed for key "${key}"`,
          error instanceof Error ? error : void 0
        )
      );
    }
  }
  /**
   * Store an object in R2
   */
  async put(key, value, options) {
    try {
      const serialized = this.serializer.serialize(value);
      const r2Options = {};
      if (options?.metadata) {
        r2Options.customMetadata = options.metadata;
      }
      if (options?.ttl) {
        const expiration = Date.now() + options.ttl * 1e3;
        r2Options.customMetadata = {
          ...r2Options.customMetadata,
          "x-expiration": expiration.toString()
        };
      }
      if (options?.expiration) {
        r2Options.customMetadata = {
          ...r2Options.customMetadata,
          "x-expiration": (options.expiration * 1e3).toString()
        };
      }
      await this.binding.put(key, serialized, r2Options);
      return Result.ok(void 0);
    } catch (error) {
      return Result.err(
        Errors.internal(
          `R2 put operation failed for key "${key}"`,
          error instanceof Error ? error : void 0
        )
      );
    }
  }
  /**
   * Delete an object from R2
   */
  async delete(key) {
    try {
      await this.binding.delete(key);
      return Result.ok(void 0);
    } catch (error) {
      return Result.err(
        Errors.internal(
          `R2 delete operation failed for key "${key}"`,
          error instanceof Error ? error : void 0
        )
      );
    }
  }
  /**
   * List objects in R2
   */
  async list(options) {
    try {
      const listOptions = {};
      if (options?.prefix) {
        listOptions.prefix = options.prefix;
      }
      if (options?.limit) {
        listOptions.limit = options.limit;
      }
      if (options?.cursor) {
        listOptions.cursor = options.cursor;
      }
      const result = await this.binding.list(listOptions);
      const now = Date.now();
      const validObjects = [];
      const expiredKeys = [];
      for (const object of result.objects) {
        const expiration = object.customMetadata?.["x-expiration"];
        if (expiration) {
          const expirationTime = parseInt(expiration, 10);
          if (expirationTime < now) {
            expiredKeys.push(object.key);
            continue;
          }
        }
        validObjects.push(object);
      }
      if (expiredKeys.length > 0) {
        Promise.all(expiredKeys.map((key) => this.binding.delete(key))).catch(() => {
        });
      }
      const BATCH_SIZE = 10;
      const values = [];
      for (let i = 0; i < validObjects.length; i += BATCH_SIZE) {
        const batch = validObjects.slice(i, i + BATCH_SIZE);
        const batchResults = await Promise.all(batch.map((obj) => this.get(obj.key)));
        for (const getResult of batchResults) {
          if (getResult.success) {
            values.push(getResult.value);
          }
        }
      }
      return Result.ok(values);
    } catch (error) {
      return Result.err(
        Errors.internal("R2 list operation failed", error instanceof Error ? error : void 0)
      );
    }
  }
  /**
   * Check if an object exists in R2
   */
  async has(key) {
    try {
      const object = await this.binding.head(key);
      return Result.ok(object !== null);
    } catch (error) {
      return Result.err(
        Errors.internal(
          `R2 has operation failed for key "${key}"`,
          error instanceof Error ? error : void 0
        )
      );
    }
  }
  /**
   * Get object with metadata
   */
  async getWithMetadata(key) {
    try {
      const object = await this.binding.get(key);
      if (object === null) {
        return Result.err(Errors.storageNotFound(key, "R2"));
      }
      const text = await object.text();
      const value = this.serializer.deserialize(text);
      return Result.ok({
        value,
        metadata: object
      });
    } catch (error) {
      return Result.err(
        Errors.internal(
          `R2 getWithMetadata operation failed for key "${key}"`,
          error instanceof Error ? error : void 0
        )
      );
    }
  }
  /**
   * Get object metadata only (head request)
   */
  async getMetadata(key) {
    try {
      const metadata = await this.binding.head(key);
      return Result.ok(metadata);
    } catch (error) {
      return Result.err(
        Errors.internal(
          `R2 getMetadata operation failed for key "${key}"`,
          error instanceof Error ? error : void 0
        )
      );
    }
  }
}
class HyperdriveRepository {
  constructor(hyperdrive, config) {
    this.hyperdrive = hyperdrive;
    this.config = config;
    this.schema = config.schema;
    this.timeout = config.options?.timeout || 3e4;
    this.readOnly = config.options?.readOnly || false;
    this.maxRows = config.options?.maxRows;
  }
  /**
   * Execute a raw SQL query
   */
  async query(sql, params) {
    try {
      if (this.readOnly && this.isWriteQuery(sql)) {
        return Result.err(Errors.internal("Write operations not allowed in read-only mode"));
      }
      const startTime = Date.now();
      let stmt = this.hyperdrive.prepare(sql);
      if (params && params.length > 0) {
        stmt = stmt.bind(...params);
      }
      const result = await stmt.all();
      const executionTime = Date.now() - startTime;
      let rows = result.results;
      if (this.maxRows && rows.length > this.maxRows) {
        rows = rows.slice(0, this.maxRows);
      }
      const columns = rows.length > 0 ? Object.keys(rows[0]) : result.meta?.columns ? result.meta.columns.map((c) => c.name) : [];
      return Result.ok({
        rows,
        metadata: {
          executionTime,
          columns,
          rowCount: rows.length,
          rowsAffected: result.meta?.changes
        }
      });
    } catch (error) {
      return Result.err(
        Errors.internal(
          `Hyperdrive query failed: ${sql}`,
          error instanceof Error ? error : void 0
        )
      );
    }
  }
  /**
   * Execute a query with named parameters
   * Converts named parameters (:name) to positional parameters based on database type
   */
  async queryNamed(sql, params) {
    const { convertedSql, orderedParams } = this.convertNamedParams(sql, params);
    return this.query(convertedSql, orderedParams);
  }
  /**
   * Execute a write query (INSERT, UPDATE, DELETE)
   */
  async execute(sql, params) {
    if (this.readOnly) {
      return Result.err(Errors.internal("Write operations not allowed in read-only mode"));
    }
    try {
      const startTime = Date.now();
      let stmt = this.hyperdrive.prepare(sql);
      if (params && params.length > 0) {
        stmt = stmt.bind(...params);
      }
      const result = await stmt.run();
      return Result.ok({
        rowsAffected: result.meta.changes || 0
      });
    } catch (error) {
      return Result.err(
        Errors.internal(
          `Hyperdrive execute failed: ${sql}`,
          error instanceof Error ? error : void 0
        )
      );
    }
  }
  /**
   * Begin a transaction
   * Note: D1/Hyperdrive transaction support is limited - this is a best-effort implementation
   */
  async transaction(callback) {
    const beginResult = await this.execute("BEGIN");
    if (!beginResult.success) {
      return Result.err(beginResult.error);
    }
    const tx = {
      query: async (sql, params) => this.query(sql, params),
      commit: async () => {
        const result = await this.execute("COMMIT");
        return result.success ? Result.ok(void 0) : Result.err(result.error);
      },
      rollback: async () => {
        const result = await this.execute("ROLLBACK");
        return result.success ? Result.ok(void 0) : Result.err(result.error);
      }
    };
    try {
      const result = await callback(tx);
      const commitResult = await tx.commit();
      if (!commitResult.success) {
        return Result.err(commitResult.error);
      }
      return Result.ok(result);
    } catch (error) {
      await tx.rollback();
      return Result.err(
        Errors.internal("Transaction failed", error instanceof Error ? error : void 0)
      );
    }
  }
  /**
   * Get table metadata
   */
  async getTableInfo(tableName) {
    try {
      let sql;
      switch (this.config.databaseType) {
        case "postgres":
          sql = `
						SELECT
							column_name as name,
							data_type as type,
							is_nullable = 'YES' as nullable,
							column_default as default_value
						FROM information_schema.columns
						WHERE table_name = $1
						${this.schema ? "AND table_schema = $2" : ""}
						ORDER BY ordinal_position
					`;
          break;
        case "mysql":
        case "mariadb":
          sql = `
						SELECT
							COLUMN_NAME as name,
							DATA_TYPE as type,
							IS_NULLABLE = 'YES' as nullable,
							COLUMN_DEFAULT as default_value
						FROM information_schema.columns
						WHERE TABLE_NAME = ?
						${this.schema ? "AND TABLE_SCHEMA = ?" : ""}
						ORDER BY ORDINAL_POSITION
					`;
          break;
      }
      const params = this.schema ? [tableName, this.schema] : [tableName];
      const result = await this.query(sql, params);
      if (!result.success) {
        return Result.err(result.error);
      }
      return Result.ok({
        name: tableName,
        schema: this.schema,
        columns: result.value.rows.map((row) => ({
          name: row.name,
          type: row.type,
          nullable: row.nullable,
          defaultValue: row.default_value
        }))
      });
    } catch (error) {
      return Result.err(
        Errors.internal(
          `Failed to get table info for ${tableName}`,
          error instanceof Error ? error : void 0
        )
      );
    }
  }
  /**
   * List tables in schema
   */
  async listTables() {
    try {
      let sql;
      switch (this.config.databaseType) {
        case "postgres":
          sql = `
						SELECT table_name
						FROM information_schema.tables
						WHERE table_schema = $1
						ORDER BY table_name
					`;
          break;
        case "mysql":
        case "mariadb":
          sql = `
						SELECT TABLE_NAME as table_name
						FROM information_schema.tables
						WHERE TABLE_SCHEMA = ?
						ORDER BY TABLE_NAME
					`;
          break;
      }
      const params = [this.schema || "public"];
      const result = await this.query(sql, params);
      if (!result.success) {
        return Result.err(result.error);
      }
      return Result.ok(result.value.rows.map((row) => row.table_name));
    } catch (error) {
      return Result.err(
        Errors.internal("Failed to list tables", error instanceof Error ? error : void 0)
      );
    }
  }
  /**
   * Check if a query is a write operation
   */
  isWriteQuery(sql) {
    const upperSQL = sql.trim().toUpperCase();
    return /^(INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|TRUNCATE|REPLACE)/i.test(upperSQL);
  }
  /**
   * Convert named parameters to positional parameters
   */
  convertNamedParams(sql, params) {
    const orderedParams = [];
    let paramIndex = 1;
    const convertedSql = sql.replace(/:(\w+)/g, (match, paramName) => {
      if (!(paramName in params)) {
        throw new Error(`Missing parameter: ${paramName}`);
      }
      orderedParams.push(params[paramName]);
      switch (this.config.databaseType) {
        case "postgres":
          return `$${paramIndex++}`;
        case "mysql":
        case "mariadb":
          return "?";
        default:
          return "?";
      }
    });
    return { convertedSql, orderedParams };
  }
  /**
   * Get database type
   */
  getDatabaseType() {
    return this.config.databaseType;
  }
  /**
   * Check if repository is read-only
   */
  isReadOnly() {
    return this.readOnly;
  }
}
const TTL = {
  /** Short-lived cache (5 minutes) */
  CACHE_SHORT: 300,
  /** Query result cache - analytics queries (1 hour) */
  QUERY_ANALYTICS: 3600,
  /** Query result cache - lookup queries (15 minutes) */
  QUERY_LOOKUP: 900,
  /** Query result cache - list queries (5 minutes) */
  QUERY_LIST: 300
};
class QueryCache {
  constructor(config) {
    this.stats = {
      hits: 0,
      misses: 0,
      sets: 0,
      deletes: 0,
      errors: 0
    };
    this.kv = config.kv;
    this.defaultTTL = config.defaultTTL || TTL.CACHE_SHORT;
    this.keyPrefix = config.keyPrefix || "query:";
    this.enableStats = config.enableStats !== false;
  }
  /**
   * Get cached query result
   */
  async get(sql, params, database) {
    try {
      const key = await this.generateKey(sql, params, database);
      const cached = await this.kv.get(key, "json");
      if (!cached) {
        if (this.enableStats) this.stats.misses++;
        return Result.ok(null);
      }
      const age = (Date.now() - cached.cachedAt) / 1e3;
      if (age > cached.ttl) {
        await this.delete(sql, params, database);
        if (this.enableStats) this.stats.misses++;
        return Result.ok(null);
      }
      if (this.enableStats) this.stats.hits++;
      return Result.ok(cached.result);
    } catch (error) {
      if (this.enableStats) this.stats.errors++;
      return Result.err(
        Errors.internal("Cache get failed", error instanceof Error ? error : void 0)
      );
    }
  }
  /**
   * Set cached query result
   */
  async set(sql, result, params, database, ttl) {
    try {
      const key = await this.generateKey(sql, params, database);
      const cacheTTL = ttl || this.defaultTTL;
      const entry = {
        result,
        cachedAt: Date.now(),
        ttl: cacheTTL,
        metadata: {
          sql: sql.substring(0, 200),
          // Truncate for storage
          database,
          paramCount: params?.length || 0
        }
      };
      await this.kv.put(key, JSON.stringify(entry), {
        expirationTtl: cacheTTL
      });
      if (this.enableStats) this.stats.sets++;
      return Result.ok(void 0);
    } catch (error) {
      if (this.enableStats) this.stats.errors++;
      return Result.err(
        Errors.internal("Cache set failed", error instanceof Error ? error : void 0)
      );
    }
  }
  /**
   * Delete cached query result
   */
  async delete(sql, params, database) {
    try {
      const key = await this.generateKey(sql, params, database);
      await this.kv.delete(key);
      if (this.enableStats) this.stats.deletes++;
      return Result.ok(void 0);
    } catch (error) {
      if (this.enableStats) this.stats.errors++;
      return Result.err(
        Errors.internal("Cache delete failed", error instanceof Error ? error : void 0)
      );
    }
  }
  /**
   * Clear all cached queries for a database
   */
  async clearDatabase(database) {
    try {
      const prefix = `${this.keyPrefix}${database}:`;
      const list = await this.kv.list({ prefix });
      let deleted = 0;
      for (const key of list.keys) {
        await this.kv.delete(key.name);
        deleted++;
      }
      if (this.enableStats) this.stats.deletes += deleted;
      return Result.ok(deleted);
    } catch (error) {
      if (this.enableStats) this.stats.errors++;
      return Result.err(
        Errors.internal("Cache clear failed", error instanceof Error ? error : void 0)
      );
    }
  }
  /**
   * Clear all cached queries
   */
  async clearAll() {
    try {
      const list = await this.kv.list({ prefix: this.keyPrefix });
      let deleted = 0;
      for (const key of list.keys) {
        await this.kv.delete(key.name);
        deleted++;
      }
      if (this.enableStats) this.stats.deletes += deleted;
      return Result.ok(deleted);
    } catch (error) {
      if (this.enableStats) this.stats.errors++;
      return Result.err(
        Errors.internal("Cache clear all failed", error instanceof Error ? error : void 0)
      );
    }
  }
  /**
   * Get cache statistics
   */
  getStats() {
    const total = this.stats.hits + this.stats.misses;
    return {
      ...this.stats,
      hitRate: total > 0 ? this.stats.hits / total : 0
    };
  }
  /**
   * Reset cache statistics
   */
  resetStats() {
    this.stats = {
      hits: 0,
      misses: 0,
      sets: 0,
      deletes: 0,
      errors: 0
    };
  }
  /**
   * Generate cache key from query, params, and database
   */
  async generateKey(sql, params, database) {
    const normalizedSQL = sql.trim().replace(/\s+/g, " ").toLowerCase();
    const components = [database || "default", normalizedSQL];
    if (params && params.length > 0) {
      const paramString = JSON.stringify(params);
      components.push(paramString);
    }
    const hash = await this.sha256Hash(components.join("|"));
    return `${this.keyPrefix}${hash}`;
  }
  /**
   * Cryptographically secure SHA-256 hash function
   * Uses Web Crypto API for secure, collision-resistant hashing
   */
  async sha256Hash(str) {
    const encoder2 = new TextEncoder();
    const data = encoder2.encode(str);
    const hashBuffer = await crypto.subtle.digest("SHA-256", data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
    return hashHex.substring(0, 16);
  }
  /**
   * Check if caching is enabled for a query
   * Certain query types should not be cached (writes, transactions, etc.)
   */
  static shouldCache(sql) {
    const upperSQL = sql.trim().toUpperCase();
    if (/^(INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|TRUNCATE|REPLACE)/i.test(upperSQL)) {
      return false;
    }
    if (/^(BEGIN|COMMIT|ROLLBACK|START TRANSACTION)/i.test(upperSQL)) {
      return false;
    }
    if (/\b(NOW|CURRENT_TIMESTAMP|RANDOM|UUID|NEWID)\b/i.test(upperSQL)) {
      return false;
    }
    return true;
  }
  /**
   * Get recommended TTL based on query type
   */
  static getRecommendedTTL(sql) {
    const upperSQL = sql.trim().toUpperCase();
    if (/\b(COUNT|SUM|AVG|GROUP BY|AGGREGATE)\b/i.test(upperSQL)) {
      return TTL.QUERY_ANALYTICS;
    }
    if (/\bWHERE\s+\w+\s*=\s*[$?:\d]/i.test(upperSQL)) {
      return TTL.QUERY_LOOKUP;
    }
    if (/\bSELECT\b/i.test(upperSQL)) {
      return TTL.QUERY_LIST;
    }
    return TTL.QUERY_LIST;
  }
}
class StorageAgent extends BaseAgent {
  constructor(config, repository) {
    super(config);
    this.repository = repository;
    const cfg = config.config;
    this.storageConfig = {
      backend: cfg?.backend,
      operation: cfg?.operation,
      binding: cfg?.binding,
      ttl: cfg?.ttl
    };
    if (!this.storageConfig.backend) {
      throw new Error(`Storage agent "${config.name}" requires backend type (kv, r2, or cache)`);
    }
    if (!this.storageConfig.operation) {
      throw new Error(`Storage agent "${config.name}" requires operation type`);
    }
  }
  /**
   * Execute storage operation via repository
   */
  async run(context) {
    const { input, env } = context;
    const repo = this.repository || this.createRepository(env);
    switch (this.storageConfig.operation) {
      case "get":
        return await this.executeGet(repo, input);
      case "put":
        return await this.executePut(repo, input);
      case "delete":
        return await this.executeDelete(repo, input);
      case "list":
        return await this.executeList(repo, input);
      default:
        throw new Error(`Unknown operation: ${this.storageConfig.operation}`);
    }
  }
  /**
   * Execute GET operation
   */
  async executeGet(repo, input) {
    if (!input.key) {
      throw new Error('GET operation requires "key" in input');
    }
    const result = await repo.get(input.key);
    if (result.success) {
      return {
        key: input.key,
        value: result.value,
        found: true
      };
    } else {
      return {
        key: input.key,
        value: null,
        found: false,
        error: result.error.message
      };
    }
  }
  /**
   * Execute PUT operation
   */
  async executePut(repo, input) {
    if (!input.key || input.value === void 0) {
      throw new Error('PUT operation requires "key" and "value" in input');
    }
    const result = await repo.put(input.key, input.value, {
      ttl: input.ttl || this.storageConfig.ttl
    });
    if (result.success) {
      return {
        key: input.key,
        success: true
      };
    } else {
      return {
        key: input.key,
        success: false,
        error: result.error.message
      };
    }
  }
  /**
   * Execute DELETE operation
   */
  async executeDelete(repo, input) {
    if (!input.key) {
      throw new Error('DELETE operation requires "key" in input');
    }
    const result = await repo.delete(input.key);
    if (result.success) {
      return {
        key: input.key,
        success: true
      };
    } else {
      return {
        key: input.key,
        success: false,
        error: result.error.message
      };
    }
  }
  /**
   * Execute LIST operation
   */
  async executeList(repo, input) {
    const result = await repo.list({
      prefix: input.prefix,
      limit: input.limit,
      cursor: input.cursor
    });
    if (result.success) {
      return {
        items: result.value,
        success: true
      };
    } else {
      return {
        items: [],
        success: false,
        error: result.error.message
      };
    }
  }
  /**
   * Create repository from environment bindings
   * Falls back to original behavior if no repository injected
   */
  createRepository(env) {
    const bindingName = this.getBindingName();
    const binding = env[bindingName];
    if (!binding) {
      throw new Error(
        `Binding "${bindingName}" not found. Add it to wrangler.toml or inject a repository in constructor.`
      );
    }
    switch (this.storageConfig.backend) {
      case StorageType.KV:
        return new KVRepository(binding, new JSONSerializer());
      case StorageType.R2:
        return new R2Repository(binding, new JSONSerializer());
      case StorageType.Cache:
        throw new Error("Cache API repository not yet implemented");
      default:
        throw new Error(`Unknown storage backend: ${this.storageConfig.backend}`);
    }
  }
  /**
   * Get binding name with sensible defaults
   */
  getBindingName() {
    if (this.storageConfig.binding) {
      return this.storageConfig.binding;
    }
    switch (this.storageConfig.backend) {
      case StorageType.KV:
        return "CACHE";
      case StorageType.R2:
        return "STORAGE";
      case StorageType.Cache:
        return "CACHE_API";
      default:
        return "STORAGE";
    }
  }
  /**
   * Get Storage configuration
   */
  getStorageConfig() {
    return { ...this.storageConfig };
  }
}
async function exportData(data, options) {
  switch (options.format) {
    case "csv":
      return exportToCSV(data, options);
    case "json":
      return exportToJSON(data, options);
    case "ndjson":
      return exportToNDJSON(data);
    case "xlsx":
      return exportToExcel(data, options);
    default:
      throw new Error(`Unsupported export format: ${options.format}`);
  }
}
function exportToCSV(data, options) {
  const delimiter = options.delimiter || ",";
  const includeHeaders = options.headers !== false;
  if (data.length === 0) {
    return {
      data: "",
      contentType: "text/csv",
      extension: "csv",
      size: 0,
      streaming: false
    };
  }
  const fields = options.fields || Object.keys(data[0]);
  const lines = [];
  if (includeHeaders) {
    lines.push(fields.map((f) => escapeCsvValue(f, delimiter)).join(delimiter));
  }
  for (const row of data) {
    const rowData = row;
    const values = fields.map((field) => {
      const value = rowData[field];
      return escapeCsvValue(String(value ?? ""), delimiter);
    });
    lines.push(values.join(delimiter));
  }
  const csv = lines.join("\n");
  return {
    data: csv,
    contentType: "text/csv",
    extension: "csv",
    size: new Blob([csv]).size,
    streaming: false
  };
}
function exportToJSON(data, options) {
  const json2 = options.pretty ? JSON.stringify(data, null, 2) : JSON.stringify(data);
  return {
    data: json2,
    contentType: "application/json",
    extension: "json",
    size: new Blob([json2]).size,
    streaming: false
  };
}
function exportToNDJSON(data, options) {
  const lines = data.map((item) => JSON.stringify(item));
  const ndjson = lines.join("\n");
  return {
    data: ndjson,
    contentType: "application/x-ndjson",
    extension: "ndjson",
    size: new Blob([ndjson]).size,
    streaming: false
  };
}
function exportToExcel(data, options) {
  const csv = exportToCSV(data, options);
  return {
    ...csv,
    contentType: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    extension: "xlsx"
  };
}
function escapeCsvValue(value, delimiter) {
  if (value.includes(delimiter) || value.includes("\n") || value.includes('"')) {
    return `"${value.replace(/"/g, '""')}"`;
  }
  return value;
}
function createStreamingExport(dataSource, options) {
  let isFirst = true;
  let fields = [];
  const stream = new ReadableStream({
    async start(controller) {
      const encoder2 = new TextEncoder();
      try {
        for await (const batch of dataSource) {
          if (batch.length === 0) continue;
          if (isFirst) {
            fields = options.fields || Object.keys(batch[0]);
            if (options.format === "csv" && options.headers !== false) {
              const delimiter = options.delimiter || ",";
              const headerLine = fields.map((f) => escapeCsvValue(f, delimiter)).join(delimiter) + "\n";
              controller.enqueue(encoder2.encode(headerLine));
            }
            if (options.format === "json") {
              controller.enqueue(encoder2.encode("[\n"));
            }
            isFirst = false;
          }
          const chunk = formatBatch(batch, fields, options, isFirst);
          controller.enqueue(encoder2.encode(chunk));
        }
        if (options.format === "json") {
          controller.enqueue(encoder2.encode("\n]"));
        }
        controller.close();
      } catch (error) {
        controller.error(error);
      }
    }
  });
  return {
    data: stream,
    contentType: getContentType(options.format),
    extension: getExtension(options.format),
    streaming: true
  };
}
function formatBatch(batch, fields, options, isFirst) {
  switch (options.format) {
    case "csv":
      return formatCsvBatch(batch, fields, options.delimiter || ",");
    case "json":
      return formatJsonBatch(batch, isFirst);
    case "ndjson":
      return formatNdjsonBatch(batch);
    default:
      return "";
  }
}
function formatCsvBatch(batch, fields, delimiter) {
  const lines = [];
  for (const row of batch) {
    const rowData = row;
    const values = fields.map((field) => {
      const value = rowData[field];
      return escapeCsvValue(String(value ?? ""), delimiter);
    });
    lines.push(values.join(delimiter));
  }
  return lines.join("\n") + "\n";
}
function formatJsonBatch(batch, isFirst) {
  const items = batch.map((item, index) => {
    const json2 = JSON.stringify(item, null, 2);
    const prefix = isFirst && index === 0 ? "  " : ",\n  ";
    return prefix + json2;
  });
  return items.join("");
}
function formatNdjsonBatch(batch) {
  return batch.map((item) => JSON.stringify(item)).join("\n") + "\n";
}
function getContentType(format2) {
  switch (format2) {
    case "csv":
      return "text/csv";
    case "json":
      return "application/json";
    case "ndjson":
      return "application/x-ndjson";
    case "xlsx":
      return "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
    default:
      return "application/octet-stream";
  }
}
function getExtension(format2) {
  switch (format2) {
    case "csv":
      return "csv";
    case "json":
      return "json";
    case "ndjson":
      return "ndjson";
    case "xlsx":
      return "xlsx";
    default:
      return "bin";
  }
}
class DataAgent extends BaseAgent {
  constructor(config, repository) {
    super(config);
    this.repository = repository;
    const cfg = config.config;
    this.dataConfig = {
      database: cfg?.database,
      operation: cfg?.operation,
      binding: cfg?.binding,
      tableName: cfg?.tableName,
      // Hyperdrive options
      databaseType: cfg?.databaseType,
      schema: cfg?.schema,
      readOnly: cfg?.readOnly,
      // Export options
      exportFormat: cfg?.exportFormat,
      exportOptions: cfg?.exportOptions
    };
    if (!this.dataConfig.database) {
      throw new Error(
        `Data agent "${config.name}" requires database type (d1, hyperdrive, vectorize, etc.)`
      );
    }
    if (!this.dataConfig.operation) {
      throw new Error(`Data agent "${config.name}" requires operation type`);
    }
  }
  /**
   * Execute data operation via repository
   */
  async run(context) {
    const { input, env } = context;
    if (this.dataConfig.database === DatabaseType.Hyperdrive) {
      return await this.executeHyperdriveOperation(env, input);
    }
    const repo = this.repository || this.createRepository(env);
    switch (this.dataConfig.operation) {
      case "get":
        return await this.executeGet(repo, input);
      case "put":
        return await this.executePut(repo, input);
      case "delete":
        return await this.executeDelete(repo, input);
      case "list":
        return await this.executeList(repo, input);
      case "query":
        return await this.executeQuery(repo, input);
      case "export":
        return await this.executeExport(repo, input);
      default:
        throw new Error(`Unknown operation: ${this.dataConfig.operation}`);
    }
  }
  /**
   * Execute Hyperdrive operation (SQL-native)
   */
  async executeHyperdriveOperation(env, input) {
    if (!this.hyperdriveRepo) {
      this.hyperdriveRepo = this.createHyperdriveRepository(env);
    }
    switch (this.dataConfig.operation) {
      case "query": {
        if (!input.query) {
          return {
            success: false,
            error: "SQL query is required for Hyperdrive query operation"
          };
        }
        const result = await this.hyperdriveRepo.query(input.query, input.params);
        if (result.success) {
          return {
            rows: result.value.rows,
            metadata: result.value.metadata,
            success: true
          };
        } else {
          return {
            rows: [],
            success: false,
            error: result.error.message
          };
        }
      }
      case "get": {
        if (!input.key) {
          return { value: null, success: false, error: "Key is required for get operation" };
        }
        const tableName = this.dataConfig.tableName || "data";
        const sql = this.dataConfig.databaseType === "postgres" ? `SELECT * FROM ${tableName} WHERE id = $1 LIMIT 1` : `SELECT * FROM ${tableName} WHERE id = ? LIMIT 1`;
        const result = await this.hyperdriveRepo.query(sql, [input.key]);
        if (result.success && result.value.rows.length > 0) {
          return { value: result.value.rows[0], found: true, success: true };
        }
        return { value: null, found: false, success: true };
      }
      case "put": {
        if (!input.key || input.value === void 0) {
          return { success: false, error: "Key and value are required for put operation" };
        }
        const tableName = this.dataConfig.tableName || "data";
        const valueJson = JSON.stringify(input.value);
        let sql;
        if (this.dataConfig.databaseType === "postgres") {
          sql = `INSERT INTO ${tableName} (id, value) VALUES ($1, $2)
                 ON CONFLICT (id) DO UPDATE SET value = $2`;
        } else {
          sql = `INSERT INTO ${tableName} (id, value) VALUES (?, ?)
                 ON DUPLICATE KEY UPDATE value = VALUES(value)`;
        }
        const result = await this.hyperdriveRepo.execute(sql, [input.key, valueJson]);
        return result.success ? { success: true, rowsAffected: result.value.rowsAffected } : { success: false, error: result.error.message };
      }
      case "delete": {
        if (!input.key) {
          return { success: false, error: "Key is required for delete operation" };
        }
        const tableName = this.dataConfig.tableName || "data";
        const sql = this.dataConfig.databaseType === "postgres" ? `DELETE FROM ${tableName} WHERE id = $1` : `DELETE FROM ${tableName} WHERE id = ?`;
        const result = await this.hyperdriveRepo.execute(sql, [input.key]);
        return result.success ? { success: true, rowsAffected: result.value.rowsAffected } : { success: false, error: result.error.message };
      }
      case "list": {
        const tableName = this.dataConfig.tableName || "data";
        const limit2 = input.limit || 100;
        const sql = this.dataConfig.databaseType === "postgres" ? `SELECT * FROM ${tableName} LIMIT $1` : `SELECT * FROM ${tableName} LIMIT ?`;
        const result = await this.hyperdriveRepo.query(sql, [limit2]);
        return result.success ? { items: result.value.rows, count: result.value.rows.length, success: true } : { items: [], success: false, error: result.error.message };
      }
      default:
        return {
          success: false,
          error: `Operation ${this.dataConfig.operation} not supported for Hyperdrive`
        };
    }
  }
  /**
   * Create Hyperdrive repository from environment bindings
   */
  createHyperdriveRepository(env) {
    const bindingName = this.getBindingName();
    const binding = env[bindingName];
    if (!binding) {
      throw new Error(
        `Hyperdrive binding "${bindingName}" not found. Add [[hyperdrive]] to wrangler.toml with binding = "${bindingName}".`
      );
    }
    const config = {
      databaseType: this.dataConfig.databaseType || "postgres",
      schema: this.dataConfig.schema,
      options: {
        readOnly: this.dataConfig.readOnly
      }
    };
    return new HyperdriveRepository(binding, config);
  }
  /**
   * Execute GET operation
   */
  async executeGet(repo, input) {
    if (!input.key) {
      throw new Error('GET operation requires "key" in input');
    }
    const result = await repo.get(input.key);
    if (result.success) {
      return {
        key: input.key,
        value: result.value,
        found: true
      };
    } else {
      return {
        key: input.key,
        value: null,
        found: false,
        error: result.error.message
      };
    }
  }
  /**
   * Execute PUT operation
   */
  async executePut(repo, input) {
    if (!input.key || input.value === void 0) {
      throw new Error('PUT operation requires "key" and "value" in input');
    }
    const result = await repo.put(input.key, input.value);
    if (result.success) {
      return {
        key: input.key,
        success: true
      };
    } else {
      return {
        key: input.key,
        success: false,
        error: result.error.message
      };
    }
  }
  /**
   * Execute DELETE operation
   */
  async executeDelete(repo, input) {
    if (!input.key) {
      throw new Error('DELETE operation requires "key" in input');
    }
    const result = await repo.delete(input.key);
    if (result.success) {
      return {
        key: input.key,
        success: true
      };
    } else {
      return {
        key: input.key,
        success: false,
        error: result.error.message
      };
    }
  }
  /**
   * Execute LIST operation
   */
  async executeList(repo, input) {
    const result = await repo.list({
      prefix: input.prefix,
      limit: input.limit,
      cursor: input.cursor
    });
    if (result.success) {
      return {
        items: result.value,
        success: true
      };
    } else {
      return {
        items: [],
        success: false,
        error: result.error.message
      };
    }
  }
  /**
   * Create repository from environment bindings
   * Falls back to original behavior if no repository injected
   */
  createRepository(env) {
    const bindingName = this.getBindingName();
    const binding = env[bindingName];
    if (!binding) {
      throw new Error(
        `Binding "${bindingName}" not found. Add it to wrangler.toml or inject a repository in constructor.`
      );
    }
    switch (this.dataConfig.database) {
      case DatabaseType.D1:
        return new D1Repository(
          binding,
          {
            tableName: this.dataConfig.tableName || "data",
            idColumn: "key",
            valueColumn: "value"
          },
          new JSONSerializer()
        );
      case DatabaseType.Hyperdrive:
        throw new Error("Hyperdrive uses SQL-native operations, not Repository pattern");
      case DatabaseType.Vectorize:
        throw new Error(
          "Vectorize is not supported via the data agent. Use the RAG agent (operation: rag) for vector operations."
        );
      case DatabaseType.Supabase:
      case DatabaseType.Neon:
      case DatabaseType.PlanetScale:
        throw new Error(`${this.dataConfig.database} repository not yet implemented`);
      default:
        throw new Error(`Unknown database type: ${this.dataConfig.database}`);
    }
  }
  /**
   * Get binding name with sensible defaults
   */
  getBindingName() {
    if (this.dataConfig.binding) {
      return this.dataConfig.binding;
    }
    switch (this.dataConfig.database) {
      case DatabaseType.D1:
        return "DB";
      case DatabaseType.Hyperdrive:
        return "HYPERDRIVE";
      case DatabaseType.Vectorize:
        return "VECTORIZE";
      case DatabaseType.Supabase:
        return "SUPABASE_URL";
      case DatabaseType.Neon:
        return "NEON_URL";
      case DatabaseType.PlanetScale:
        return "PLANETSCALE_URL";
      default:
        return "DATABASE";
    }
  }
  /**
   * Execute QUERY operation (D1 only)
   */
  async executeQuery(repo, input) {
    const listResult = await repo.list({
      prefix: input.prefix,
      limit: input.limit,
      cursor: input.cursor
    });
    if (!listResult.success) {
      return {
        items: [],
        success: false,
        error: listResult.error.message
      };
    }
    let items = listResult.value;
    if (input.filter) {
      items = items.filter((item) => {
        return Object.entries(input.filter).every(([key, value]) => {
          return item[key] === value;
        });
      });
    }
    if (input.sort) {
      const [field, order = "asc"] = input.sort.split(":");
      items = items.sort((a, b) => {
        const aVal = a[field];
        const bVal = b[field];
        if (order === "desc") {
          return bVal > aVal ? 1 : bVal < aVal ? -1 : 0;
        }
        return aVal > bVal ? 1 : aVal < bVal ? -1 : 0;
      });
    }
    return {
      items,
      count: items.length,
      success: true
    };
  }
  /**
   * Execute EXPORT operation
   */
  async executeExport(repo, input) {
    const listResult = await repo.list({
      prefix: input.prefix,
      limit: input.limit || 1e4,
      // Default to large limit for exports
      cursor: input.cursor
    });
    if (!listResult.success) {
      return {
        success: false,
        error: listResult.error.message
      };
    }
    let items = listResult.value;
    if (input.filter) {
      items = items.filter((item) => {
        return Object.entries(input.filter).every(([key, value]) => {
          return item[key] === value;
        });
      });
    }
    const exportOptions = {
      format: input.format || this.dataConfig.exportFormat || "json",
      ...this.dataConfig.exportOptions,
      ...input.exportOptions
    };
    if (input.streaming || items.length > 1e3) {
      async function* dataSource() {
        const batchSize = exportOptions.batchSize || 100;
        for (let i = 0; i < items.length; i += batchSize) {
          yield items.slice(i, i + batchSize);
        }
      }
      const exportResult2 = createStreamingExport(dataSource(), exportOptions);
      return {
        success: true,
        streaming: true,
        stream: exportResult2.data,
        contentType: exportResult2.contentType,
        extension: exportResult2.extension,
        count: items.length
      };
    }
    const exportResult = await exportData(items, exportOptions);
    return {
      success: true,
      streaming: false,
      data: exportResult.data,
      contentType: exportResult.contentType,
      extension: exportResult.extension,
      size: exportResult.size,
      count: items.length
    };
  }
  /**
   * Get Data configuration
   */
  getDataConfig() {
    return { ...this.dataConfig };
  }
}
class APIAgent extends BaseAgent {
  constructor(config) {
    super(config);
    const cfg = config.config;
    this.apiConfig = {
      url: cfg?.url,
      method: cfg?.method || "GET",
      headers: cfg?.headers || {},
      timeout: cfg?.timeout || 3e4,
      retries: cfg?.retries || 0
    };
  }
  /**
   * Execute the API request
   */
  async run(context) {
    const { input } = context;
    const url = this.apiConfig.url || input.url;
    if (!url) {
      throw new Error(`API agent "${this.name}" requires a URL (in config or input)`);
    }
    const requestInit = {
      method: this.apiConfig.method,
      headers: this.resolveHeaders(this.apiConfig.headers || {}, context)
    };
    if (["POST", "PUT", "PATCH"].includes(this.apiConfig.method)) {
      if (input.body) {
        requestInit.body = typeof input.body === "string" ? input.body : JSON.stringify(input.body);
        const headers = requestInit.headers;
        if (!headers["content-type"] && !headers["Content-Type"]) {
          headers["content-type"] = "application/json";
        }
      }
    }
    return await this.executeWithRetries(url, requestInit);
  }
  /**
   * Resolve headers (may contain env var references)
   */
  resolveHeaders(headers, context) {
    const resolved = {};
    for (const [key, value] of Object.entries(headers)) {
      resolved[key] = value.replace(/\$\{env\.(\w+)\}/g, (_, varName) => {
        return context.env[varName] || "";
      });
    }
    return resolved;
  }
  /**
   * Execute request with timeout and retry logic
   */
  async executeWithRetries(url, init, attempt = 0) {
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), this.apiConfig.timeout);
      try {
        const response = await fetch(url, {
          ...init,
          signal: controller.signal
        });
        clearTimeout(timeoutId);
        const contentType = response.headers.get("content-type");
        let data;
        if (contentType?.includes("application/json")) {
          data = await response.json();
        } else {
          data = await response.text();
        }
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        return {
          status: response.status,
          headers: Object.fromEntries(response.headers.entries()),
          data
        };
      } finally {
        clearTimeout(timeoutId);
      }
    } catch (error) {
      if (attempt < (this.apiConfig.retries || 0)) {
        const delay = Math.min(1e3 * Math.pow(2, attempt), 1e4);
        await new Promise((resolve2) => setTimeout(resolve2, delay));
        return this.executeWithRetries(url, init, attempt + 1);
      }
      throw new Error(
        `API request to ${url} failed after ${attempt + 1} attempts: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  }
  /**
   * Get API configuration
   */
  getAPIConfig() {
    return { ...this.apiConfig };
  }
}
class BaseEmailProvider {
  /**
   * Normalize recipients to array
   */
  normalizeRecipients(recipients) {
    return Array.isArray(recipients) ? recipients : [recipients];
  }
  /**
   * Validate email address format
   */
  validateEmail(email) {
    const emailRegex2 = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex2.test(email);
  }
  /**
   * Validate required fields
   */
  validateMessage(message2) {
    const errors = [];
    if (!message2.to || Array.isArray(message2.to) && message2.to.length === 0) {
      errors.push("Recipient (to) is required");
    }
    if (!message2.subject || message2.subject.trim() === "") {
      errors.push("Subject is required");
    }
    if (!message2.html && !message2.text) {
      errors.push("Either html or text content is required");
    }
    const recipients = this.normalizeRecipients(message2.to);
    for (const email of recipients) {
      if (!this.validateEmail(email)) {
        errors.push(`Invalid email address: ${email}`);
      }
    }
    return {
      valid: errors.length === 0,
      errors: errors.length > 0 ? errors : void 0
    };
  }
}
class CloudflareEmailProvider extends BaseEmailProvider {
  constructor(binding, defaultFrom, enableDkim = true) {
    super();
    this.binding = binding;
    this.defaultFrom = defaultFrom;
    this.enableDkim = enableDkim;
    this.name = "cloudflare";
  }
  /**
   * Send email via Cloudflare Email Workers
   */
  async send(message2) {
    const validation = this.validateMessage(message2);
    if (!validation.valid) {
      return {
        messageId: "",
        status: "failed",
        provider: this.name,
        error: validation.errors?.join(", ")
      };
    }
    try {
      const request = {
        from: message2.from || this.defaultFrom,
        to: message2.to,
        subject: message2.subject,
        html: message2.html,
        text: message2.text,
        headers: message2.headers
      };
      if (this.enableDkim && request.headers) {
        request.headers["X-Cloudflare-DKIM"] = "enabled";
      }
      const response = await this.binding.send(request);
      if (!response.success) {
        return {
          messageId: "",
          status: "failed",
          provider: this.name,
          error: response.error || "Unknown error"
        };
      }
      return {
        messageId: response.messageId || `cf-${Date.now()}`,
        status: "sent",
        provider: this.name
      };
    } catch (error) {
      return {
        messageId: "",
        status: "failed",
        provider: this.name,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  /**
   * Validate configuration
   */
  async validateConfig() {
    const errors = [];
    if (!this.binding) {
      errors.push("Cloudflare Email binding is not configured");
    }
    if (!this.defaultFrom) {
      errors.push("Default from address is required");
    } else if (!this.validateEmail(this.defaultFrom)) {
      errors.push("Default from address is invalid");
    }
    return {
      valid: errors.length === 0,
      errors: errors.length > 0 ? errors : void 0
    };
  }
}
class ResendProvider extends BaseEmailProvider {
  constructor(apiKey, defaultFrom) {
    super();
    this.apiKey = apiKey;
    this.defaultFrom = defaultFrom;
    this.name = "resend";
    this.apiUrl = "https://api.resend.com/emails";
  }
  /**
   * Send email via Resend API
   */
  async send(message2) {
    const validation = this.validateMessage(message2);
    if (!validation.valid) {
      return {
        messageId: "",
        status: "failed",
        provider: this.name,
        error: validation.errors?.join(", ")
      };
    }
    try {
      const request = {
        from: message2.from || this.defaultFrom,
        to: message2.to,
        subject: message2.subject,
        html: message2.html,
        text: message2.text
      };
      if (message2.cc) request.cc = message2.cc;
      if (message2.bcc) request.bcc = message2.bcc;
      if (message2.replyTo) request.reply_to = message2.replyTo;
      if (message2.headers) request.headers = message2.headers;
      if (message2.attachments) {
        request.attachments = message2.attachments.map((att) => ({
          filename: att.filename,
          content: typeof att.content === "string" ? att.content : att.content.toString("base64")
        }));
      }
      if (message2.tags) {
        request.tags = message2.tags.map((tag2) => ({
          name: tag2,
          value: "true"
        }));
      }
      const response = await fetch(this.apiUrl, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${this.apiKey}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify(request)
      });
      const data = await response.json();
      if (!response.ok || data.error) {
        return {
          messageId: "",
          status: "failed",
          provider: this.name,
          error: data.error?.message || `HTTP ${response.status}`
        };
      }
      return {
        messageId: data.id,
        status: "sent",
        provider: this.name
      };
    } catch (error) {
      return {
        messageId: "",
        status: "failed",
        provider: this.name,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  /**
   * Validate configuration
   */
  async validateConfig() {
    const errors = [];
    if (!this.apiKey) {
      errors.push("Resend API key is required");
    }
    if (!this.defaultFrom) {
      errors.push("Default from address is required");
    } else if (!this.validateEmail(this.defaultFrom)) {
      errors.push("Default from address is invalid");
    }
    return {
      valid: errors.length === 0,
      errors: errors.length > 0 ? errors : void 0
    };
  }
}
class SmtpProvider extends BaseEmailProvider {
  constructor(config, defaultFrom) {
    super();
    this.config = config;
    this.defaultFrom = defaultFrom;
    this.name = "smtp";
  }
  /**
   * Send email via SMTP
   */
  async send(message2) {
    const validation = this.validateMessage(message2);
    if (!validation.valid) {
      return {
        messageId: "",
        status: "failed",
        provider: this.name,
        error: validation.errors?.join(", ")
      };
    }
    try {
      const from = message2.from || this.defaultFrom;
      const to = this.normalizeRecipients(message2.to);
      const messageId = `<${Date.now()}.${Math.random().toString(36)}@${from.split("@")[1]}>`;
      const headers = [
        `Message-ID: ${messageId}`,
        `From: ${from}`,
        `To: ${to.join(", ")}`,
        `Subject: ${message2.subject}`,
        `Date: ${(/* @__PURE__ */ new Date()).toUTCString()}`,
        "MIME-Version: 1.0"
      ];
      if (message2.cc) {
        headers.push(`Cc: ${this.normalizeRecipients(message2.cc).join(", ")}`);
      }
      if (message2.bcc) {
        headers.push(`Bcc: ${this.normalizeRecipients(message2.bcc).join(", ")}`);
      }
      if (message2.replyTo) {
        headers.push(`Reply-To: ${message2.replyTo}`);
      }
      if (message2.headers) {
        for (const [key, value] of Object.entries(message2.headers)) {
          headers.push(`${key}: ${value}`);
        }
      }
      let body = "";
      if (message2.html && message2.text) {
        const boundary = `boundary_${Date.now()}_${Math.random().toString(36)}`;
        headers.push(`Content-Type: multipart/alternative; boundary="${boundary}"`);
        body = [
          "",
          `--${boundary}`,
          "Content-Type: text/plain; charset=utf-8",
          "Content-Transfer-Encoding: quoted-printable",
          "",
          this.encodeQuotedPrintable(message2.text),
          "",
          `--${boundary}`,
          "Content-Type: text/html; charset=utf-8",
          "Content-Transfer-Encoding: quoted-printable",
          "",
          this.encodeQuotedPrintable(message2.html),
          "",
          `--${boundary}--`
        ].join("\r\n");
      } else if (message2.html) {
        headers.push("Content-Type: text/html; charset=utf-8");
        headers.push("Content-Transfer-Encoding: quoted-printable");
        body = "\r\n" + this.encodeQuotedPrintable(message2.html);
      } else if (message2.text) {
        headers.push("Content-Type: text/plain; charset=utf-8");
        headers.push("Content-Transfer-Encoding: quoted-printable");
        body = "\r\n" + this.encodeQuotedPrintable(message2.text);
      }
      const response = await this.sendSmtp(from, to, headers.join("\r\n") + body);
      if (!response.success) {
        return {
          messageId: "",
          status: "failed",
          provider: this.name,
          error: response.error || "SMTP send failed"
        };
      }
      return {
        messageId: messageId.slice(1, -1),
        // Remove < >
        status: "sent",
        provider: this.name
      };
    } catch (error) {
      return {
        messageId: "",
        status: "failed",
        provider: this.name,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  /**
   * Validate configuration
   */
  async validateConfig() {
    const errors = [];
    if (!this.config.host) {
      errors.push("SMTP host is required");
    }
    if (!this.config.port || this.config.port < 1 || this.config.port > 65535) {
      errors.push("Valid SMTP port is required (1-65535)");
    }
    if (!this.config.auth?.user) {
      errors.push("SMTP username is required");
    }
    if (!this.config.auth?.pass) {
      errors.push("SMTP password is required");
    }
    if (!this.defaultFrom) {
      errors.push("Default from address is required");
    } else if (!this.validateEmail(this.defaultFrom)) {
      errors.push("Default from address is invalid");
    }
    return {
      valid: errors.length === 0,
      errors: errors.length > 0 ? errors : void 0
    };
  }
  /**
   * Send email via SMTP protocol
   */
  async sendSmtp(from, to, message2) {
    try {
      const protocol = this.config.secure ? "smtps" : "smtp";
      const url = `${protocol}://${this.config.host}:${this.config.port}`;
      const response = await fetch(url, {
        method: "POST",
        headers: {
          "Content-Type": "message/rfc822",
          Authorization: `Basic ${btoa(`${this.config.auth.user}:${this.config.auth.pass}`)}`
        },
        body: `MAIL FROM:<${from}>\r
RCPT TO:<${to.join(">,<")}>\r
DATA\r
${message2}\r
.\r
`
      });
      if (!response.ok) {
        return {
          success: false,
          error: `SMTP error: ${response.status} ${response.statusText}`
        };
      }
      return { success: true };
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : "Unknown SMTP error"
      };
    }
  }
  /**
   * Encode string as quoted-printable
   */
  encodeQuotedPrintable(text) {
    return text.replace(/[^\x20-\x7E]/g, (char) => {
      const hex = char.charCodeAt(0).toString(16).toUpperCase();
      return "=" + (hex.length === 1 ? "0" + hex : hex);
    }).replace(/=/g, "=3D").replace(/\r\n/g, "\n").split("\n").map((line) => {
      if (line.length <= 76) return line;
      const result = [];
      for (let i = 0; i < line.length; i += 75) {
        result.push(line.slice(i, i + 75) + "=");
      }
      return result.join("\r\n");
    }).join("\r\n");
  }
}
function createEmailProvider(config) {
  const from = config.from || "noreply@example.com";
  switch (config.provider) {
    case "cloudflare":
      if (!config.cloudflare?.binding) {
        throw new Error("Cloudflare Email binding is required");
      }
      return new CloudflareEmailProvider(
        config.cloudflare.binding,
        from,
        config.cloudflare.dkim ?? true
      );
    case "resend":
      if (!config.resend?.apiKey) {
        throw new Error("Resend API key is required");
      }
      return new ResendProvider(config.resend.apiKey, from);
    case "smtp":
      if (!config.smtp) {
        throw new Error("SMTP configuration is required");
      }
      return new SmtpProvider(config.smtp, from);
    default:
      throw new Error(`Unknown email provider: ${config.provider}`);
  }
}
var handlebars_runtime$1 = { exports: {} };
var handlebars_runtime = handlebars_runtime$1.exports;
var hasRequiredHandlebars_runtime;
function requireHandlebars_runtime() {
  if (hasRequiredHandlebars_runtime) return handlebars_runtime$1.exports;
  hasRequiredHandlebars_runtime = 1;
  (function(module, exports$1) {
    (function webpackUniversalModuleDefinition(root, factory) {
      module.exports = factory();
    })(handlebars_runtime, function() {
      return (
        /******/
        (function(modules) {
          var installedModules = {};
          function __webpack_require__(moduleId) {
            if (installedModules[moduleId])
              return installedModules[moduleId].exports;
            var module2 = installedModules[moduleId] = {
              /******/
              exports: {},
              /******/
              id: moduleId,
              /******/
              loaded: false
              /******/
            };
            modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
            module2.loaded = true;
            return module2.exports;
          }
          __webpack_require__.m = modules;
          __webpack_require__.c = installedModules;
          __webpack_require__.p = "";
          return __webpack_require__(0);
        })([
          /* 0 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var _interopRequireWildcard = __webpack_require__(1)["default"];
            var _interopRequireDefault = __webpack_require__(2)["default"];
            exports$12.__esModule = true;
            var _handlebarsBase = __webpack_require__(3);
            var base = _interopRequireWildcard(_handlebarsBase);
            var _handlebarsSafeString = __webpack_require__(76);
            var _handlebarsSafeString2 = _interopRequireDefault(_handlebarsSafeString);
            var _handlebarsException = __webpack_require__(5);
            var _handlebarsException2 = _interopRequireDefault(_handlebarsException);
            var _handlebarsUtils = __webpack_require__(4);
            var Utils = _interopRequireWildcard(_handlebarsUtils);
            var _handlebarsRuntime = __webpack_require__(77);
            var runtime = _interopRequireWildcard(_handlebarsRuntime);
            var _handlebarsNoConflict = __webpack_require__(82);
            var _handlebarsNoConflict2 = _interopRequireDefault(_handlebarsNoConflict);
            function create() {
              var hb = new base.HandlebarsEnvironment();
              Utils.extend(hb, base);
              hb.SafeString = _handlebarsSafeString2["default"];
              hb.Exception = _handlebarsException2["default"];
              hb.Utils = Utils;
              hb.escapeExpression = Utils.escapeExpression;
              hb.VM = runtime;
              hb.template = function(spec) {
                return runtime.template(spec, hb);
              };
              return hb;
            }
            var inst = create();
            inst.create = create;
            _handlebarsNoConflict2["default"](inst);
            inst["default"] = inst;
            exports$12["default"] = inst;
            module2.exports = exports$12["default"];
          }),
          /* 1 */
          /***/
          (function(module2, exports$12) {
            exports$12["default"] = function(obj) {
              if (obj && obj.__esModule) {
                return obj;
              } else {
                var newObj = {};
                if (obj != null) {
                  for (var key in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
                  }
                }
                newObj["default"] = obj;
                return newObj;
              }
            };
            exports$12.__esModule = true;
          }),
          /* 2 */
          /***/
          (function(module2, exports$12) {
            exports$12["default"] = function(obj) {
              return obj && obj.__esModule ? obj : {
                "default": obj
              };
            };
            exports$12.__esModule = true;
          }),
          /* 3 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var _interopRequireDefault = __webpack_require__(2)["default"];
            exports$12.__esModule = true;
            exports$12.HandlebarsEnvironment = HandlebarsEnvironment;
            var _utils = __webpack_require__(4);
            var _exception = __webpack_require__(5);
            var _exception2 = _interopRequireDefault(_exception);
            var _helpers = __webpack_require__(9);
            var _decorators = __webpack_require__(69);
            var _logger = __webpack_require__(71);
            var _logger2 = _interopRequireDefault(_logger);
            var _internalProtoAccess = __webpack_require__(72);
            var VERSION = "4.7.8";
            exports$12.VERSION = VERSION;
            var COMPILER_REVISION = 8;
            exports$12.COMPILER_REVISION = COMPILER_REVISION;
            var LAST_COMPATIBLE_COMPILER_REVISION = 7;
            exports$12.LAST_COMPATIBLE_COMPILER_REVISION = LAST_COMPATIBLE_COMPILER_REVISION;
            var REVISION_CHANGES = {
              1: "<= 1.0.rc.2",
              // 1.0.rc.2 is actually rev2 but doesn't report it
              2: "== 1.0.0-rc.3",
              3: "== 1.0.0-rc.4",
              4: "== 1.x.x",
              5: "== 2.0.0-alpha.x",
              6: ">= 2.0.0-beta.1",
              7: ">= 4.0.0 <4.3.0",
              8: ">= 4.3.0"
            };
            exports$12.REVISION_CHANGES = REVISION_CHANGES;
            var objectType2 = "[object Object]";
            function HandlebarsEnvironment(helpers, partials, decorators) {
              this.helpers = helpers || {};
              this.partials = partials || {};
              this.decorators = decorators || {};
              _helpers.registerDefaultHelpers(this);
              _decorators.registerDefaultDecorators(this);
            }
            HandlebarsEnvironment.prototype = {
              constructor: HandlebarsEnvironment,
              logger: _logger2["default"],
              log: _logger2["default"].log,
              registerHelper: function registerHelper(name, fn) {
                if (_utils.toString.call(name) === objectType2) {
                  if (fn) {
                    throw new _exception2["default"]("Arg not supported with multiple helpers");
                  }
                  _utils.extend(this.helpers, name);
                } else {
                  this.helpers[name] = fn;
                }
              },
              unregisterHelper: function unregisterHelper(name) {
                delete this.helpers[name];
              },
              registerPartial: function registerPartial(name, partial) {
                if (_utils.toString.call(name) === objectType2) {
                  _utils.extend(this.partials, name);
                } else {
                  if (typeof partial === "undefined") {
                    throw new _exception2["default"]('Attempting to register a partial called "' + name + '" as undefined');
                  }
                  this.partials[name] = partial;
                }
              },
              unregisterPartial: function unregisterPartial(name) {
                delete this.partials[name];
              },
              registerDecorator: function registerDecorator(name, fn) {
                if (_utils.toString.call(name) === objectType2) {
                  if (fn) {
                    throw new _exception2["default"]("Arg not supported with multiple decorators");
                  }
                  _utils.extend(this.decorators, name);
                } else {
                  this.decorators[name] = fn;
                }
              },
              unregisterDecorator: function unregisterDecorator(name) {
                delete this.decorators[name];
              },
              /**
               * Reset the memory of illegal property accesses that have already been logged.
               * @deprecated should only be used in handlebars test-cases
               */
              resetLoggedPropertyAccesses: function resetLoggedPropertyAccesses() {
                _internalProtoAccess.resetLoggedProperties();
              }
            };
            var log = _logger2["default"].log;
            exports$12.log = log;
            exports$12.createFrame = _utils.createFrame;
            exports$12.logger = _logger2["default"];
          }),
          /* 4 */
          /***/
          (function(module2, exports$12) {
            exports$12.__esModule = true;
            exports$12.extend = extend;
            exports$12.indexOf = indexOf;
            exports$12.escapeExpression = escapeExpression;
            exports$12.isEmpty = isEmpty2;
            exports$12.createFrame = createFrame;
            exports$12.blockParams = blockParams;
            exports$12.appendContextPath = appendContextPath;
            var escape2 = {
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#x27;",
              "`": "&#x60;",
              "=": "&#x3D;"
            };
            var badChars = /[&<>"'`=]/g, possible = /[&<>"'`=]/;
            function escapeChar2(chr) {
              return escape2[chr];
            }
            function extend(obj) {
              for (var i = 1; i < arguments.length; i++) {
                for (var key in arguments[i]) {
                  if (Object.prototype.hasOwnProperty.call(arguments[i], key)) {
                    obj[key] = arguments[i][key];
                  }
                }
              }
              return obj;
            }
            var toString2 = Object.prototype.toString;
            exports$12.toString = toString2;
            var isFunction2 = function isFunction3(value) {
              return typeof value === "function";
            };
            if (isFunction2(/x/)) {
              exports$12.isFunction = isFunction2 = function(value) {
                return typeof value === "function" && toString2.call(value) === "[object Function]";
              };
            }
            exports$12.isFunction = isFunction2;
            var isArray2 = Array.isArray || function(value) {
              return value && typeof value === "object" ? toString2.call(value) === "[object Array]" : false;
            };
            exports$12.isArray = isArray2;
            function indexOf(array, value) {
              for (var i = 0, len = array.length; i < len; i++) {
                if (array[i] === value) {
                  return i;
                }
              }
              return -1;
            }
            function escapeExpression(string2) {
              if (typeof string2 !== "string") {
                if (string2 && string2.toHTML) {
                  return string2.toHTML();
                } else if (string2 == null) {
                  return "";
                } else if (!string2) {
                  return string2 + "";
                }
                string2 = "" + string2;
              }
              if (!possible.test(string2)) {
                return string2;
              }
              return string2.replace(badChars, escapeChar2);
            }
            function isEmpty2(value) {
              if (!value && value !== 0) {
                return true;
              } else if (isArray2(value) && value.length === 0) {
                return true;
              } else {
                return false;
              }
            }
            function createFrame(object) {
              var frame = extend({}, object);
              frame._parent = object;
              return frame;
            }
            function blockParams(params, ids) {
              params.path = ids;
              return params;
            }
            function appendContextPath(contextPath, id) {
              return (contextPath ? contextPath + "." : "") + id;
            }
          }),
          /* 5 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var _Object$defineProperty = __webpack_require__(6)["default"];
            exports$12.__esModule = true;
            var errorProps = ["description", "fileName", "lineNumber", "endLineNumber", "message", "name", "number", "stack"];
            function Exception(message2, node) {
              var loc = node && node.loc, line = void 0, endLineNumber = void 0, column = void 0, endColumn = void 0;
              if (loc) {
                line = loc.start.line;
                endLineNumber = loc.end.line;
                column = loc.start.column;
                endColumn = loc.end.column;
                message2 += " - " + line + ":" + column;
              }
              var tmp = Error.prototype.constructor.call(this, message2);
              for (var idx = 0; idx < errorProps.length; idx++) {
                this[errorProps[idx]] = tmp[errorProps[idx]];
              }
              if (Error.captureStackTrace) {
                Error.captureStackTrace(this, Exception);
              }
              try {
                if (loc) {
                  this.lineNumber = line;
                  this.endLineNumber = endLineNumber;
                  if (_Object$defineProperty) {
                    Object.defineProperty(this, "column", {
                      value: column,
                      enumerable: true
                    });
                    Object.defineProperty(this, "endColumn", {
                      value: endColumn,
                      enumerable: true
                    });
                  } else {
                    this.column = column;
                    this.endColumn = endColumn;
                  }
                }
              } catch (nop) {
              }
            }
            Exception.prototype = new Error();
            exports$12["default"] = Exception;
            module2.exports = exports$12["default"];
          }),
          /* 6 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            module2.exports = { "default": __webpack_require__(7), __esModule: true };
          }),
          /* 7 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var $ = __webpack_require__(8);
            module2.exports = function defineProperty(it, key, desc) {
              return $.setDesc(it, key, desc);
            };
          }),
          /* 8 */
          /***/
          (function(module2, exports$12) {
            var $Object = Object;
            module2.exports = {
              create: $Object.create,
              getProto: $Object.getPrototypeOf,
              isEnum: {}.propertyIsEnumerable,
              getDesc: $Object.getOwnPropertyDescriptor,
              setDesc: $Object.defineProperty,
              setDescs: $Object.defineProperties,
              getKeys: $Object.keys,
              getNames: $Object.getOwnPropertyNames,
              getSymbols: $Object.getOwnPropertySymbols,
              each: [].forEach
            };
          }),
          /* 9 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var _interopRequireDefault = __webpack_require__(2)["default"];
            exports$12.__esModule = true;
            exports$12.registerDefaultHelpers = registerDefaultHelpers;
            exports$12.moveHelperToHooks = moveHelperToHooks;
            var _helpersBlockHelperMissing = __webpack_require__(10);
            var _helpersBlockHelperMissing2 = _interopRequireDefault(_helpersBlockHelperMissing);
            var _helpersEach = __webpack_require__(11);
            var _helpersEach2 = _interopRequireDefault(_helpersEach);
            var _helpersHelperMissing = __webpack_require__(64);
            var _helpersHelperMissing2 = _interopRequireDefault(_helpersHelperMissing);
            var _helpersIf = __webpack_require__(65);
            var _helpersIf2 = _interopRequireDefault(_helpersIf);
            var _helpersLog = __webpack_require__(66);
            var _helpersLog2 = _interopRequireDefault(_helpersLog);
            var _helpersLookup = __webpack_require__(67);
            var _helpersLookup2 = _interopRequireDefault(_helpersLookup);
            var _helpersWith = __webpack_require__(68);
            var _helpersWith2 = _interopRequireDefault(_helpersWith);
            function registerDefaultHelpers(instance) {
              _helpersBlockHelperMissing2["default"](instance);
              _helpersEach2["default"](instance);
              _helpersHelperMissing2["default"](instance);
              _helpersIf2["default"](instance);
              _helpersLog2["default"](instance);
              _helpersLookup2["default"](instance);
              _helpersWith2["default"](instance);
            }
            function moveHelperToHooks(instance, helperName, keepHelper) {
              if (instance.helpers[helperName]) {
                instance.hooks[helperName] = instance.helpers[helperName];
                if (!keepHelper) {
                  delete instance.helpers[helperName];
                }
              }
            }
          }),
          /* 10 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            exports$12.__esModule = true;
            var _utils = __webpack_require__(4);
            exports$12["default"] = function(instance) {
              instance.registerHelper("blockHelperMissing", function(context, options) {
                var inverse = options.inverse, fn = options.fn;
                if (context === true) {
                  return fn(this);
                } else if (context === false || context == null) {
                  return inverse(this);
                } else if (_utils.isArray(context)) {
                  if (context.length > 0) {
                    if (options.ids) {
                      options.ids = [options.name];
                    }
                    return instance.helpers.each(context, options);
                  } else {
                    return inverse(this);
                  }
                } else {
                  if (options.data && options.ids) {
                    var data = _utils.createFrame(options.data);
                    data.contextPath = _utils.appendContextPath(options.data.contextPath, options.name);
                    options = { data };
                  }
                  return fn(context, options);
                }
              });
            };
            module2.exports = exports$12["default"];
          }),
          /* 11 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var _Symbol = __webpack_require__(12)["default"];
            var _Symbol$iterator = __webpack_require__(42)["default"];
            var _getIterator = __webpack_require__(54)["default"];
            var _Object$keys = __webpack_require__(59)["default"];
            var _interopRequireDefault = __webpack_require__(2)["default"];
            exports$12.__esModule = true;
            var _utils = __webpack_require__(4);
            var _exception = __webpack_require__(5);
            var _exception2 = _interopRequireDefault(_exception);
            exports$12["default"] = function(instance) {
              instance.registerHelper("each", function(context, options) {
                if (!options) {
                  throw new _exception2["default"]("Must pass iterator to #each");
                }
                var fn = options.fn, inverse = options.inverse, i = 0, ret = "", data = void 0, contextPath = void 0;
                if (options.data && options.ids) {
                  contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]) + ".";
                }
                if (_utils.isFunction(context)) {
                  context = context.call(this);
                }
                if (options.data) {
                  data = _utils.createFrame(options.data);
                }
                function execIteration(field, index, last2) {
                  if (data) {
                    data.key = field;
                    data.index = index;
                    data.first = index === 0;
                    data.last = !!last2;
                    if (contextPath) {
                      data.contextPath = contextPath + field;
                    }
                  }
                  ret = ret + fn(context[field], {
                    data,
                    blockParams: _utils.blockParams([context[field], field], [contextPath + field, null])
                  });
                }
                if (context && typeof context === "object") {
                  if (_utils.isArray(context)) {
                    for (var j = context.length; i < j; i++) {
                      if (i in context) {
                        execIteration(i, i, i === context.length - 1);
                      }
                    }
                  } else if (typeof _Symbol === "function" && context[_Symbol$iterator]) {
                    var newContext = [];
                    var iterator = _getIterator(context);
                    for (var it = iterator.next(); !it.done; it = iterator.next()) {
                      newContext.push(it.value);
                    }
                    context = newContext;
                    for (var j = context.length; i < j; i++) {
                      execIteration(i, i, i === context.length - 1);
                    }
                  } else {
                    (function() {
                      var priorKey = void 0;
                      _Object$keys(context).forEach(function(key) {
                        if (priorKey !== void 0) {
                          execIteration(priorKey, i - 1);
                        }
                        priorKey = key;
                        i++;
                      });
                      if (priorKey !== void 0) {
                        execIteration(priorKey, i - 1, true);
                      }
                    })();
                  }
                }
                if (i === 0) {
                  ret = inverse(this);
                }
                return ret;
              });
            };
            module2.exports = exports$12["default"];
          }),
          /* 12 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            module2.exports = { "default": __webpack_require__(13), __esModule: true };
          }),
          /* 13 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            __webpack_require__(14);
            __webpack_require__(41);
            module2.exports = __webpack_require__(20).Symbol;
          }),
          /* 14 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var $ = __webpack_require__(8), global2 = __webpack_require__(15), has2 = __webpack_require__(16), DESCRIPTORS = __webpack_require__(17), $export = __webpack_require__(19), redefine = __webpack_require__(23), $fails = __webpack_require__(18), shared = __webpack_require__(26), setToStringTag = __webpack_require__(27), uid = __webpack_require__(29), wks = __webpack_require__(28), keyOf = __webpack_require__(30), $names = __webpack_require__(35), enumKeys = __webpack_require__(36), isArray2 = __webpack_require__(37), anObject = __webpack_require__(38), toIObject = __webpack_require__(31), createDesc = __webpack_require__(25), getDesc = $.getDesc, setDesc = $.setDesc, _create = $.create, getNames = $names.get, $Symbol = global2.Symbol, $JSON = global2.JSON, _stringify = $JSON && $JSON.stringify, setter = false, HIDDEN = wks("_hidden"), isEnum = $.isEnum, SymbolRegistry = shared("symbol-registry"), AllSymbols = shared("symbols"), useNative = typeof $Symbol == "function", ObjectProto = Object.prototype;
            var setSymbolDesc = DESCRIPTORS && $fails(function() {
              return _create(setDesc({}, "a", {
                get: function() {
                  return setDesc(this, "a", { value: 7 }).a;
                }
              })).a != 7;
            }) ? function(it, key, D) {
              var protoDesc = getDesc(ObjectProto, key);
              if (protoDesc) delete ObjectProto[key];
              setDesc(it, key, D);
              if (protoDesc && it !== ObjectProto) setDesc(ObjectProto, key, protoDesc);
            } : setDesc;
            var wrap = function(tag2) {
              var sym = AllSymbols[tag2] = _create($Symbol.prototype);
              sym._k = tag2;
              DESCRIPTORS && setter && setSymbolDesc(ObjectProto, tag2, {
                configurable: true,
                set: function(value) {
                  if (has2(this, HIDDEN) && has2(this[HIDDEN], tag2)) this[HIDDEN][tag2] = false;
                  setSymbolDesc(this, tag2, createDesc(1, value));
                }
              });
              return sym;
            };
            var isSymbol = function(it) {
              return typeof it == "symbol";
            };
            var $defineProperty = function defineProperty(it, key, D) {
              if (D && has2(AllSymbols, key)) {
                if (!D.enumerable) {
                  if (!has2(it, HIDDEN)) setDesc(it, HIDDEN, createDesc(1, {}));
                  it[HIDDEN][key] = true;
                } else {
                  if (has2(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
                  D = _create(D, { enumerable: createDesc(0, false) });
                }
                return setSymbolDesc(it, key, D);
              }
              return setDesc(it, key, D);
            };
            var $defineProperties = function defineProperties(it, P) {
              anObject(it);
              var keys = enumKeys(P = toIObject(P)), i = 0, l = keys.length, key;
              while (l > i) $defineProperty(it, key = keys[i++], P[key]);
              return it;
            };
            var $create = function create(it, P) {
              return P === void 0 ? _create(it) : $defineProperties(_create(it), P);
            };
            var $propertyIsEnumerable = function propertyIsEnumerable(key) {
              var E = isEnum.call(this, key);
              return E || !has2(this, key) || !has2(AllSymbols, key) || has2(this, HIDDEN) && this[HIDDEN][key] ? E : true;
            };
            var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
              var D = getDesc(it = toIObject(it), key);
              if (D && has2(AllSymbols, key) && !(has2(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
              return D;
            };
            var $getOwnPropertyNames = function getOwnPropertyNames(it) {
              var names = getNames(toIObject(it)), result = [], i = 0, key;
              while (names.length > i) if (!has2(AllSymbols, key = names[i++]) && key != HIDDEN) result.push(key);
              return result;
            };
            var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
              var names = getNames(toIObject(it)), result = [], i = 0, key;
              while (names.length > i) if (has2(AllSymbols, key = names[i++])) result.push(AllSymbols[key]);
              return result;
            };
            var $stringify = function stringify2(it) {
              if (it === void 0 || isSymbol(it)) return;
              var args = [it], i = 1, $$ = arguments, replacer, $replacer;
              while ($$.length > i) args.push($$[i++]);
              replacer = args[1];
              if (typeof replacer == "function") $replacer = replacer;
              if ($replacer || !isArray2(replacer)) replacer = function(key, value) {
                if ($replacer) value = $replacer.call(this, key, value);
                if (!isSymbol(value)) return value;
              };
              args[1] = replacer;
              return _stringify.apply($JSON, args);
            };
            var buggyJSON = $fails(function() {
              var S = $Symbol();
              return _stringify([S]) != "[null]" || _stringify({ a: S }) != "{}" || _stringify(Object(S)) != "{}";
            });
            if (!useNative) {
              $Symbol = function Symbol2() {
                if (isSymbol(this)) throw TypeError("Symbol is not a constructor");
                return wrap(uid(arguments.length > 0 ? arguments[0] : void 0));
              };
              redefine($Symbol.prototype, "toString", function toString2() {
                return this._k;
              });
              isSymbol = function(it) {
                return it instanceof $Symbol;
              };
              $.create = $create;
              $.isEnum = $propertyIsEnumerable;
              $.getDesc = $getOwnPropertyDescriptor;
              $.setDesc = $defineProperty;
              $.setDescs = $defineProperties;
              $.getNames = $names.get = $getOwnPropertyNames;
              $.getSymbols = $getOwnPropertySymbols;
              if (DESCRIPTORS && !__webpack_require__(40)) {
                redefine(ObjectProto, "propertyIsEnumerable", $propertyIsEnumerable, true);
              }
            }
            var symbolStatics = {
              // 19.4.2.1 Symbol.for(key)
              "for": function(key) {
                return has2(SymbolRegistry, key += "") ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
              },
              // 19.4.2.5 Symbol.keyFor(sym)
              keyFor: function keyFor(key) {
                return keyOf(SymbolRegistry, key);
              },
              useSetter: function() {
                setter = true;
              },
              useSimple: function() {
                setter = false;
              }
            };
            $.each.call("hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), function(it) {
              var sym = wks(it);
              symbolStatics[it] = useNative ? sym : wrap(sym);
            });
            setter = true;
            $export($export.G + $export.W, { Symbol: $Symbol });
            $export($export.S, "Symbol", symbolStatics);
            $export($export.S + $export.F * !useNative, "Object", {
              // 19.1.2.2 Object.create(O [, Properties])
              create: $create,
              // 19.1.2.4 Object.defineProperty(O, P, Attributes)
              defineProperty: $defineProperty,
              // 19.1.2.3 Object.defineProperties(O, Properties)
              defineProperties: $defineProperties,
              // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
              getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
              // 19.1.2.7 Object.getOwnPropertyNames(O)
              getOwnPropertyNames: $getOwnPropertyNames,
              // 19.1.2.8 Object.getOwnPropertySymbols(O)
              getOwnPropertySymbols: $getOwnPropertySymbols
            });
            $JSON && $export($export.S + $export.F * (!useNative || buggyJSON), "JSON", { stringify: $stringify });
            setToStringTag($Symbol, "Symbol");
            setToStringTag(Math, "Math", true);
            setToStringTag(global2.JSON, "JSON", true);
          }),
          /* 15 */
          /***/
          (function(module2, exports$12) {
            var global2 = module2.exports = typeof window != "undefined" && window.Math == Math ? window : typeof self != "undefined" && self.Math == Math ? self : Function("return this")();
            if (typeof __g == "number") __g = global2;
          }),
          /* 16 */
          /***/
          (function(module2, exports$12) {
            var hasOwnProperty2 = {}.hasOwnProperty;
            module2.exports = function(it, key) {
              return hasOwnProperty2.call(it, key);
            };
          }),
          /* 17 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            module2.exports = !__webpack_require__(18)(function() {
              return Object.defineProperty({}, "a", { get: function() {
                return 7;
              } }).a != 7;
            });
          }),
          /* 18 */
          /***/
          (function(module2, exports$12) {
            module2.exports = function(exec) {
              try {
                return !!exec();
              } catch (e) {
                return true;
              }
            };
          }),
          /* 19 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var global2 = __webpack_require__(15), core = __webpack_require__(20), ctx = __webpack_require__(21), PROTOTYPE = "prototype";
            var $export = function(type, name, source) {
              var IS_FORCED = type & $export.F, IS_GLOBAL = type & $export.G, IS_STATIC = type & $export.S, IS_PROTO = type & $export.P, IS_BIND = type & $export.B, IS_WRAP = type & $export.W, exports$13 = IS_GLOBAL ? core : core[name] || (core[name] = {}), target = IS_GLOBAL ? global2 : IS_STATIC ? global2[name] : (global2[name] || {})[PROTOTYPE], key, own, out;
              if (IS_GLOBAL) source = name;
              for (key in source) {
                own = !IS_FORCED && target && key in target;
                if (own && key in exports$13) continue;
                out = own ? target[key] : source[key];
                exports$13[key] = IS_GLOBAL && typeof target[key] != "function" ? source[key] : IS_BIND && own ? ctx(out, global2) : IS_WRAP && target[key] == out ? (function(C) {
                  var F = function(param) {
                    return this instanceof C ? new C(param) : C(param);
                  };
                  F[PROTOTYPE] = C[PROTOTYPE];
                  return F;
                })(out) : IS_PROTO && typeof out == "function" ? ctx(Function.call, out) : out;
                if (IS_PROTO) (exports$13[PROTOTYPE] || (exports$13[PROTOTYPE] = {}))[key] = out;
              }
            };
            $export.F = 1;
            $export.G = 2;
            $export.S = 4;
            $export.P = 8;
            $export.B = 16;
            $export.W = 32;
            module2.exports = $export;
          }),
          /* 20 */
          /***/
          (function(module2, exports$12) {
            var core = module2.exports = { version: "1.2.6" };
            if (typeof __e == "number") __e = core;
          }),
          /* 21 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var aFunction = __webpack_require__(22);
            module2.exports = function(fn, that, length) {
              aFunction(fn);
              if (that === void 0) return fn;
              switch (length) {
                case 1:
                  return function(a) {
                    return fn.call(that, a);
                  };
                case 2:
                  return function(a, b) {
                    return fn.call(that, a, b);
                  };
                case 3:
                  return function(a, b, c) {
                    return fn.call(that, a, b, c);
                  };
              }
              return function() {
                return fn.apply(that, arguments);
              };
            };
          }),
          /* 22 */
          /***/
          (function(module2, exports$12) {
            module2.exports = function(it) {
              if (typeof it != "function") throw TypeError(it + " is not a function!");
              return it;
            };
          }),
          /* 23 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            module2.exports = __webpack_require__(24);
          }),
          /* 24 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var $ = __webpack_require__(8), createDesc = __webpack_require__(25);
            module2.exports = __webpack_require__(17) ? function(object, key, value) {
              return $.setDesc(object, key, createDesc(1, value));
            } : function(object, key, value) {
              object[key] = value;
              return object;
            };
          }),
          /* 25 */
          /***/
          (function(module2, exports$12) {
            module2.exports = function(bitmap, value) {
              return {
                enumerable: !(bitmap & 1),
                configurable: !(bitmap & 2),
                writable: !(bitmap & 4),
                value
              };
            };
          }),
          /* 26 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var global2 = __webpack_require__(15), SHARED = "__core-js_shared__", store = global2[SHARED] || (global2[SHARED] = {});
            module2.exports = function(key) {
              return store[key] || (store[key] = {});
            };
          }),
          /* 27 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var def = __webpack_require__(8).setDesc, has2 = __webpack_require__(16), TAG = __webpack_require__(28)("toStringTag");
            module2.exports = function(it, tag2, stat) {
              if (it && !has2(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag2 });
            };
          }),
          /* 28 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var store = __webpack_require__(26)("wks"), uid = __webpack_require__(29), Symbol2 = __webpack_require__(15).Symbol;
            module2.exports = function(name) {
              return store[name] || (store[name] = Symbol2 && Symbol2[name] || (Symbol2 || uid)("Symbol." + name));
            };
          }),
          /* 29 */
          /***/
          (function(module2, exports$12) {
            var id = 0, px = Math.random();
            module2.exports = function(key) {
              return "Symbol(".concat(key === void 0 ? "" : key, ")_", (++id + px).toString(36));
            };
          }),
          /* 30 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var $ = __webpack_require__(8), toIObject = __webpack_require__(31);
            module2.exports = function(object, el) {
              var O = toIObject(object), keys = $.getKeys(O), length = keys.length, index = 0, key;
              while (length > index) if (O[key = keys[index++]] === el) return key;
            };
          }),
          /* 31 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var IObject = __webpack_require__(32), defined = __webpack_require__(34);
            module2.exports = function(it) {
              return IObject(defined(it));
            };
          }),
          /* 32 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var cof = __webpack_require__(33);
            module2.exports = Object("z").propertyIsEnumerable(0) ? Object : function(it) {
              return cof(it) == "String" ? it.split("") : Object(it);
            };
          }),
          /* 33 */
          /***/
          (function(module2, exports$12) {
            var toString2 = {}.toString;
            module2.exports = function(it) {
              return toString2.call(it).slice(8, -1);
            };
          }),
          /* 34 */
          /***/
          (function(module2, exports$12) {
            module2.exports = function(it) {
              if (it == void 0) throw TypeError("Can't call method on  " + it);
              return it;
            };
          }),
          /* 35 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var toIObject = __webpack_require__(31), getNames = __webpack_require__(8).getNames, toString2 = {}.toString;
            var windowNames = typeof window == "object" && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
            var getWindowNames = function(it) {
              try {
                return getNames(it);
              } catch (e) {
                return windowNames.slice();
              }
            };
            module2.exports.get = function getOwnPropertyNames(it) {
              if (windowNames && toString2.call(it) == "[object Window]") return getWindowNames(it);
              return getNames(toIObject(it));
            };
          }),
          /* 36 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var $ = __webpack_require__(8);
            module2.exports = function(it) {
              var keys = $.getKeys(it), getSymbols = $.getSymbols;
              if (getSymbols) {
                var symbols = getSymbols(it), isEnum = $.isEnum, i = 0, key;
                while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) keys.push(key);
              }
              return keys;
            };
          }),
          /* 37 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var cof = __webpack_require__(33);
            module2.exports = Array.isArray || function(arg) {
              return cof(arg) == "Array";
            };
          }),
          /* 38 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var isObject2 = __webpack_require__(39);
            module2.exports = function(it) {
              if (!isObject2(it)) throw TypeError(it + " is not an object!");
              return it;
            };
          }),
          /* 39 */
          /***/
          (function(module2, exports$12) {
            module2.exports = function(it) {
              return typeof it === "object" ? it !== null : typeof it === "function";
            };
          }),
          /* 40 */
          /***/
          (function(module2, exports$12) {
            module2.exports = true;
          }),
          /* 41 */
          /***/
          (function(module2, exports$12) {
          }),
          /* 42 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            module2.exports = { "default": __webpack_require__(43), __esModule: true };
          }),
          /* 43 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            __webpack_require__(44);
            __webpack_require__(50);
            module2.exports = __webpack_require__(28)("iterator");
          }),
          /* 44 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var $at = __webpack_require__(45)(true);
            __webpack_require__(47)(String, "String", function(iterated) {
              this._t = String(iterated);
              this._i = 0;
            }, function() {
              var O = this._t, index = this._i, point;
              if (index >= O.length) return { value: void 0, done: true };
              point = $at(O, index);
              this._i += point.length;
              return { value: point, done: false };
            });
          }),
          /* 45 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var toInteger = __webpack_require__(46), defined = __webpack_require__(34);
            module2.exports = function(TO_STRING) {
              return function(that, pos) {
                var s = String(defined(that)), i = toInteger(pos), l = s.length, a, b;
                if (i < 0 || i >= l) return TO_STRING ? "" : void 0;
                a = s.charCodeAt(i);
                return a < 55296 || a > 56319 || i + 1 === l || (b = s.charCodeAt(i + 1)) < 56320 || b > 57343 ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 55296 << 10) + (b - 56320) + 65536;
              };
            };
          }),
          /* 46 */
          /***/
          (function(module2, exports$12) {
            var ceil2 = Math.ceil, floor2 = Math.floor;
            module2.exports = function(it) {
              return isNaN(it = +it) ? 0 : (it > 0 ? floor2 : ceil2)(it);
            };
          }),
          /* 47 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var LIBRARY = __webpack_require__(40), $export = __webpack_require__(19), redefine = __webpack_require__(23), hide = __webpack_require__(24), has2 = __webpack_require__(16), Iterators = __webpack_require__(48), $iterCreate = __webpack_require__(49), setToStringTag = __webpack_require__(27), getProto = __webpack_require__(8).getProto, ITERATOR = __webpack_require__(28)("iterator"), BUGGY = !([].keys && "next" in [].keys()), FF_ITERATOR = "@@iterator", KEYS = "keys", VALUES = "values";
            var returnThis = function() {
              return this;
            };
            module2.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
              $iterCreate(Constructor, NAME, next);
              var getMethod = function(kind) {
                if (!BUGGY && kind in proto) return proto[kind];
                switch (kind) {
                  case KEYS:
                    return function keys() {
                      return new Constructor(this, kind);
                    };
                  case VALUES:
                    return function values() {
                      return new Constructor(this, kind);
                    };
                }
                return function entries() {
                  return new Constructor(this, kind);
                };
              };
              var TAG = NAME + " Iterator", DEF_VALUES = DEFAULT == VALUES, VALUES_BUG = false, proto = Base.prototype, $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT], $default = $native || getMethod(DEFAULT), methods, key;
              if ($native) {
                var IteratorPrototype = getProto($default.call(new Base()));
                setToStringTag(IteratorPrototype, TAG, true);
                if (!LIBRARY && has2(proto, FF_ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);
                if (DEF_VALUES && $native.name !== VALUES) {
                  VALUES_BUG = true;
                  $default = function values() {
                    return $native.call(this);
                  };
                }
              }
              if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
                hide(proto, ITERATOR, $default);
              }
              Iterators[NAME] = $default;
              Iterators[TAG] = returnThis;
              if (DEFAULT) {
                methods = {
                  values: DEF_VALUES ? $default : getMethod(VALUES),
                  keys: IS_SET ? $default : getMethod(KEYS),
                  entries: !DEF_VALUES ? $default : getMethod("entries")
                };
                if (FORCED) for (key in methods) {
                  if (!(key in proto)) redefine(proto, key, methods[key]);
                }
                else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
              }
              return methods;
            };
          }),
          /* 48 */
          /***/
          (function(module2, exports$12) {
            module2.exports = {};
          }),
          /* 49 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var $ = __webpack_require__(8), descriptor = __webpack_require__(25), setToStringTag = __webpack_require__(27), IteratorPrototype = {};
            __webpack_require__(24)(IteratorPrototype, __webpack_require__(28)("iterator"), function() {
              return this;
            });
            module2.exports = function(Constructor, NAME, next) {
              Constructor.prototype = $.create(IteratorPrototype, { next: descriptor(1, next) });
              setToStringTag(Constructor, NAME + " Iterator");
            };
          }),
          /* 50 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            __webpack_require__(51);
            var Iterators = __webpack_require__(48);
            Iterators.NodeList = Iterators.HTMLCollection = Iterators.Array;
          }),
          /* 51 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var addToUnscopables = __webpack_require__(52), step2 = __webpack_require__(53), Iterators = __webpack_require__(48), toIObject = __webpack_require__(31);
            module2.exports = __webpack_require__(47)(Array, "Array", function(iterated, kind) {
              this._t = toIObject(iterated);
              this._i = 0;
              this._k = kind;
            }, function() {
              var O = this._t, kind = this._k, index = this._i++;
              if (!O || index >= O.length) {
                this._t = void 0;
                return step2(1);
              }
              if (kind == "keys") return step2(0, index);
              if (kind == "values") return step2(0, O[index]);
              return step2(0, [index, O[index]]);
            }, "values");
            Iterators.Arguments = Iterators.Array;
            addToUnscopables("keys");
            addToUnscopables("values");
            addToUnscopables("entries");
          }),
          /* 52 */
          /***/
          (function(module2, exports$12) {
            module2.exports = function() {
            };
          }),
          /* 53 */
          /***/
          (function(module2, exports$12) {
            module2.exports = function(done, value) {
              return { value, done: !!done };
            };
          }),
          /* 54 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            module2.exports = { "default": __webpack_require__(55), __esModule: true };
          }),
          /* 55 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            __webpack_require__(50);
            __webpack_require__(44);
            module2.exports = __webpack_require__(56);
          }),
          /* 56 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var anObject = __webpack_require__(38), get = __webpack_require__(57);
            module2.exports = __webpack_require__(20).getIterator = function(it) {
              var iterFn = get(it);
              if (typeof iterFn != "function") throw TypeError(it + " is not iterable!");
              return anObject(iterFn.call(it));
            };
          }),
          /* 57 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var classof = __webpack_require__(58), ITERATOR = __webpack_require__(28)("iterator"), Iterators = __webpack_require__(48);
            module2.exports = __webpack_require__(20).getIteratorMethod = function(it) {
              if (it != void 0) return it[ITERATOR] || it["@@iterator"] || Iterators[classof(it)];
            };
          }),
          /* 58 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var cof = __webpack_require__(33), TAG = __webpack_require__(28)("toStringTag"), ARG = cof(/* @__PURE__ */ (function() {
              return arguments;
            })()) == "Arguments";
            module2.exports = function(it) {
              var O, T, B;
              return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (T = (O = Object(it))[TAG]) == "string" ? T : ARG ? cof(O) : (B = cof(O)) == "Object" && typeof O.callee == "function" ? "Arguments" : B;
            };
          }),
          /* 59 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            module2.exports = { "default": __webpack_require__(60), __esModule: true };
          }),
          /* 60 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            __webpack_require__(61);
            module2.exports = __webpack_require__(20).Object.keys;
          }),
          /* 61 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var toObject = __webpack_require__(62);
            __webpack_require__(63)("keys", function($keys) {
              return function keys(it) {
                return $keys(toObject(it));
              };
            });
          }),
          /* 62 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var defined = __webpack_require__(34);
            module2.exports = function(it) {
              return Object(defined(it));
            };
          }),
          /* 63 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var $export = __webpack_require__(19), core = __webpack_require__(20), fails = __webpack_require__(18);
            module2.exports = function(KEY, exec) {
              var fn = (core.Object || {})[KEY] || Object[KEY], exp = {};
              exp[KEY] = exec(fn);
              $export($export.S + $export.F * fails(function() {
                fn(1);
              }), "Object", exp);
            };
          }),
          /* 64 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var _interopRequireDefault = __webpack_require__(2)["default"];
            exports$12.__esModule = true;
            var _exception = __webpack_require__(5);
            var _exception2 = _interopRequireDefault(_exception);
            exports$12["default"] = function(instance) {
              instance.registerHelper("helperMissing", function() {
                if (arguments.length === 1) {
                  return void 0;
                } else {
                  throw new _exception2["default"]('Missing helper: "' + arguments[arguments.length - 1].name + '"');
                }
              });
            };
            module2.exports = exports$12["default"];
          }),
          /* 65 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var _interopRequireDefault = __webpack_require__(2)["default"];
            exports$12.__esModule = true;
            var _utils = __webpack_require__(4);
            var _exception = __webpack_require__(5);
            var _exception2 = _interopRequireDefault(_exception);
            exports$12["default"] = function(instance) {
              instance.registerHelper("if", function(conditional, options) {
                if (arguments.length != 2) {
                  throw new _exception2["default"]("#if requires exactly one argument");
                }
                if (_utils.isFunction(conditional)) {
                  conditional = conditional.call(this);
                }
                if (!options.hash.includeZero && !conditional || _utils.isEmpty(conditional)) {
                  return options.inverse(this);
                } else {
                  return options.fn(this);
                }
              });
              instance.registerHelper("unless", function(conditional, options) {
                if (arguments.length != 2) {
                  throw new _exception2["default"]("#unless requires exactly one argument");
                }
                return instance.helpers["if"].call(this, conditional, {
                  fn: options.inverse,
                  inverse: options.fn,
                  hash: options.hash
                });
              });
            };
            module2.exports = exports$12["default"];
          }),
          /* 66 */
          /***/
          (function(module2, exports$12) {
            exports$12.__esModule = true;
            exports$12["default"] = function(instance) {
              instance.registerHelper("log", function() {
                var args = [void 0], options = arguments[arguments.length - 1];
                for (var i = 0; i < arguments.length - 1; i++) {
                  args.push(arguments[i]);
                }
                var level = 1;
                if (options.hash.level != null) {
                  level = options.hash.level;
                } else if (options.data && options.data.level != null) {
                  level = options.data.level;
                }
                args[0] = level;
                instance.log.apply(instance, args);
              });
            };
            module2.exports = exports$12["default"];
          }),
          /* 67 */
          /***/
          (function(module2, exports$12) {
            exports$12.__esModule = true;
            exports$12["default"] = function(instance) {
              instance.registerHelper("lookup", function(obj, field, options) {
                if (!obj) {
                  return obj;
                }
                return options.lookupProperty(obj, field);
              });
            };
            module2.exports = exports$12["default"];
          }),
          /* 68 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var _interopRequireDefault = __webpack_require__(2)["default"];
            exports$12.__esModule = true;
            var _utils = __webpack_require__(4);
            var _exception = __webpack_require__(5);
            var _exception2 = _interopRequireDefault(_exception);
            exports$12["default"] = function(instance) {
              instance.registerHelper("with", function(context, options) {
                if (arguments.length != 2) {
                  throw new _exception2["default"]("#with requires exactly one argument");
                }
                if (_utils.isFunction(context)) {
                  context = context.call(this);
                }
                var fn = options.fn;
                if (!_utils.isEmpty(context)) {
                  var data = options.data;
                  if (options.data && options.ids) {
                    data = _utils.createFrame(options.data);
                    data.contextPath = _utils.appendContextPath(options.data.contextPath, options.ids[0]);
                  }
                  return fn(context, {
                    data,
                    blockParams: _utils.blockParams([context], [data && data.contextPath])
                  });
                } else {
                  return options.inverse(this);
                }
              });
            };
            module2.exports = exports$12["default"];
          }),
          /* 69 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var _interopRequireDefault = __webpack_require__(2)["default"];
            exports$12.__esModule = true;
            exports$12.registerDefaultDecorators = registerDefaultDecorators;
            var _decoratorsInline = __webpack_require__(70);
            var _decoratorsInline2 = _interopRequireDefault(_decoratorsInline);
            function registerDefaultDecorators(instance) {
              _decoratorsInline2["default"](instance);
            }
          }),
          /* 70 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            exports$12.__esModule = true;
            var _utils = __webpack_require__(4);
            exports$12["default"] = function(instance) {
              instance.registerDecorator("inline", function(fn, props, container, options) {
                var ret = fn;
                if (!props.partials) {
                  props.partials = {};
                  ret = function(context, options2) {
                    var original = container.partials;
                    container.partials = _utils.extend({}, original, props.partials);
                    var ret2 = fn(context, options2);
                    container.partials = original;
                    return ret2;
                  };
                }
                props.partials[options.args[0]] = options.fn;
                return ret;
              });
            };
            module2.exports = exports$12["default"];
          }),
          /* 71 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            exports$12.__esModule = true;
            var _utils = __webpack_require__(4);
            var logger2 = {
              methodMap: ["debug", "info", "warn", "error"],
              level: "info",
              // Maps a given level value to the `methodMap` indexes above.
              lookupLevel: function lookupLevel(level) {
                if (typeof level === "string") {
                  var levelMap = _utils.indexOf(logger2.methodMap, level.toLowerCase());
                  if (levelMap >= 0) {
                    level = levelMap;
                  } else {
                    level = parseInt(level, 10);
                  }
                }
                return level;
              },
              // Can be overridden in the host environment
              log: function log(level) {
                level = logger2.lookupLevel(level);
                if (typeof console !== "undefined" && logger2.lookupLevel(logger2.level) <= level) {
                  var method = logger2.methodMap[level];
                  if (!console[method]) {
                    method = "log";
                  }
                  for (var _len = arguments.length, message2 = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    message2[_key - 1] = arguments[_key];
                  }
                  console[method].apply(console, message2);
                }
              }
            };
            exports$12["default"] = logger2;
            module2.exports = exports$12["default"];
          }),
          /* 72 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var _Object$create = __webpack_require__(73)["default"];
            var _Object$keys = __webpack_require__(59)["default"];
            var _interopRequireDefault = __webpack_require__(2)["default"];
            exports$12.__esModule = true;
            exports$12.createProtoAccessControl = createProtoAccessControl;
            exports$12.resultIsAllowed = resultIsAllowed;
            exports$12.resetLoggedProperties = resetLoggedProperties;
            var _createNewLookupObject = __webpack_require__(75);
            var _logger = __webpack_require__(71);
            var _logger2 = _interopRequireDefault(_logger);
            var loggedProperties = _Object$create(null);
            function createProtoAccessControl(runtimeOptions) {
              var defaultMethodWhiteList = _Object$create(null);
              defaultMethodWhiteList["constructor"] = false;
              defaultMethodWhiteList["__defineGetter__"] = false;
              defaultMethodWhiteList["__defineSetter__"] = false;
              defaultMethodWhiteList["__lookupGetter__"] = false;
              var defaultPropertyWhiteList = _Object$create(null);
              defaultPropertyWhiteList["__proto__"] = false;
              return {
                properties: {
                  whitelist: _createNewLookupObject.createNewLookupObject(defaultPropertyWhiteList, runtimeOptions.allowedProtoProperties),
                  defaultValue: runtimeOptions.allowProtoPropertiesByDefault
                },
                methods: {
                  whitelist: _createNewLookupObject.createNewLookupObject(defaultMethodWhiteList, runtimeOptions.allowedProtoMethods),
                  defaultValue: runtimeOptions.allowProtoMethodsByDefault
                }
              };
            }
            function resultIsAllowed(result, protoAccessControl, propertyName) {
              if (typeof result === "function") {
                return checkWhiteList(protoAccessControl.methods, propertyName);
              } else {
                return checkWhiteList(protoAccessControl.properties, propertyName);
              }
            }
            function checkWhiteList(protoAccessControlForType, propertyName) {
              if (protoAccessControlForType.whitelist[propertyName] !== void 0) {
                return protoAccessControlForType.whitelist[propertyName] === true;
              }
              if (protoAccessControlForType.defaultValue !== void 0) {
                return protoAccessControlForType.defaultValue;
              }
              logUnexpecedPropertyAccessOnce(propertyName);
              return false;
            }
            function logUnexpecedPropertyAccessOnce(propertyName) {
              if (loggedProperties[propertyName] !== true) {
                loggedProperties[propertyName] = true;
                _logger2["default"].log("error", 'Handlebars: Access has been denied to resolve the property "' + propertyName + '" because it is not an "own property" of its parent.\nYou can add a runtime option to disable the check or this warning:\nSee https://handlebarsjs.com/api-reference/runtime-options.html#options-to-control-prototype-access for details');
              }
            }
            function resetLoggedProperties() {
              _Object$keys(loggedProperties).forEach(function(propertyName) {
                delete loggedProperties[propertyName];
              });
            }
          }),
          /* 73 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            module2.exports = { "default": __webpack_require__(74), __esModule: true };
          }),
          /* 74 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var $ = __webpack_require__(8);
            module2.exports = function create(P, D) {
              return $.create(P, D);
            };
          }),
          /* 75 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var _Object$create = __webpack_require__(73)["default"];
            exports$12.__esModule = true;
            exports$12.createNewLookupObject = createNewLookupObject;
            var _utils = __webpack_require__(4);
            function createNewLookupObject() {
              for (var _len = arguments.length, sources = Array(_len), _key = 0; _key < _len; _key++) {
                sources[_key] = arguments[_key];
              }
              return _utils.extend.apply(void 0, [_Object$create(null)].concat(sources));
            }
          }),
          /* 76 */
          /***/
          (function(module2, exports$12) {
            exports$12.__esModule = true;
            function SafeString(string2) {
              this.string = string2;
            }
            SafeString.prototype.toString = SafeString.prototype.toHTML = function() {
              return "" + this.string;
            };
            exports$12["default"] = SafeString;
            module2.exports = exports$12["default"];
          }),
          /* 77 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var _Object$seal = __webpack_require__(78)["default"];
            var _Object$keys = __webpack_require__(59)["default"];
            var _interopRequireWildcard = __webpack_require__(1)["default"];
            var _interopRequireDefault = __webpack_require__(2)["default"];
            exports$12.__esModule = true;
            exports$12.checkRevision = checkRevision;
            exports$12.template = template2;
            exports$12.wrapProgram = wrapProgram;
            exports$12.resolvePartial = resolvePartial;
            exports$12.invokePartial = invokePartial;
            exports$12.noop = noop;
            var _utils = __webpack_require__(4);
            var Utils = _interopRequireWildcard(_utils);
            var _exception = __webpack_require__(5);
            var _exception2 = _interopRequireDefault(_exception);
            var _base = __webpack_require__(3);
            var _helpers = __webpack_require__(9);
            var _internalWrapHelper = __webpack_require__(81);
            var _internalProtoAccess = __webpack_require__(72);
            function checkRevision(compilerInfo) {
              var compilerRevision = compilerInfo && compilerInfo[0] || 1, currentRevision = _base.COMPILER_REVISION;
              if (compilerRevision >= _base.LAST_COMPATIBLE_COMPILER_REVISION && compilerRevision <= _base.COMPILER_REVISION) {
                return;
              }
              if (compilerRevision < _base.LAST_COMPATIBLE_COMPILER_REVISION) {
                var runtimeVersions = _base.REVISION_CHANGES[currentRevision], compilerVersions = _base.REVISION_CHANGES[compilerRevision];
                throw new _exception2["default"]("Template was precompiled with an older version of Handlebars than the current runtime. Please update your precompiler to a newer version (" + runtimeVersions + ") or downgrade your runtime to an older version (" + compilerVersions + ").");
              } else {
                throw new _exception2["default"]("Template was precompiled with a newer version of Handlebars than the current runtime. Please update your runtime to a newer version (" + compilerInfo[1] + ").");
              }
            }
            function template2(templateSpec, env) {
              if (!env) {
                throw new _exception2["default"]("No environment passed to template");
              }
              if (!templateSpec || !templateSpec.main) {
                throw new _exception2["default"]("Unknown template object: " + typeof templateSpec);
              }
              templateSpec.main.decorator = templateSpec.main_d;
              env.VM.checkRevision(templateSpec.compiler);
              var templateWasPrecompiledWithCompilerV7 = templateSpec.compiler && templateSpec.compiler[0] === 7;
              function invokePartialWrapper(partial, context, options) {
                if (options.hash) {
                  context = Utils.extend({}, context, options.hash);
                  if (options.ids) {
                    options.ids[0] = true;
                  }
                }
                partial = env.VM.resolvePartial.call(this, partial, context, options);
                var extendedOptions = Utils.extend({}, options, {
                  hooks: this.hooks,
                  protoAccessControl: this.protoAccessControl
                });
                var result = env.VM.invokePartial.call(this, partial, context, extendedOptions);
                if (result == null && env.compile) {
                  options.partials[options.name] = env.compile(partial, templateSpec.compilerOptions, env);
                  result = options.partials[options.name](context, extendedOptions);
                }
                if (result != null) {
                  if (options.indent) {
                    var lines = result.split("\n");
                    for (var i = 0, l = lines.length; i < l; i++) {
                      if (!lines[i] && i + 1 === l) {
                        break;
                      }
                      lines[i] = options.indent + lines[i];
                    }
                    result = lines.join("\n");
                  }
                  return result;
                } else {
                  throw new _exception2["default"]("The partial " + options.name + " could not be compiled when running in runtime-only mode");
                }
              }
              var container = {
                strict: function strict(obj, name, loc) {
                  if (!obj || !(name in obj)) {
                    throw new _exception2["default"]('"' + name + '" not defined in ' + obj, {
                      loc
                    });
                  }
                  return container.lookupProperty(obj, name);
                },
                lookupProperty: function lookupProperty(parent, propertyName) {
                  var result = parent[propertyName];
                  if (result == null) {
                    return result;
                  }
                  if (Object.prototype.hasOwnProperty.call(parent, propertyName)) {
                    return result;
                  }
                  if (_internalProtoAccess.resultIsAllowed(result, container.protoAccessControl, propertyName)) {
                    return result;
                  }
                  return void 0;
                },
                lookup: function lookup(depths, name) {
                  var len = depths.length;
                  for (var i = 0; i < len; i++) {
                    var result = depths[i] && container.lookupProperty(depths[i], name);
                    if (result != null) {
                      return depths[i][name];
                    }
                  }
                },
                lambda: function lambda(current, context) {
                  return typeof current === "function" ? current.call(context) : current;
                },
                escapeExpression: Utils.escapeExpression,
                invokePartial: invokePartialWrapper,
                fn: function fn(i) {
                  var ret2 = templateSpec[i];
                  ret2.decorator = templateSpec[i + "_d"];
                  return ret2;
                },
                programs: [],
                program: function program(i, data, declaredBlockParams, blockParams, depths) {
                  var programWrapper = this.programs[i], fn = this.fn(i);
                  if (data || depths || blockParams || declaredBlockParams) {
                    programWrapper = wrapProgram(this, i, fn, data, declaredBlockParams, blockParams, depths);
                  } else if (!programWrapper) {
                    programWrapper = this.programs[i] = wrapProgram(this, i, fn);
                  }
                  return programWrapper;
                },
                data: function data(value, depth) {
                  while (value && depth--) {
                    value = value._parent;
                  }
                  return value;
                },
                mergeIfNeeded: function mergeIfNeeded(param, common) {
                  var obj = param || common;
                  if (param && common && param !== common) {
                    obj = Utils.extend({}, common, param);
                  }
                  return obj;
                },
                // An empty object to use as replacement for null-contexts
                nullContext: _Object$seal({}),
                noop: env.VM.noop,
                compilerInfo: templateSpec.compiler
              };
              function ret(context) {
                var options = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
                var data = options.data;
                ret._setup(options);
                if (!options.partial && templateSpec.useData) {
                  data = initData(context, data);
                }
                var depths = void 0, blockParams = templateSpec.useBlockParams ? [] : void 0;
                if (templateSpec.useDepths) {
                  if (options.depths) {
                    depths = context != options.depths[0] ? [context].concat(options.depths) : options.depths;
                  } else {
                    depths = [context];
                  }
                }
                function main(context2) {
                  return "" + templateSpec.main(container, context2, container.helpers, container.partials, data, blockParams, depths);
                }
                main = executeDecorators(templateSpec.main, main, container, options.depths || [], data, blockParams);
                return main(context, options);
              }
              ret.isTop = true;
              ret._setup = function(options) {
                if (!options.partial) {
                  var mergedHelpers = Utils.extend({}, env.helpers, options.helpers);
                  wrapHelpersToPassLookupProperty(mergedHelpers, container);
                  container.helpers = mergedHelpers;
                  if (templateSpec.usePartial) {
                    container.partials = container.mergeIfNeeded(options.partials, env.partials);
                  }
                  if (templateSpec.usePartial || templateSpec.useDecorators) {
                    container.decorators = Utils.extend({}, env.decorators, options.decorators);
                  }
                  container.hooks = {};
                  container.protoAccessControl = _internalProtoAccess.createProtoAccessControl(options);
                  var keepHelperInHelpers = options.allowCallsToHelperMissing || templateWasPrecompiledWithCompilerV7;
                  _helpers.moveHelperToHooks(container, "helperMissing", keepHelperInHelpers);
                  _helpers.moveHelperToHooks(container, "blockHelperMissing", keepHelperInHelpers);
                } else {
                  container.protoAccessControl = options.protoAccessControl;
                  container.helpers = options.helpers;
                  container.partials = options.partials;
                  container.decorators = options.decorators;
                  container.hooks = options.hooks;
                }
              };
              ret._child = function(i, data, blockParams, depths) {
                if (templateSpec.useBlockParams && !blockParams) {
                  throw new _exception2["default"]("must pass block params");
                }
                if (templateSpec.useDepths && !depths) {
                  throw new _exception2["default"]("must pass parent depths");
                }
                return wrapProgram(container, i, templateSpec[i], data, 0, blockParams, depths);
              };
              return ret;
            }
            function wrapProgram(container, i, fn, data, declaredBlockParams, blockParams, depths) {
              function prog(context) {
                var options = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
                var currentDepths = depths;
                if (depths && context != depths[0] && !(context === container.nullContext && depths[0] === null)) {
                  currentDepths = [context].concat(depths);
                }
                return fn(container, context, container.helpers, container.partials, options.data || data, blockParams && [options.blockParams].concat(blockParams), currentDepths);
              }
              prog = executeDecorators(fn, prog, container, depths, data, blockParams);
              prog.program = i;
              prog.depth = depths ? depths.length : 0;
              prog.blockParams = declaredBlockParams || 0;
              return prog;
            }
            function resolvePartial(partial, context, options) {
              if (!partial) {
                if (options.name === "@partial-block") {
                  partial = options.data["partial-block"];
                } else {
                  partial = options.partials[options.name];
                }
              } else if (!partial.call && !options.name) {
                options.name = partial;
                partial = options.partials[partial];
              }
              return partial;
            }
            function invokePartial(partial, context, options) {
              var currentPartialBlock = options.data && options.data["partial-block"];
              options.partial = true;
              if (options.ids) {
                options.data.contextPath = options.ids[0] || options.data.contextPath;
              }
              var partialBlock = void 0;
              if (options.fn && options.fn !== noop) {
                (function() {
                  options.data = _base.createFrame(options.data);
                  var fn = options.fn;
                  partialBlock = options.data["partial-block"] = function partialBlockWrapper(context2) {
                    var options2 = arguments.length <= 1 || arguments[1] === void 0 ? {} : arguments[1];
                    options2.data = _base.createFrame(options2.data);
                    options2.data["partial-block"] = currentPartialBlock;
                    return fn(context2, options2);
                  };
                  if (fn.partials) {
                    options.partials = Utils.extend({}, options.partials, fn.partials);
                  }
                })();
              }
              if (partial === void 0 && partialBlock) {
                partial = partialBlock;
              }
              if (partial === void 0) {
                throw new _exception2["default"]("The partial " + options.name + " could not be found");
              } else if (partial instanceof Function) {
                return partial(context, options);
              }
            }
            function noop() {
              return "";
            }
            function initData(context, data) {
              if (!data || !("root" in data)) {
                data = data ? _base.createFrame(data) : {};
                data.root = context;
              }
              return data;
            }
            function executeDecorators(fn, prog, container, depths, data, blockParams) {
              if (fn.decorator) {
                var props = {};
                prog = fn.decorator(prog, props, container, depths && depths[0], data, blockParams, depths);
                Utils.extend(prog, props);
              }
              return prog;
            }
            function wrapHelpersToPassLookupProperty(mergedHelpers, container) {
              _Object$keys(mergedHelpers).forEach(function(helperName) {
                var helper = mergedHelpers[helperName];
                mergedHelpers[helperName] = passLookupPropertyOption(helper, container);
              });
            }
            function passLookupPropertyOption(helper, container) {
              var lookupProperty = container.lookupProperty;
              return _internalWrapHelper.wrapHelper(helper, function(options) {
                return Utils.extend({ lookupProperty }, options);
              });
            }
          }),
          /* 78 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            module2.exports = { "default": __webpack_require__(79), __esModule: true };
          }),
          /* 79 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            __webpack_require__(80);
            module2.exports = __webpack_require__(20).Object.seal;
          }),
          /* 80 */
          /***/
          (function(module2, exports$12, __webpack_require__) {
            var isObject2 = __webpack_require__(39);
            __webpack_require__(63)("seal", function($seal) {
              return function seal(it) {
                return $seal && isObject2(it) ? $seal(it) : it;
              };
            });
          }),
          /* 81 */
          /***/
          (function(module2, exports$12) {
            exports$12.__esModule = true;
            exports$12.wrapHelper = wrapHelper;
            function wrapHelper(helper, transformOptionsFn) {
              if (typeof helper !== "function") {
                return helper;
              }
              var wrapper = function wrapper2() {
                var options = arguments[arguments.length - 1];
                arguments[arguments.length - 1] = transformOptionsFn(options);
                return helper.apply(this, arguments);
              };
              return wrapper;
            }
          }),
          /* 82 */
          /***/
          (function(module2, exports$12) {
            exports$12.__esModule = true;
            exports$12["default"] = function(Handlebars) {
              (function() {
                if (typeof globalThis === "object") return;
                Object.prototype.__defineGetter__("__magic__", function() {
                  return this;
                });
                __magic__.globalThis = __magic__;
                delete Object.prototype.__magic__;
              })();
              var $Handlebars = globalThis.Handlebars;
              Handlebars.noConflict = function() {
                if (globalThis.Handlebars === Handlebars) {
                  globalThis.Handlebars = $Handlebars;
                }
                return Handlebars;
              };
            };
            module2.exports = exports$12["default"];
          })
          /******/
        ])
      );
    });
  })(handlebars_runtime$1);
  return handlebars_runtime$1.exports;
}
var handlebars_runtimeExports = requireHandlebars_runtime();
class HandlebarsTemplateEngine extends BaseTemplateEngine {
  constructor() {
    super();
    this.name = "handlebars";
    this.compiledTemplates = /* @__PURE__ */ new Map();
    this.handlebars = handlebars_runtimeExports.create();
    this.registerDefaultHelpers();
  }
  /**
   * Render a template with Handlebars
   */
  async render(template2, context) {
    try {
      let compiledTemplate = this.compiledTemplates.get(template2);
      if (!compiledTemplate) {
        compiledTemplate = this.handlebars.compile(template2);
        this.compiledTemplates.set(template2, compiledTemplate);
      }
      return compiledTemplate(context);
    } catch (error) {
      throw new Error(
        `Handlebars render error: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
  /**
   * Validate template syntax
   */
  async validate(template2) {
    try {
      this.handlebars.compile(template2);
      return { valid: true };
    } catch (error) {
      return {
        valid: false,
        errors: [error instanceof Error ? error.message : String(error)]
      };
    }
  }
  /**
   * Compile a template for repeated use
   */
  async compile(template2) {
    const compiled = this.handlebars.compile(template2);
    this.compiledTemplates.set(template2, compiled);
    return compiled;
  }
  /**
   * Register a helper function
   */
  registerHelper(name, fn) {
    this.handlebars.registerHelper(name, fn);
  }
  /**
   * Register a partial template
   */
  registerPartial(name, template2) {
    this.handlebars.registerPartial(name, template2);
  }
  /**
   * Register default helpers
   */
  registerDefaultHelpers() {
    this.handlebars.registerHelper("eq", (a, b) => a === b);
    this.handlebars.registerHelper("ne", (a, b) => a !== b);
    this.handlebars.registerHelper("lt", (a, b) => a < b);
    this.handlebars.registerHelper("lte", (a, b) => a <= b);
    this.handlebars.registerHelper("gt", (a, b) => a > b);
    this.handlebars.registerHelper("gte", (a, b) => a >= b);
    this.handlebars.registerHelper("and", (...args) => {
      const values = args.slice(0, -1);
      return values.every((v) => !!v);
    });
    this.handlebars.registerHelper("or", (...args) => {
      const values = args.slice(0, -1);
      return values.some((v) => !!v);
    });
    this.handlebars.registerHelper("not", (value) => !value);
    this.handlebars.registerHelper("length", (value) => {
      if (Array.isArray(value) || typeof value === "string") {
        return value.length;
      }
      return 0;
    });
    this.handlebars.registerHelper("join", (array, separator = ",") => {
      if (Array.isArray(array)) {
        return array.join(separator);
      }
      return "";
    });
    this.handlebars.registerHelper("upper", (str) => {
      if (typeof str === "string") {
        return str.toUpperCase();
      }
      return str;
    });
    this.handlebars.registerHelper("lower", (str) => {
      if (typeof str === "string") {
        return str.toLowerCase();
      }
      return str;
    });
    this.handlebars.registerHelper("capitalize", (str) => {
      if (typeof str === "string" && str.length > 0) {
        return str.charAt(0).toUpperCase() + str.slice(1);
      }
      return str;
    });
    this.handlebars.registerHelper("truncate", (str, length = 100) => {
      if (typeof str === "string" && str.length > length) {
        return str.substring(0, length) + "...";
      }
      return str;
    });
    this.handlebars.registerHelper("default", (value, defaultValue) => {
      return value ?? defaultValue;
    });
    this.handlebars.registerHelper("json", (obj) => {
      try {
        return JSON.stringify(obj, null, 2);
      } catch {
        return String(obj);
      }
    });
    this.handlebars.registerHelper("date", (date2) => {
      try {
        const d = date2 instanceof Date ? date2 : new Date(date2);
        return d.toLocaleDateString();
      } catch {
        return String(date2);
      }
    });
    this.handlebars.registerHelper("formatNumber", (num) => {
      if (typeof num === "number") {
        return num.toLocaleString();
      }
      return num;
    });
  }
  /**
   * Clear the template cache
   */
  clearCache() {
    this.compiledTemplates.clear();
  }
}
function createTemplateEngine(engine) {
  switch (engine) {
    case "simple":
      return new SimpleTemplateEngine();
    case "liquid":
      return new LiquidTemplateEngine();
    default:
      throw new Error(`Unknown template engine: ${engine}`);
  }
}
class TemplateLoader {
  constructor(config) {
    this.engine = config.engine;
    this.kv = config.kv;
    this.localDir = config.localDir || "templates";
    this.defaultVersion = config.defaultVersion || "latest";
    this.cache = /* @__PURE__ */ new Map();
  }
  /**
   * Load and render template
   */
  async render(template2, data = {}, env) {
    const context = {
      env,
      baseDir: process.cwd()
    };
    const resolved = await resolveValue(template2, context);
    const content = typeof resolved.content === "string" ? resolved.content : JSON.stringify(resolved.content);
    return await this.engine.render(content, data);
  }
  /**
   * Parse template reference
   */
  parseTemplateRef(template2) {
    if (template2.startsWith("kv://")) {
      const path = template2.slice(5);
      const [pathPart, version] = path.split("@");
      return {
        type: "kv",
        path: pathPart,
        version: version || this.defaultVersion
      };
    }
    const isFilePath2 = (template2.endsWith(".html") || template2.endsWith(".mjml")) && !template2.includes("<");
    if (isFilePath2) {
      return {
        type: "local",
        path: template2
      };
    }
    return {
      type: "inline",
      path: template2
    };
  }
  /**
   * Load template from storage
   */
  async loadTemplate(ref2) {
    const cacheKey = `${ref2.type}:${ref2.path}${ref2.version ? `@${ref2.version}` : ""}`;
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }
    let content;
    switch (ref2.type) {
      case "kv":
        content = await this.loadFromKv(ref2.path, ref2.version);
        break;
      case "local":
        content = await this.loadFromLocal(ref2.path);
        break;
      case "inline":
        content = ref2.path;
        break;
    }
    this.cache.set(cacheKey, content);
    return content;
  }
  /**
   * Load template from KV
   */
  async loadFromKv(path, version) {
    if (!this.kv) {
      throw new Error("KV namespace not configured for template loading");
    }
    const key = version ? `${path}@${version}` : path;
    const content = await this.kv.get(key, "text");
    if (!content) {
      throw new Error(`Template not found in KV: ${key}`);
    }
    return content;
  }
  /**
   * Load template from local file system
   */
  async loadFromLocal(path) {
    throw new Error(
      "Local file system access not available in Cloudflare Workers. Use KV storage (kv://...) or inline templates instead."
    );
  }
  /**
   * Clear template cache
   */
  clearCache() {
    this.cache.clear();
  }
  /**
   * Preload template into cache
   */
  async preload(template2) {
    const ref2 = this.parseTemplateRef(template2);
    await this.loadTemplate(ref2);
  }
}
class EmailAgent extends BaseAgent {
  constructor(config) {
    super(config);
    const emailConfig = config.config;
    if (!emailConfig?.provider) {
      throw new Error("Email agent requires provider configuration");
    }
    this.provider = createEmailProvider(emailConfig.provider);
    const engine = emailConfig.templateEngine || "simple";
    this.templateEngine = createTemplateEngine(engine);
    this.templateLoader = new TemplateLoader({
      engine: this.templateEngine,
      kv: emailConfig.templatesKv ? config.env?.[emailConfig.templatesKv] || void 0 : void 0,
      defaultVersion: "latest"
    });
    this.rateLimit = emailConfig.rateLimit || 10;
    this.tracking = emailConfig.tracking ?? false;
  }
  /**
   * Execute email sending
   */
  async run(context) {
    const input = context.input;
    if ("recipients" in input && Array.isArray(input.recipients)) {
      return this.sendBatch(input, context);
    }
    return this.sendSingle(input, context);
  }
  /**
   * Send single email
   */
  async sendSingle(input, context) {
    const message2 = await this.buildMessage(input, context);
    const validation = await this.provider.validateConfig();
    if (!validation.valid) {
      throw new Error(`Provider validation failed: ${validation.errors?.join(", ")}`);
    }
    const result = await this.provider.send(message2);
    if (result.status === "failed") {
      throw new Error(`Email send failed: ${result.error}`);
    }
    return {
      messageId: result.messageId,
      status: result.status,
      provider: result.provider,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
  /**
   * Send batch emails
   */
  async sendBatch(input, context) {
    const results = [];
    const errors = [];
    const messageIds = [];
    const delayMs = 1e3 / this.rateLimit;
    let lastSendTime = 0;
    for (const recipient of input.recipients) {
      try {
        const now = Date.now();
        const timeSinceLastSend = now - lastSendTime;
        if (timeSinceLastSend < delayMs) {
          await this.delay(delayMs - timeSinceLastSend);
        }
        lastSendTime = Date.now();
        const emailInput = {
          to: recipient.email,
          subject: input.subject,
          template: input.template,
          data: {
            ...input.commonData,
            ...recipient.data
          }
        };
        const message2 = await this.buildMessage(emailInput, context);
        const result = await this.provider.send(message2);
        results.push(result);
        if (result.status === "sent") {
          messageIds.push(result.messageId);
        } else {
          errors.push({
            email: recipient.email,
            error: result.error || "Unknown error"
          });
        }
      } catch (error) {
        errors.push({
          email: recipient.email,
          error: error instanceof Error ? error.message : "Unknown error"
        });
      }
    }
    const sent = results.filter((r) => r.status === "sent").length;
    const failed = results.length - sent;
    return {
      sent,
      failed,
      messageIds,
      errors: errors.length > 0 ? errors : void 0
    };
  }
  /**
   * Build email message from input
   */
  async buildMessage(input, context) {
    let html = input.html;
    let text = input.text;
    if (input.template) {
      const data = input.data || {};
      html = await this.templateLoader.render(input.template, data, context.env);
      if (!text) {
        text = this.stripHtml(html);
      }
    }
    const message2 = {
      to: input.to,
      cc: input.cc,
      bcc: input.bcc,
      from: input.from,
      replyTo: input.replyTo,
      subject: input.subject,
      html,
      text,
      attachments: input.attachments,
      headers: input.headers,
      tags: input.tags,
      metadata: input.metadata
    };
    if (this.tracking) {
      message2.headers = {
        ...message2.headers,
        "X-Conductor-Tracking": "enabled",
        "X-Conductor-Ensemble": context.state?.ensembleName || "unknown"
      };
    }
    return message2;
  }
  /**
   * Strip HTML tags for plain text version
   */
  stripHtml(html) {
    return html.replace(/<style[^>]*>[\s\S]*?<\/style>/gi, "").replace(/<script[^>]*>[\s\S]*?<\/script>/gi, "").replace(/<[^>]+>/g, "").replace(/&nbsp;/g, " ").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&").replace(/\s+/g, " ").trim();
  }
  /**
   * Delay execution
   */
  delay(ms) {
    return new Promise((resolve2) => setTimeout(resolve2, ms));
  }
}
class BaseSmsProvider {
  /**
   * Normalize recipients to array
   */
  normalizeRecipients(recipients) {
    return Array.isArray(recipients) ? recipients : [recipients];
  }
  /**
   * Validate phone number format (basic E.164 validation)
   */
  validatePhoneNumber(phone) {
    const e164Regex = /^\+[1-9]\d{1,14}$/;
    return e164Regex.test(phone);
  }
  /**
   * Validate required fields
   */
  validateMessage(message2) {
    const errors = [];
    if (!message2.to || Array.isArray(message2.to) && message2.to.length === 0) {
      errors.push("Recipient (to) is required");
    }
    if (!message2.body || message2.body.trim() === "") {
      errors.push("Message body is required");
    }
    const recipients = this.normalizeRecipients(message2.to);
    for (const phone of recipients) {
      if (!this.validatePhoneNumber(phone)) {
        errors.push(
          `Invalid phone number format: ${phone} (must be E.164 format, e.g., +1234567890)`
        );
      }
    }
    if (message2.body.length > 1600) {
      errors.push("Message body exceeds maximum length of 1600 characters");
    }
    return {
      valid: errors.length === 0,
      errors: errors.length > 0 ? errors : void 0
    };
  }
}
class TwilioProvider extends BaseSmsProvider {
  constructor(accountSid, authToken, defaultFrom, messagingServiceSid) {
    super();
    this.accountSid = accountSid;
    this.authToken = authToken;
    this.defaultFrom = defaultFrom;
    this.messagingServiceSid = messagingServiceSid;
    this.name = "twilio";
    this.apiUrl = "https://api.twilio.com/2010-04-01";
  }
  /**
   * Send SMS via Twilio API
   */
  async send(message2) {
    const validation = this.validateMessage(message2);
    if (!validation.valid) {
      return {
        messageId: "",
        status: "failed",
        provider: this.name,
        error: validation.errors?.join(", ")
      };
    }
    try {
      const recipients = this.normalizeRecipients(message2.to);
      if (recipients.length === 1) {
        return await this.sendSingle(message2, recipients[0]);
      }
      const results = [];
      for (const recipient of recipients) {
        const result = await this.sendSingle({ ...message2, to: recipient }, recipient);
        results.push(result);
      }
      return results[0];
    } catch (error) {
      return {
        messageId: "",
        status: "failed",
        provider: this.name,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  /**
   * Send SMS to single recipient
   */
  async sendSingle(message2, recipient) {
    const body = new URLSearchParams();
    body.append("To", recipient);
    body.append("Body", message2.body);
    if (this.messagingServiceSid) {
      body.append("MessagingServiceSid", this.messagingServiceSid);
    } else {
      body.append("From", message2.from || this.defaultFrom);
    }
    if (message2.mediaUrl && message2.mediaUrl.length > 0) {
      message2.mediaUrl.forEach((url2) => {
        body.append("MediaUrl", url2);
      });
    }
    if (message2.metadata?.statusCallback) {
      body.append("StatusCallback", message2.metadata.statusCallback);
    }
    const url = `${this.apiUrl}/Accounts/${this.accountSid}/Messages.json`;
    const auth = btoa(`${this.accountSid}:${this.authToken}`);
    const response = await fetch(url, {
      method: "POST",
      headers: {
        Authorization: `Basic ${auth}`,
        "Content-Type": "application/x-www-form-urlencoded"
      },
      body: body.toString()
    });
    const data = await response.json();
    if (!response.ok) {
      return {
        messageId: "",
        status: "failed",
        provider: this.name,
        error: data.message || data.error_message || `HTTP ${response.status}`
      };
    }
    return {
      messageId: data.sid || "",
      status: this.mapTwilioStatus(data.status || "unknown"),
      provider: this.name
    };
  }
  /**
   * Map Twilio status to our status
   */
  mapTwilioStatus(twilioStatus) {
    switch (twilioStatus) {
      case "sent":
      case "delivered":
        return "sent";
      case "queued":
      case "accepted":
      case "sending":
        return "queued";
      case "failed":
      case "undelivered":
      default:
        return "failed";
    }
  }
  /**
   * Validate configuration
   */
  async validateConfig() {
    const errors = [];
    if (!this.accountSid) {
      errors.push("Twilio Account SID is required");
    }
    if (!this.authToken) {
      errors.push("Twilio Auth Token is required");
    }
    if (!this.messagingServiceSid && !this.defaultFrom) {
      errors.push("Either Twilio Messaging Service SID or default from number is required");
    }
    if (this.defaultFrom && !this.validatePhoneNumber(this.defaultFrom)) {
      errors.push("Default from number must be in E.164 format (e.g., +1234567890)");
    }
    return {
      valid: errors.length === 0,
      errors: errors.length > 0 ? errors : void 0
    };
  }
}
function createSmsProvider(config) {
  const from = config.from || "";
  switch (config.provider) {
    case "twilio":
      if (!config.twilio) {
        throw new Error("Twilio configuration is required");
      }
      if (!config.twilio.accountSid) {
        throw new Error("Twilio Account SID is required");
      }
      if (!config.twilio.authToken) {
        throw new Error("Twilio Auth Token is required");
      }
      return new TwilioProvider(
        config.twilio.accountSid,
        config.twilio.authToken,
        from,
        config.twilio.messagingServiceSid
      );
    default:
      throw new Error(`Unknown SMS provider: ${config.provider}`);
  }
}
class SmsMember extends BaseAgent {
  constructor(config) {
    super(config);
    const smsConfig = config.config;
    if (!smsConfig?.provider) {
      throw new Error("SMS agent requires provider configuration");
    }
    this.provider = createSmsProvider(smsConfig.provider);
    const engine = smsConfig.templateEngine || "simple";
    this.templateEngine = createTemplateEngine(engine);
    this.rateLimit = smsConfig.rateLimit || 10;
  }
  /**
   * Execute SMS sending
   */
  async run(context) {
    const input = context.input;
    if ("recipients" in input && Array.isArray(input.recipients)) {
      return this.sendBatch(input, context);
    }
    return this.sendSingle(input, context);
  }
  /**
   * Send single SMS
   */
  async sendSingle(input, context) {
    const message2 = this.buildMessage(input);
    const validation = await this.provider.validateConfig();
    if (!validation.valid) {
      throw new Error(`Provider validation failed: ${validation.errors?.join(", ")}`);
    }
    const result = await this.provider.send(message2);
    if (result.status === "failed") {
      throw new Error(`SMS send failed: ${result.error}`);
    }
    return {
      messageId: result.messageId,
      status: result.status,
      provider: result.provider,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
  /**
   * Send batch SMS
   */
  async sendBatch(input, context) {
    const results = [];
    const errors = [];
    const messageIds = [];
    const delayMs = 1e3 / this.rateLimit;
    let lastSendTime = 0;
    for (const recipient of input.recipients) {
      try {
        const now = Date.now();
        const timeSinceLastSend = now - lastSendTime;
        if (timeSinceLastSend < delayMs) {
          await this.delay(delayMs - timeSinceLastSend);
        }
        lastSendTime = Date.now();
        const body = await this.renderTemplate(input.body, {
          ...input.commonData,
          ...recipient.data
        });
        const smsInput = {
          to: recipient.phone,
          body,
          mediaUrl: input.mediaUrl
        };
        const message2 = this.buildMessage(smsInput);
        const result = await this.provider.send(message2);
        results.push(result);
        if (result.status === "sent" || result.status === "queued") {
          messageIds.push(result.messageId);
        } else {
          errors.push({
            phone: recipient.phone,
            error: result.error || "Unknown error"
          });
        }
      } catch (error) {
        errors.push({
          phone: recipient.phone,
          error: error instanceof Error ? error.message : "Unknown error"
        });
      }
    }
    const sent = results.filter((r) => r.status === "sent" || r.status === "queued").length;
    const failed = results.length - sent;
    return {
      sent,
      failed,
      messageIds,
      errors: errors.length > 0 ? errors : void 0
    };
  }
  /**
   * Build SMS message from input
   */
  buildMessage(input) {
    return {
      to: input.to,
      from: input.from,
      body: input.body,
      mediaUrl: input.mediaUrl,
      metadata: input.metadata
    };
  }
  /**
   * Render template with variables using template engine
   */
  async renderTemplate(template2, data) {
    return await this.templateEngine.render(template2, data);
  }
  /**
   * Delay execution
   */
  delay(ms) {
    return new Promise((resolve2) => setTimeout(resolve2, ms));
  }
}
async function validateField(field, value, allData, context) {
  const errors = [];
  if (field.disabled || field.readonly) {
    return errors;
  }
  const validation = field.validation;
  if (!validation) {
    return errors;
  }
  if (validation.required) {
    if (isEmpty(value)) {
      const message2 = typeof validation.required === "string" ? validation.required : `${field.label || field.name} is required`;
      errors.push({ field: field.name, message: message2, rule: "required" });
      return errors;
    }
  }
  if (isEmpty(value)) {
    return errors;
  }
  const stringValue = String(value);
  if (validation.email) {
    if (!isValidEmail(stringValue)) {
      const message2 = typeof validation.email === "string" ? validation.email : "Please enter a valid email address";
      errors.push({ field: field.name, message: message2, rule: "email" });
    }
  }
  if (validation.url) {
    if (!isValidUrl(stringValue)) {
      const message2 = typeof validation.url === "string" ? validation.url : "Please enter a valid URL";
      errors.push({ field: field.name, message: message2, rule: "url" });
    }
  }
  if (validation.pattern) {
    const pattern = typeof validation.pattern === "string" ? { regex: validation.pattern, message: "Invalid format" } : validation.pattern;
    const regex = new RegExp(pattern.regex);
    if (!regex.test(stringValue)) {
      errors.push({ field: field.name, message: pattern.message, rule: "pattern" });
    }
  }
  if (field.type === "number" && typeof value === "number") {
    if (validation.min !== void 0) {
      const min = typeof validation.min === "number" ? { value: validation.min, message: `Minimum value is ${validation.min}` } : validation.min;
      if (value < min.value) {
        errors.push({ field: field.name, message: min.message, rule: "min" });
      }
    }
    if (validation.max !== void 0) {
      const max = typeof validation.max === "number" ? { value: validation.max, message: `Maximum value is ${validation.max}` } : validation.max;
      if (value > max.value) {
        errors.push({ field: field.name, message: max.message, rule: "max" });
      }
    }
  }
  if (validation.minLength !== void 0) {
    const minLength = typeof validation.minLength === "number" ? { value: validation.minLength, message: `Minimum length is ${validation.minLength}` } : validation.minLength;
    if (stringValue.length < minLength.value) {
      errors.push({ field: field.name, message: minLength.message, rule: "minLength" });
    }
  }
  if (validation.maxLength !== void 0) {
    const maxLength = typeof validation.maxLength === "number" ? { value: validation.maxLength, message: `Maximum length is ${validation.maxLength}` } : validation.maxLength;
    if (stringValue.length > maxLength.value) {
      errors.push({ field: field.name, message: maxLength.message, rule: "maxLength" });
    }
  }
  if (validation.matches) {
    const matches = typeof validation.matches === "string" ? { field: validation.matches, message: "Fields do not match" } : validation.matches;
    const matchValue = allData[matches.field];
    if (value !== matchValue) {
      errors.push({ field: field.name, message: matches.message, rule: "matches" });
    }
  }
  if (validation.custom) {
    const input = context.input;
    const customValidator = input?.validators?.[validation.custom];
    if (typeof customValidator === "function") {
      const customResult = await customValidator(value, allData, field);
      if (customResult !== true) {
        const message2 = typeof customResult === "string" ? customResult : "Validation failed";
        errors.push({ field: field.name, message: message2, rule: "custom" });
      }
    }
  }
  return errors;
}
function isEmpty(value) {
  if (value === null || value === void 0) {
    return true;
  }
  if (typeof value === "string") {
    return value.trim() === "";
  }
  if (Array.isArray(value)) {
    return value.length === 0;
  }
  return false;
}
function isValidEmail(email) {
  const emailRegex2 = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex2.test(email);
}
function isValidUrl(url) {
  try {
    const parsed = new URL(url);
    return parsed.protocol === "http:" || parsed.protocol === "https:";
  } catch {
    return false;
  }
}
async function renderForm(options) {
  const { config, fields, data, errors, csrfToken, currentStep, stepInfo } = options;
  const style = config.style || {};
  const classes = style.classes || {};
  const errorMap2 = /* @__PURE__ */ new Map();
  for (const error of errors) {
    if (!errorMap2.has(error.field)) {
      errorMap2.set(error.field, []);
    }
    errorMap2.get(error.field).push(error.message);
  }
  let html = `<form
		class="${classes.form || "conductor-form"}"
		method="${config.method || "POST"}"
		${config.action ? `action="${escapeHtml(config.action)}"` : ""}
		novalidate
	>`;
  const title = stepInfo?.title || config.title;
  const description = stepInfo?.description || config.description;
  if (title) {
    html += `<h2 class="form-title">${escapeHtml(title)}</h2>`;
  }
  if (description) {
    html += `<p class="form-description">${escapeHtml(description)}</p>`;
  }
  if (csrfToken) {
    const csrfFieldName = config.csrf?.fieldName || "_csrf";
    html += `<input type="hidden" name="${escapeHtml(csrfFieldName)}" value="${escapeHtml(csrfToken)}">`;
  }
  if (config.honeypot) {
    html += `<input type="text" name="${escapeHtml(config.honeypot)}" value="" style="position:absolute;left:-9999px;" tabindex="-1" autocomplete="off" aria-hidden="true">`;
  }
  if (currentStep) {
    html += `<input type="hidden" name="_currentStep" value="${escapeHtml(currentStep)}">`;
  }
  for (const field of fields) {
    html += renderField(field, data[field.name], errorMap2.get(field.name), classes);
  }
  if (config.captcha) {
    html += renderCaptcha(config.captcha.type, config.captcha.siteKey, config.captcha);
  }
  html += `<div class="form-actions">
		<button type="submit" class="${classes.button || "form-submit"}">
			${escapeHtml(config.submitText || "Submit")}
		</button>
	</div>`;
  html += `</form>`;
  if (style.includeDefaultStyles !== false) {
    html = renderDefaultStyles() + html;
  }
  return html;
}
function renderField(field, value, errors, classes) {
  const hasError = errors && errors.length > 0;
  const fieldClass = `${classes.field || "form-field"} ${hasError ? "has-error" : ""}`.trim();
  let html = `<div class="${fieldClass}">`;
  if (field.label && field.type !== "hidden") {
    const required = field.validation?.required ? ' <span class="required">*</span>' : "";
    html += `<label for="${field.name}" class="${classes.label || "form-label"}">
			${escapeHtml(field.label)}${required}
		</label>`;
  }
  html += renderFieldInput(field, value, classes);
  if (field.help) {
    html += `<div class="${classes.help || "form-help"}">${escapeHtml(field.help)}</div>`;
  }
  if (hasError) {
    for (const error of errors) {
      html += `<div class="${classes.error || "form-error"}">${escapeHtml(error)}</div>`;
    }
  }
  html += `</div>`;
  return html;
}
function renderFieldInput(field, value, classes) {
  const inputClass = `${classes.input || "form-input"} ${field.className || ""}`.trim();
  const commonAttrs = `
		name="${escapeHtml(field.name)}"
		id="${field.name}"
		class="${inputClass}"
		${field.placeholder ? `placeholder="${escapeHtml(field.placeholder)}"` : ""}
		${field.disabled ? "disabled" : ""}
		${field.readonly ? "readonly" : ""}
		${field.autocomplete ? `autocomplete="${escapeHtml(field.autocomplete)}"` : ""}
	`.trim();
  switch (field.type) {
    case "textarea":
      return `<textarea ${commonAttrs} ${field.rows ? `rows="${field.rows}"` : ""} ${field.cols ? `cols="${field.cols}"` : ""}>${escapeHtml(String(value || field.default || ""))}</textarea>`;
    case "select":
      return renderSelectField(field, value, commonAttrs);
    case "checkbox":
      return renderCheckboxField(field, value, commonAttrs);
    case "radio":
      return renderRadioField(field, value);
    case "hidden":
      return `<input type="hidden" name="${escapeHtml(field.name)}" value="${escapeHtml(String(value || field.default || ""))}">`;
    default:
      return `<input
				type="${field.type}"
				${commonAttrs}
				${field.min !== void 0 ? `min="${field.min}"` : ""}
				${field.max !== void 0 ? `max="${field.max}"` : ""}
				${field.step !== void 0 ? `step="${field.step}"` : ""}
				${field.accept ? `accept="${escapeHtml(field.accept)}"` : ""}
				value="${escapeHtml(String(value || field.default || ""))}"
			>`;
  }
}
function renderSelectField(field, value, commonAttrs) {
  let html = `<select ${commonAttrs} ${field.multiple ? "multiple" : ""}>`;
  const options = normalizeOptions(field.options || []);
  const selectedValues = field.multiple && Array.isArray(value) ? value : [value];
  for (const option of options) {
    const selected = selectedValues.includes(option.value) || option.selected;
    html += `<option value="${escapeHtml(option.value)}" ${selected ? "selected" : ""} ${option.disabled ? "disabled" : ""}>
			${escapeHtml(option.label)}
		</option>`;
  }
  html += `</select>`;
  return html;
}
function renderCheckboxField(field, value, commonAttrs) {
  const checked = Boolean(value || field.default);
  return `<input type="checkbox" ${commonAttrs} ${checked ? "checked" : ""} value="true">`;
}
function renderRadioField(field, value, commonAttrs) {
  const options = normalizeOptions(field.options || []);
  let html = "";
  for (const option of options) {
    const checked = value === option.value || option.selected;
    html += `<label class="radio-option">
			<input
				type="radio"
				name="${escapeHtml(field.name)}"
				value="${escapeHtml(option.value)}"
				${checked ? "checked" : ""}
				${option.disabled ? "disabled" : ""}
			>
			${escapeHtml(option.label)}
		</label>`;
  }
  return html;
}
function normalizeOptions(options) {
  return options.map((opt) => typeof opt === "string" ? { label: opt, value: opt } : opt);
}
function renderCaptcha(type, siteKey, config) {
  switch (type) {
    case "turnstile":
      return `<div class="cf-turnstile"
				data-sitekey="${escapeHtml(siteKey)}"
				data-theme="${config.theme || "auto"}"
				data-size="${config.size || "normal"}">
			</div>
			<script src="https://challenges.cloudflare.com/turnstile/v0/api.js" async defer><\/script>`;
    case "recaptcha":
      return `<div class="g-recaptcha"
				data-sitekey="${escapeHtml(siteKey)}"
				data-theme="${config.theme || "light"}"
				data-size="${config.size || "normal"}">
			</div>
			<script src="https://www.google.com/recaptcha/api.js" async defer><\/script>`;
    case "hcaptcha":
      return `<div class="h-captcha"
				data-sitekey="${escapeHtml(siteKey)}"
				data-theme="${config.theme || "light"}"
				data-size="${config.size || "normal"}">
			</div>
			<script src="https://js.hcaptcha.com/1/api.js" async defer><\/script>`;
    default:
      return "";
  }
}
function renderDefaultStyles() {
  return `<style>
		.conductor-form {
			max-width: 600px;
			margin: 0 auto;
			padding: 2rem;
		}
		.form-title {
			margin: 0 0 0.5rem;
			font-size: 1.75rem;
			font-weight: 600;
		}
		.form-description {
			margin: 0 0 1.5rem;
			color: #666;
		}
		.form-field {
			margin-bottom: 1.5rem;
		}
		.form-label {
			display: block;
			margin-bottom: 0.5rem;
			font-weight: 500;
		}
		.required {
			color: #e53e3e;
		}
		.form-input, .form-input textarea, .form-input select {
			width: 100%;
			padding: 0.5rem 0.75rem;
			border: 1px solid #d1d5db;
			border-radius: 0.375rem;
			font-size: 1rem;
			transition: border-color 0.15s;
		}
		.form-input:focus {
			outline: none;
			border-color: #3b82f6;
			box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.1);
		}
		.form-help {
			margin-top: 0.25rem;
			font-size: 0.875rem;
			color: #6b7280;
		}
		.form-error {
			margin-top: 0.25rem;
			font-size: 0.875rem;
			color: #e53e3e;
		}
		.has-error .form-input {
			border-color: #e53e3e;
		}
		.radio-option {
			display: block;
			margin-bottom: 0.5rem;
		}
		.radio-option input {
			margin-right: 0.5rem;
		}
		.form-actions {
			margin-top: 2rem;
		}
		.form-submit {
			padding: 0.75rem 1.5rem;
			background-color: #3b82f6;
			color: white;
			border: none;
			border-radius: 0.375rem;
			font-size: 1rem;
			font-weight: 500;
			cursor: pointer;
			transition: background-color 0.15s;
		}
		.form-submit:hover {
			background-color: #2563eb;
		}
		.form-submit:disabled {
			opacity: 0.5;
			cursor: not-allowed;
		}
	</style>`;
}
function escapeHtml(str) {
  const map2 = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#39;"
  };
  return str.replace(/[&<>"']/g, (char) => map2[char]);
}
async function generateCsrfToken(config, env) {
  const secret = config.secret || "default-csrf-secret";
  const expiresIn = config.expiresIn || 3600;
  const tokenValue = generateRandomString(32);
  const expiresAt = Date.now() + expiresIn * 1e3;
  const payload = {
    value: tokenValue,
    expiresAt
  };
  const signature = await signData(JSON.stringify(payload), secret);
  const token = btoa(JSON.stringify({ ...payload, signature }));
  const kv = env.CSRF_TOKENS;
  if (kv) {
    await kv.put(tokenValue, JSON.stringify(payload), {
      expirationTtl: expiresIn
    });
  }
  return token;
}
async function validateCsrfToken(token, config, env) {
  if (!token) {
    return false;
  }
  try {
    const secret = config.secret || "default-csrf-secret";
    const decoded = JSON.parse(atob(token));
    const { value, expiresAt, signature } = decoded;
    if (Date.now() > expiresAt) {
      return false;
    }
    const payload = { value, expiresAt };
    const expectedSignature = await signData(JSON.stringify(payload), secret);
    if (signature !== expectedSignature) {
      return false;
    }
    const kv = env.CSRF_TOKENS;
    if (kv) {
      const stored = await kv.get(value);
      if (!stored) {
        return false;
      }
      await kv.delete(value);
    }
    return true;
  } catch (error) {
    return false;
  }
}
function generateRandomString(length) {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  let result = "";
  if (typeof crypto !== "undefined" && crypto.getRandomValues) {
    const array = new Uint8Array(length);
    crypto.getRandomValues(array);
    for (let i = 0; i < length; i++) {
      result += chars[array[i] % chars.length];
    }
  } else {
    for (let i = 0; i < length; i++) {
      result += chars[Math.floor(Math.random() * chars.length)];
    }
  }
  return result;
}
async function signData(data, secret) {
  if (typeof crypto !== "undefined" && crypto.subtle) {
    const encoder2 = new TextEncoder();
    const keyData = encoder2.encode(secret);
    const messageData = encoder2.encode(data);
    const key = await crypto.subtle.importKey(
      "raw",
      keyData,
      { name: "HMAC", hash: "SHA-256" },
      false,
      ["sign"]
    );
    const signature = await crypto.subtle.sign("HMAC", key, messageData);
    return Array.from(new Uint8Array(signature)).map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  return simpleHash(data + secret);
}
function simpleHash(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash;
  }
  return Math.abs(hash).toString(16);
}
async function checkRateLimit(identifier, config, kv) {
  if (!kv) {
    return {
      allowed: true,
      remaining: config.max,
      reset: Date.now() + config.window * 1e3,
      limit: config.max
    };
  }
  const key = `rate-limit:${identifier}`;
  const now = Date.now();
  const windowMs = config.window * 1e3;
  const stored = await kv.get(key, "json");
  let data;
  if (stored) {
    data = stored;
    if (now > data.resetAt) {
      data = {
        count: 0,
        resetAt: now + windowMs
      };
    }
  } else {
    data = {
      count: 0,
      resetAt: now + windowMs
    };
  }
  if (data.count >= config.max) {
    return {
      allowed: false,
      remaining: 0,
      reset: data.resetAt,
      limit: config.max
    };
  }
  data.count++;
  const ttl = Math.ceil((data.resetAt - now) / 1e3);
  await kv.put(key, JSON.stringify(data), {
    expirationTtl: ttl
  });
  return {
    allowed: true,
    remaining: config.max - data.count,
    reset: data.resetAt,
    limit: config.max
  };
}
class FormAgent extends BaseAgent {
  constructor(config) {
    super(config);
    this.formConfig = config.config || {};
    this.validateConfig();
  }
  /**
   * Validate agent configuration
   */
  validateConfig() {
    if (!this.formConfig.fields && !this.formConfig.steps) {
      throw new Error("Form agent requires either fields or steps configuration");
    }
    if (this.formConfig.fields && this.formConfig.steps) {
      throw new Error("Form agent cannot have both fields and steps - use one or the other");
    }
    if (this.formConfig.captcha) {
      if (!this.formConfig.captcha.siteKey) {
        throw new Error("CAPTCHA configuration requires siteKey");
      }
    }
    if (this.formConfig.csrf?.enabled) {
      if (!this.formConfig.csrf.secret) {
        throw new Error("CSRF protection requires a secret");
      }
    }
  }
  /**
   * Execute form operation
   */
  async run(context) {
    const input = context.input;
    const mode = input.mode || "render";
    if (this.formConfig.rateLimit) {
      const identifier = input.request?.ip || "anonymous";
      const rateLimitResult = await checkRateLimit(
        identifier,
        this.formConfig.rateLimit,
        context.env.RATE_LIMIT
      );
      if (!rateLimitResult.allowed) {
        return {
          valid: false,
          errors: [
            {
              field: "_form",
              message: "Rate limit exceeded. Please try again later.",
              rule: "rate_limit"
            }
          ],
          rateLimit: {
            remaining: rateLimitResult.remaining,
            reset: rateLimitResult.reset
          }
        };
      }
    }
    switch (mode) {
      case "render":
        return this.renderForm(input, context);
      case "validate":
        return this.validateForm(input, context);
      case "submit":
        return this.submitForm(input, context);
      default:
        throw new Error(`Invalid form mode: ${mode}`);
    }
  }
  /**
   * Render form HTML
   */
  async renderForm(input, context) {
    let csrfToken;
    if (this.formConfig.csrf?.enabled) {
      csrfToken = await generateCsrfToken(this.formConfig.csrf, context.env);
    }
    const currentStep = this.getCurrentStep(input);
    const fields = this.getFieldsForStep(currentStep);
    const html = await renderForm({
      config: this.formConfig,
      fields,
      data: input.data || {},
      csrfToken,
      currentStep: currentStep?.id,
      stepInfo: currentStep || void 0,
      errors: []
    });
    return {
      html,
      currentStep: currentStep?.id,
      csrfToken,
      valid: true
    };
  }
  /**
   * Validate form data
   */
  async validateForm(input, context) {
    const data = input.data || {};
    const errors = [];
    if (this.formConfig.honeypot && data[this.formConfig.honeypot]) {
      return {
        valid: false,
        errors: [{ field: "_form", message: "Form submission failed", rule: "honeypot" }]
      };
    }
    if (this.formConfig.csrf?.enabled) {
      const csrfToken = data[this.formConfig.csrf.fieldName || "_csrf"];
      const isValid2 = await validateCsrfToken(csrfToken, this.formConfig.csrf, context.env);
      if (!isValid2) {
        errors.push({
          field: "_csrf",
          message: "Invalid or expired security token",
          rule: "csrf"
        });
      }
    }
    const currentStep = this.getCurrentStep(input);
    const fields = this.getFieldsForStep(currentStep);
    for (const field of fields) {
      const value = data[field.name];
      const fieldErrors = await validateField(field, value, data, context);
      errors.push(...fieldErrors);
    }
    const sanitizedData = this.sanitizeData(data, fields);
    return {
      valid: errors.length === 0,
      errors: errors.length > 0 ? errors : void 0,
      data: sanitizedData,
      currentStep: currentStep?.id
    };
  }
  /**
   * Submit form (validate + return next step/completion)
   */
  async submitForm(input, context) {
    const validationResult = await this.validateForm(input, context);
    if (!validationResult.valid) {
      return validationResult;
    }
    if (this.formConfig.steps) {
      const currentStepIndex = this.formConfig.steps.findIndex(
        (step2) => step2.id === input.currentStep
      );
      const nextStep = this.formConfig.steps[currentStepIndex + 1];
      return {
        ...validationResult,
        currentStep: input.currentStep,
        nextStep: nextStep?.id,
        isLastStep: !nextStep
      };
    }
    return {
      ...validationResult,
      isLastStep: true
    };
  }
  /**
   * Get current step for multi-step forms
   */
  getCurrentStep(input) {
    if (!this.formConfig.steps) {
      return null;
    }
    if (input.currentStep) {
      const step2 = this.formConfig.steps.find((s) => s.id === input.currentStep);
      if (step2) return step2;
    }
    return this.formConfig.steps[0];
  }
  /**
   * Get fields for current step or all fields
   */
  getFieldsForStep(step2) {
    if (step2) {
      return step2.fields;
    }
    return this.formConfig.fields || [];
  }
  /**
   * Sanitize form data
   */
  sanitizeData(data, fields) {
    const sanitized = {};
    for (const field of fields) {
      const value = data[field.name];
      if (value === void 0 || value === null) {
        continue;
      }
      switch (field.type) {
        case "email":
          sanitized[field.name] = String(value).toLowerCase().trim();
          break;
        case "number":
          sanitized[field.name] = Number(value);
          break;
        case "checkbox":
          sanitized[field.name] = Boolean(value);
          break;
        case "select":
          if (field.multiple && Array.isArray(value)) {
            sanitized[field.name] = value.map((v) => String(v).trim());
          } else {
            sanitized[field.name] = String(value).trim();
          }
          break;
        case "textarea":
        case "text":
        case "password":
        case "tel":
        case "url":
        default:
          sanitized[field.name] = String(value).trim();
      }
    }
    return sanitized;
  }
}
function detectTemplateEngine(key, content) {
  if (key.endsWith(".liquid")) {
    return "liquid";
  }
  if (content && /\{%.*%\}/.test(content)) {
    return "liquid";
  }
  return "simple";
}
async function loadTemplate(source, env) {
  if (source.inline) {
    const engine = source.engine || detectTemplateEngine("inline", source.inline);
    return {
      content: source.inline,
      engine,
      source: "inline"
    };
  }
  if (source.kv) {
    if (!env?.TEMPLATES) {
      throw new Error("KV namespace TEMPLATES is not configured");
    }
    const content = await env.TEMPLATES.get(source.kv, "text");
    if (!content) {
      throw new Error(`Template not found in KV: ${source.kv}`);
    }
    const engine = source.engine || detectTemplateEngine(source.kv, content);
    return {
      content,
      engine,
      source: "kv"
    };
  }
  if (source.r2) {
    if (!env?.ASSETS) {
      throw new Error("R2 bucket ASSETS is not configured");
    }
    const object = await env.ASSETS.get(source.r2);
    if (!object) {
      throw new Error(`Template not found in R2: ${source.r2}`);
    }
    const content = await object.text();
    const engine = source.engine || detectTemplateEngine(source.r2, content);
    return {
      content,
      engine,
      source: "r2"
    };
  }
  if (source.file) {
    throw new Error(
      "File-based templates are not supported in Cloudflare Workers. Use inline, KV (TEMPLATES), or R2 (ASSETS) instead."
    );
  }
  throw new Error("No valid template source specified (inline, kv, or r2)");
}
function normalizeTemplateSource(source) {
  if (typeof source === "string") {
    if (source.startsWith("kv://")) {
      return { kv: source.slice(5) };
    }
    if (source.startsWith("r2://")) {
      return { r2: source.slice(5) };
    }
    if (source.startsWith("file://")) {
      return { file: source.slice(7) };
    }
    return { inline: source };
  }
  return source;
}
class ComponentLoader {
  constructor(options) {
    this.kv = options.kv;
    this.cache = options.cache;
    this.logger = options.logger;
    this.defaultVersion = options.defaultVersion || "latest";
  }
  /**
   * Parse component URI
   *
   * Supports:
   * - template://components/header          (defaults to @latest)
   * - template://components/header@latest
   * - template://components/header@v1.0.0
   * - prompt://analyze-company@prod
   */
  parseURI(uri) {
    const match = uri.match(/^(\w+):\/\/([^@]+)(?:@(.+))?$/);
    if (!match) {
      throw new Error(
        `Invalid component URI: ${uri}
Expected format: {protocol}://{path}[@{version}]
Examples:
  - template://components/header
  - template://components/header@latest
  - prompt://analyze-company@v1.0.0`
      );
    }
    const [, protocol, path, version] = match;
    const validProtocols = [
      "template",
      "prompt",
      "query",
      "config",
      "script",
      "schema",
      "docs"
    ];
    if (!validProtocols.includes(protocol)) {
      throw new Error(
        `Invalid protocol: ${protocol}
Valid protocols: ${validProtocols.join(", ")}`
      );
    }
    return {
      protocol,
      path,
      version: version || this.defaultVersion,
      // Default to "latest"
      originalURI: uri
    };
  }
  /**
   * Map protocol to KV key prefix
   */
  getPrefix(protocol) {
    const prefixMap = {
      template: "templates",
      prompt: "prompts",
      query: "queries",
      config: "configs",
      script: "scripts",
      schema: "schemas",
      docs: "docs"
    };
    return prefixMap[protocol];
  }
  /**
   * Build KV key from parsed URI
   */
  buildKVKey(parsed) {
    const prefix = this.getPrefix(parsed.protocol);
    return `${prefix}/${parsed.path}@${parsed.version}`;
  }
  /**
   * Build cache key for component
   */
  buildCacheKey(uri) {
    return `components:${uri}`;
  }
  /**
   * Load component content from KV with standard Conductor caching
   */
  async load(uri, options) {
    const cacheKey = this.buildCacheKey(uri);
    const bypass = options?.cache?.bypass ?? false;
    const ttl = options?.cache?.ttl ?? 3600;
    if (this.cache && !bypass) {
      const cacheResult = await this.cache.get(cacheKey);
      if (cacheResult.success && cacheResult.value !== null) {
        this.logger?.debug("Component cache hit", { uri, cacheKey });
        return cacheResult.value;
      }
    }
    const parsed = this.parseURI(uri);
    const kvKey = this.buildKVKey(parsed);
    this.logger?.debug("Loading component from KV", { uri, kvKey, bypass });
    const content = await this.kv.get(kvKey, "text");
    if (!content) {
      this.logger?.warn("Component not found", { uri, kvKey });
      throw new Error(
        `Component not found: ${uri}
KV key: ${kvKey}
Make sure the component is deployed to KV with:
  edgit components add <name> <path> ${parsed.protocol}
  edgit tag create <name> ${parsed.version}
  edgit deploy set <name> ${parsed.version} --to production`
      );
    }
    if (this.cache && !bypass) {
      const cacheResult = await this.cache.set(cacheKey, content, { ttl });
      if (cacheResult.success) {
        this.logger?.debug("Component cached", { uri, cacheKey, ttl });
      }
    }
    return content;
  }
  /**
   * Load and parse JSON component
   */
  async loadJSON(uri, options) {
    const content = await this.load(uri, options);
    try {
      return JSON.parse(content);
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      this.logger?.error("JSON parse error", err, { uri });
      throw new Error(`Failed to parse JSON component: ${uri}
Error: ${err.message}`);
    }
  }
  /**
   * Load and evaluate compiled component (for JSX components/pages)
   *
   * @deprecated This method uses new Function() which is blocked in Cloudflare Workers.
   * For scripts, use the ScriptLoader with bundled scripts instead:
   *
   * ```typescript
   * import { scriptsMap } from 'virtual:conductor-scripts'
   * import { createScriptLoader } from '@ensemble-edge/conductor'
   *
   * const loader = createScriptLoader(scriptsMap)
   * const handler = loader.resolve('script://my-script')
   * ```
   *
   * For other compiled components, bundle them at build time using Vite plugins.
   */
  async loadCompiled(uri, options) {
    this.logger?.warn("loadCompiled() is deprecated and will not work in Cloudflare Workers", {
      uri
    });
    const content = await this.load(uri, options);
    try {
      const module = new Function("exports", content);
      const exports$1 = {};
      module(exports$1);
      return exports$1.default || exports$1;
    } catch (error) {
      const err = error instanceof Error ? error : new Error(String(error));
      this.logger?.error("Component compilation error", err, { uri });
      throw new Error(
        `Failed to load compiled component: ${uri}
Error: ${err.message}

Note: This method uses new Function() which is blocked in Cloudflare Workers.
For Workers compatibility, use bundled scripts via script:// URIs instead.
See: https://docs.ensemble.ai/conductor/guides/migrate-inline-code`
      );
    }
  }
  /**
   * Check if a component exists in KV
   */
  async exists(uri) {
    try {
      const parsed = this.parseURI(uri);
      const kvKey = this.buildKVKey(parsed);
      const metadata = await this.kv.getWithMetadata(kvKey);
      return metadata.value !== null;
    } catch (error) {
      this.logger?.debug("Component exists check failed", { uri, error });
      return false;
    }
  }
  /**
   * List all versions of a component
   */
  async listVersions(protocol, path) {
    const prefix = this.getPrefix(protocol);
    const listPrefix = `${prefix}/${path}@`;
    const list = await this.kv.list({ prefix: listPrefix });
    return list.keys.map((key) => {
      const match = key.name.match(/@(.+)$/);
      return match ? match[1] : "unknown";
    });
  }
  /**
   * Invalidate cache for a component
   */
  async invalidateCache(uri) {
    if (this.cache) {
      const cacheKey = this.buildCacheKey(uri);
      const result = await this.cache.delete(cacheKey);
      if (result.success) {
        this.logger?.info("Component cache invalidated", { uri, cacheKey });
      }
    }
  }
}
function createComponentLoader(options) {
  return new ComponentLoader(options);
}
function serializeCookie(name, value, options = {}) {
  const pairs2 = [`${encodeURIComponent(name)}=${encodeURIComponent(value)}`];
  if (options.maxAge !== void 0) {
    pairs2.push(`Max-Age=${options.maxAge}`);
  }
  if (options.expires) {
    pairs2.push(`Expires=${options.expires.toUTCString()}`);
  }
  if (options.domain) {
    pairs2.push(`Domain=${options.domain}`);
  }
  if (options.path) {
    pairs2.push(`Path=${options.path}`);
  } else {
    pairs2.push("Path=/");
  }
  if (options.secure) {
    pairs2.push("Secure");
  }
  if (options.httpOnly) {
    pairs2.push("HttpOnly");
  }
  if (options.sameSite) {
    const sameSite = options.sameSite.charAt(0).toUpperCase() + options.sameSite.slice(1);
    pairs2.push(`SameSite=${sameSite}`);
  }
  return pairs2.join("; ");
}
async function signCookie(value, secret) {
  const encoder2 = new TextEncoder();
  const key = await crypto.subtle.importKey(
    "raw",
    encoder2.encode(secret),
    { name: "HMAC", hash: "SHA-256" },
    false,
    ["sign"]
  );
  const signature = await crypto.subtle.sign("HMAC", key, encoder2.encode(value));
  const signatureBase64 = btoa(String.fromCharCode(...new Uint8Array(signature)));
  return `${value}.${signatureBase64}`;
}
async function unsignCookie(signedValue, secret) {
  const lastDotIndex = signedValue.lastIndexOf(".");
  if (lastDotIndex === -1) {
    return null;
  }
  const value = signedValue.slice(0, lastDotIndex);
  const signatureBase64 = signedValue.slice(lastDotIndex + 1);
  try {
    const expectedSigned = await signCookie(value, secret);
    const expectedSignature = expectedSigned.slice(expectedSigned.lastIndexOf(".") + 1);
    if (signatureBase64 === expectedSignature) {
      return { name: "", value, valid: true };
    }
    return { name: "", value, valid: false };
  } catch {
    return null;
  }
}
async function createSetCookieHeader(cookie, secret) {
  let value = cookie.value;
  if (cookie.options?.signed && secret) {
    value = await signCookie(value, secret);
  }
  return serializeCookie(cookie.name, value, cookie.options);
}
function createDeleteCookie(name, options = {}) {
  return serializeCookie(name, "", {
    ...options,
    expires: /* @__PURE__ */ new Date(0),
    maxAge: 0
  });
}
async function parseSignedCookies(cookies, secret) {
  const parsed = {};
  for (const [name, value] of Object.entries(cookies)) {
    const unsigned = await unsignCookie(value, secret);
    if (unsigned) {
      parsed[name] = { ...unsigned, name };
    } else {
      parsed[name] = { name, value, valid: void 0 };
    }
  }
  return parsed;
}
function isValidCookieName(name) {
  const invalidChars = /[()<>@,;:\\"\/\[\]?={}]/;
  return name.length > 0 && !invalidChars.test(name);
}
function mergeCookieOptions(options, defaults) {
  return {
    ...defaults,
    ...options
  };
}
class HtmlMember extends BaseAgent {
  constructor(config) {
    super(config);
    const rawConfig = config.config || {};
    this.htmlConfig = this.normalizeConfig(rawConfig);
    this.validateConfig();
  }
  /**
   * Normalize YAML config format to typed config
   *
   * Handles the common YAML pattern:
   *   config:
   *     templateEngine: liquid
   *     template: |
   *       <html>...
   *
   * Converts to:
   *   template: { inline: "<html>...", engine: "liquid" }
   */
  normalizeConfig(rawConfig) {
    const { template: template2, templateEngine, ...rest } = rawConfig;
    if (template2 && typeof template2 === "object" && !Array.isArray(template2)) {
      const templateObj = template2;
      if ("inline" in templateObj || "kv" in templateObj || "r2" in templateObj || "file" in templateObj) {
        if (templateEngine && !templateObj.engine) {
          templateObj.engine = templateEngine;
        }
        return {
          ...rest,
          template: templateObj
        };
      }
    }
    if (typeof template2 === "string") {
      return {
        ...rest,
        template: {
          inline: template2,
          engine: templateEngine
        }
      };
    }
    return rawConfig;
  }
  /**
   * Validate agent configuration
   */
  validateConfig() {
    if (!this.htmlConfig.template) {
      throw new Error("HTML agent requires a template configuration");
    }
  }
  /**
   * Execute HTML rendering
   */
  async run(context) {
    const startTime = Date.now();
    const input = context.input;
    const templateSource = input.template ? normalizeTemplateSource(input.template) : this.htmlConfig.template;
    const templateResult = await loadTemplate(templateSource, {
      TEMPLATES: context.env.KV,
      ASSETS: context.env.STORAGE
    });
    const requestCookies = input.cookies || {};
    let readCookies = {};
    if (Object.keys(requestCookies).length > 0) {
      if (this.htmlConfig.cookieSecret) {
        const parsed = await parseSignedCookies(requestCookies, this.htmlConfig.cookieSecret);
        readCookies = Object.entries(parsed).reduce(
          (acc, [name, cookie]) => {
            acc[name] = cookie.value;
            return acc;
          },
          {}
        );
      } else {
        readCookies = requestCookies;
      }
    }
    const engine = createTemplateEngine(templateResult.engine);
    if (context.env.COMPONENTS && engine instanceof SimpleTemplateEngine) {
      let cache2;
      if (context.env.CACHE) {
        const { MemoryCache } = await import("./cache-BcDDTYOs.js");
        cache2 = new MemoryCache({
          defaultTTL: 3600
        });
      }
      const componentLoader = createComponentLoader({
        kv: context.env.COMPONENTS,
        cache: cache2,
        logger: context.logger
      });
      engine.setComponentLoader(componentLoader);
    }
    const templateContext = {
      data: {
        ...input.data,
        // Add cookies to template data
        cookies: readCookies
      },
      helpers: this.getDefaultHelpers(),
      partials: {}
    };
    let html = await engine.render(templateResult.content, templateContext);
    if (input.layout && engine instanceof SimpleTemplateEngine) {
      const layoutContent = await this.loadLayoutContent(input.layout, context, engine);
      if (layoutContent) {
        html = await engine.render(layoutContent, {
          data: {
            ...templateContext.data,
            content: html
            // Make rendered HTML available as {{content}}
          },
          helpers: templateContext.helpers,
          partials: templateContext.partials
        });
      }
    }
    const renderOptions = { ...this.htmlConfig.renderOptions, ...input.renderOptions };
    if (renderOptions?.inlineCss) {
      html = await this.inlineCss(html);
    }
    if (renderOptions?.minify) {
      html = this.minifyHtml(html);
    }
    const setCookieHeaders = [];
    if (input.setCookies && input.setCookies.length > 0) {
      for (const cookie of input.setCookies) {
        if (!isValidCookieName(cookie.name)) {
          throw new Error(`Invalid cookie name: ${cookie.name}`);
        }
        const options = mergeCookieOptions(cookie.options, this.htmlConfig.defaultCookieOptions);
        const header = await createSetCookieHeader(
          { ...cookie, options },
          this.htmlConfig.cookieSecret
        );
        setCookieHeaders.push(header);
      }
    }
    if (input.deleteCookies && input.deleteCookies.length > 0) {
      for (const cookieName of input.deleteCookies) {
        const deleteHeader = createDeleteCookie(cookieName, this.htmlConfig.defaultCookieOptions);
        setCookieHeaders.push(deleteHeader);
      }
    }
    const renderTime = Date.now() - startTime;
    return {
      html,
      cookies: setCookieHeaders.length > 0 ? setCookieHeaders : void 0,
      readCookies: Object.keys(readCookies).length > 0 ? readCookies : void 0,
      engine: templateResult.engine,
      metadata: {
        renderTime,
        templateSize: templateResult.content.length,
        outputSize: html.length,
        cssInlined: renderOptions?.inlineCss || false,
        minified: renderOptions?.minify || false
      }
    };
  }
  /**
   * Load layout content from ComponentLoader or registered partial
   */
  async loadLayoutContent(layout, context, engine) {
    if (layout.includes("://")) {
      if (context.env.COMPONENTS) {
        let cache2;
        if (context.env.CACHE) {
          const { MemoryCache } = await import("./cache-BcDDTYOs.js");
          cache2 = new MemoryCache({
            defaultTTL: 3600
          });
        }
        const componentLoader = createComponentLoader({
          kv: context.env.COMPONENTS,
          cache: cache2,
          logger: context.logger
        });
        try {
          return await componentLoader.load(layout);
        } catch (error) {
          context.logger?.warn("Failed to load layout", {
            layout,
            error: error instanceof Error ? error.message : String(error)
          });
          return null;
        }
      }
    }
    return null;
  }
  /**
   * Get default template helpers
   */
  getDefaultHelpers() {
    return {
      // Date formatting
      formatDate: (date2, format2) => {
        const d = typeof date2 === "string" ? new Date(date2) : date2;
        return d.toLocaleDateString("en-US", {
          year: "numeric",
          month: "long",
          day: "numeric"
        });
      },
      // String helpers
      uppercase: (str) => String(str).toUpperCase(),
      lowercase: (str) => String(str).toLowerCase(),
      capitalize: (str) => {
        const s = String(str);
        return s.charAt(0).toUpperCase() + s.slice(1);
      },
      // Number formatting
      currency: (amount, currency = "USD") => {
        return new Intl.NumberFormat("en-US", {
          style: "currency",
          currency: String(currency)
        }).format(Number(amount));
      },
      // Conditional helpers
      eq: (a, b) => a === b,
      ne: (a, b) => a !== b,
      lt: (a, b) => Number(a) < Number(b),
      gt: (a, b) => Number(a) > Number(b),
      and: (...args) => args.every(Boolean),
      or: (...args) => args.some(Boolean)
    };
  }
  /**
   * Inline CSS for email compatibility
   * Simple implementation - for production use a library like juice
   */
  async inlineCss(html) {
    const styleRegex = /<style[^>]*>([\s\S]*?)<\/style>/gi;
    const styles = [];
    let match;
    while ((match = styleRegex.exec(html)) !== null) {
      styles.push(match[1]);
    }
    if (styles.length === 0) {
      return html;
    }
    let result = html;
    for (const style of styles) {
      const rules = style.match(/([.#][\w-]+)\s*\{([^}]+)\}/g);
      if (rules) {
        for (const rule of rules) {
          const [, selector, properties] = rule.match(/([.#][\w-]+)\s*\{([^}]+)\}/) || [];
          if (selector && properties) {
            const trimmedProps = properties.trim();
            if (selector.startsWith(".")) {
              const className = selector.slice(1);
              const classRegex = new RegExp(
                `(<[^>]*class=["'][^"']*\\b${className}\\b[^"']*["'][^>]*)(>)`,
                "g"
              );
              result = result.replace(classRegex, `$1 style="${trimmedProps}"$2`);
            } else if (selector.startsWith("#")) {
              const idName = selector.slice(1);
              const idRegex = new RegExp(`(<[^>]*id=["']${idName}["'][^>]*)(>)`, "g");
              result = result.replace(idRegex, `$1 style="${trimmedProps}"$2`);
            }
          }
        }
      }
    }
    result = result.replace(styleRegex, "");
    return result;
  }
  /**
   * Minify HTML (basic implementation)
   */
  minifyHtml(html) {
    return html.replace(/<!--[\s\S]*?-->/g, "").replace(/>\s+</g, "><").trim();
  }
}
async function generatePdf(options, env) {
  if (env?.BROWSER) {
    return await generatePdfWithBrowser(options, env.BROWSER);
  }
  return await generatePdfBasic(options);
}
async function generatePdfWithBrowser(options, browser) {
  const startTime = Date.now();
  const session = await browser.newSession();
  try {
    const dataUrl = `data:text/html;charset=utf-8,${encodeURIComponent(options.html)}`;
    await session.goto(dataUrl, { waitUntil: "networkidle" });
    const pdfOptions = {
      format: options.page?.size || "A4",
      landscape: options.page?.orientation === "landscape",
      printBackground: options.page?.printBackground !== false,
      margin: {
        top: `${options.page?.margins?.top || 10}mm`,
        right: `${options.page?.margins?.right || 10}mm`,
        bottom: `${options.page?.margins?.bottom || 10}mm`,
        left: `${options.page?.margins?.left || 10}mm`
      }
    };
    if (options.headerFooter?.displayHeaderFooter) {
      pdfOptions.displayHeaderFooter = true;
      pdfOptions.headerTemplate = options.headerFooter.header || "";
      pdfOptions.footerTemplate = options.headerFooter.footer || "";
    }
    if (options.page?.scale) {
      pdfOptions.scale = options.page.scale;
    }
    const pdfBuffer = await session.pdf(pdfOptions);
    const pdf = pdfBuffer instanceof ArrayBuffer ? pdfBuffer : new Uint8Array(pdfBuffer).buffer;
    return {
      pdf,
      generateTime: Date.now() - startTime
    };
  } finally {
    await session.close();
  }
}
async function generatePdfBasic(options) {
  const startTime = Date.now();
  const pdfContent = createBasicPdf(options);
  const encoder2 = new TextEncoder();
  const pdfBuffer = encoder2.encode(pdfContent);
  const pdf = pdfBuffer.buffer.slice(0);
  return {
    pdf,
    generateTime: Date.now() - startTime
  };
}
function createBasicPdf(options) {
  const title = options.metadata?.title || "Document";
  const author = options.metadata?.author || "Conductor";
  const creationDate = options.metadata?.creationDate || /* @__PURE__ */ new Date();
  const textContent = options.html.replace(/<[^>]*>/g, " ").replace(/\s+/g, " ").trim();
  return `%PDF-1.4
1 0 obj
<<
/Type /Catalog
/Pages 2 0 R
/Metadata 3 0 R
>>
endobj

2 0 obj
<<
/Type /Pages
/Kids [4 0 R]
/Count 1
>>
endobj

3 0 obj
<<
/Type /Metadata
/Subtype /XML
/Length 0
>>
stream
endstream
endobj

4 0 obj
<<
/Type /Page
/Parent 2 0 R
/MediaBox [0 0 595 842]
/Contents 5 0 R
/Resources <<
/Font <<
/F1 6 0 R
>>
>>
>>
endobj

5 0 obj
<<
/Length ${textContent.length + 50}
>>
stream
BT
/F1 12 Tf
50 800 Td
(${title}) Tj
0 -20 Td
(${textContent.substring(0, 500)}) Tj
ET
endstream
endobj

6 0 obj
<<
/Type /Font
/Subtype /Type1
/BaseFont /Helvetica
>>
endobj

xref
0 7
0000000000 65535 f
0000000009 00000 n
0000000074 00000 n
0000000131 00000 n
0000000229 00000 n
0000000379 00000 n
0000000${(500 + textContent.length).toString().padStart(3, "0")} 00000 n
trailer
<<
/Size 7
/Root 1 0 R
/Info <<
/Title (${title})
/Author (${author})
/CreationDate (D:${formatPdfDate(creationDate)})
>>
>>
startxref
${(550 + textContent.length).toString()}
%%EOF`;
}
function formatPdfDate(date2) {
  const year2 = date2.getFullYear();
  const month = String(date2.getMonth() + 1).padStart(2, "0");
  const day2 = String(date2.getDate()).padStart(2, "0");
  const hours = String(date2.getHours()).padStart(2, "0");
  const minutes = String(date2.getMinutes()).padStart(2, "0");
  const seconds = String(date2.getSeconds()).padStart(2, "0");
  return `${year2}${month}${day2}${hours}${minutes}${seconds}`;
}
function validatePageConfig(page) {
  const errors = [];
  if (page?.scale && (page.scale < 0.1 || page.scale > 2)) {
    errors.push("Scale must be between 0.1 and 2.0");
  }
  if (page?.margins) {
    const { top, right, bottom, left } = page.margins;
    if (top && top < 0) errors.push("Top margin cannot be negative");
    if (right && right < 0) errors.push("Right margin cannot be negative");
    if (bottom && bottom < 0) errors.push("Bottom margin cannot be negative");
    if (left && left < 0) errors.push("Left margin cannot be negative");
  }
  return {
    valid: errors.length === 0,
    errors: errors.length > 0 ? errors : void 0
  };
}
async function storePdfToR2(pdf, config, env) {
  const r2BindingName = config.r2Binding || "ASSETS";
  const bucket = env[r2BindingName];
  if (!bucket) {
    throw new Error(`R2 bucket binding "${r2BindingName}" not found in environment`);
  }
  const r2Key = config.r2Key || generateDefaultR2Key();
  await bucket.put(r2Key, pdf, {
    httpMetadata: {
      contentType: "application/pdf"
    },
    customMetadata: {
      uploadedAt: (/* @__PURE__ */ new Date()).toISOString(),
      generatedBy: "conductor-pdf-agent"
    }
  });
  let url;
  if (config.publicUrl) {
    url = `/assets/static/${r2Key.split("/").pop()}`;
  }
  return { r2Key, url };
}
function generateDefaultR2Key() {
  const timestamp2 = Date.now();
  const random = Math.random().toString(36).substring(2, 8);
  return `static/generated-${timestamp2}-${random}.pdf`;
}
function generateFilename(r2Key, configFilename, fallback2 = "document.pdf") {
  if (configFilename) {
    return configFilename.endsWith(".pdf") ? configFilename : `${configFilename}.pdf`;
  }
  if (r2Key) {
    const parts = r2Key.split("/");
    const filename = parts[parts.length - 1];
    return filename || fallback2;
  }
  return fallback2;
}
function createContentDisposition(mode, filename) {
  const safeFilename = filename.replace(/[^a-zA-Z0-9._-]/g, "_");
  if (mode === "attachment") {
    return `attachment; filename="${safeFilename}"`;
  }
  return `inline; filename="${safeFilename}"`;
}
function validateStorageConfig(config) {
  if (!config || !config.saveToR2) {
    return { valid: true };
  }
  const errors = [];
  if (config.r2Key) {
    if (config.r2Key.includes("..")) {
      errors.push('R2 key cannot contain ".."');
    }
    if (config.r2Key.startsWith("/")) {
      errors.push('R2 key should not start with "/"');
    }
  }
  return {
    valid: errors.length === 0,
    errors: errors.length > 0 ? errors : void 0
  };
}
class PdfMember extends BaseAgent {
  constructor(config) {
    super(config);
    this.pdfConfig = config.config || {};
    const engine = this.pdfConfig.templateEngine || "simple";
    this.templateEngine = createTemplateEngine(engine);
    this.validateConfig();
  }
  /**
   * Validate agent configuration
   */
  validateConfig() {
    if (this.pdfConfig.page) {
      const pageValidation = validatePageConfig(this.pdfConfig.page);
      if (!pageValidation.valid) {
        throw new Error(`Invalid page config: ${pageValidation.errors?.join(", ")}`);
      }
    }
    if (this.pdfConfig.storage) {
      const storageValidation = validateStorageConfig(this.pdfConfig.storage);
      if (!storageValidation.valid) {
        throw new Error(`Invalid storage config: ${storageValidation.errors?.join(", ")}`);
      }
    }
  }
  /**
   * Execute PDF generation
   */
  async run(context) {
    const startTime = Date.now();
    const input = context.input;
    const htmlSource = input.html || this.pdfConfig.html;
    const pageConfig = { ...this.pdfConfig.page, ...input.page };
    const headerFooter = { ...this.pdfConfig.headerFooter, ...input.headerFooter };
    const storageConfig = { ...this.pdfConfig.storage, ...input.storage };
    const metadata = { ...this.pdfConfig.metadata, ...input.metadata };
    const deliveryMode = input.deliveryMode || this.pdfConfig.deliveryMode || "inline";
    const filename = input.filename || this.pdfConfig.filename;
    let html;
    let htmlSize;
    if (htmlSource?.inline) {
      html = htmlSource.inline;
      htmlSize = html.length;
    } else if (htmlSource?.fromMember) {
      const memberOutput = context.previousOutputs?.[htmlSource.fromMember];
      const output = memberOutput?.output;
      if (!output?.html) {
        throw new Error(
          `Agent "${htmlSource.fromMember}" did not produce HTML output. Make sure it's an HTML agent and executed before this PDF agent.`
        );
      }
      html = output.html;
      htmlSize = html.length;
    } else if (htmlSource?.template) {
      const htmlMemberConfig = {
        name: `${this.name}-html-renderer`,
        operation: Operation.html,
        config: {
          template: htmlSource.template,
          templateEngine: this.pdfConfig.templateEngine || "simple",
          renderOptions: {
            // Don't inline CSS for PDF - browser can handle it
            inlineCss: false,
            minify: false
          }
        }
      };
      const htmlMember = new HtmlMember(htmlMemberConfig);
      const htmlContext = {
        input: { data: htmlSource.data || {} },
        env: context.env,
        ctx: context.ctx,
        previousOutputs: context.previousOutputs
      };
      const htmlResponse = await htmlMember.execute(htmlContext);
      if (!htmlResponse.success) {
        throw new Error(`HTML rendering failed: ${htmlResponse.error}`);
      }
      const htmlData = htmlResponse.data;
      if (!htmlData.html) {
        throw new Error("HTML rendering succeeded but no HTML content was produced");
      }
      html = htmlData.html;
      htmlSize = html.length;
    } else {
      throw new Error(
        "No HTML source specified. Provide html.inline, html.fromMember, or html.template"
      );
    }
    const renderedHeaderFooter = await this.renderHeaderFooter(headerFooter);
    const pdfResult = await generatePdf(
      {
        html,
        page: pageConfig,
        headerFooter: renderedHeaderFooter,
        metadata
      },
      { BROWSER: context.env.BROWSER }
    );
    let r2Key;
    let url;
    if (storageConfig?.saveToR2) {
      const storageResult = await storePdfToR2(pdfResult.pdf, storageConfig, context.env);
      r2Key = storageResult.r2Key;
      url = storageResult.url;
    }
    const finalFilename = generateFilename(r2Key, filename, "document.pdf");
    const contentDisposition = createContentDisposition(deliveryMode, finalFilename);
    return {
      pdf: pdfResult.pdf,
      size: pdfResult.pdf.byteLength,
      url,
      r2Key,
      contentDisposition,
      filename: finalFilename,
      metadata: {
        generateTime: Date.now() - startTime,
        pageCount: pdfResult.pageCount,
        htmlSize
      }
    };
  }
  /**
   * Render header/footer templates with template engine
   */
  async renderHeaderFooter(headerFooter) {
    if (!headerFooter) {
      return void 0;
    }
    const data = headerFooter.data || {};
    const rendered = { ...headerFooter };
    if (headerFooter.header) {
      rendered.header = await this.templateEngine.render(headerFooter.header, data);
    }
    if (headerFooter.footer) {
      rendered.footer = await this.templateEngine.render(headerFooter.footer, data);
    }
    return rendered;
  }
}
class BuiltInMemberRegistry {
  constructor() {
    this.agents = /* @__PURE__ */ new Map();
  }
  /**
   * Register a built-in agent
   */
  register(metadata, factory) {
    this.agents.set(metadata.name, {
      metadata,
      factory,
      loaded: false
    });
  }
  /**
   * Check if a agent is built-in
   */
  isBuiltIn(name) {
    return this.agents.has(name);
  }
  /**
   * Get a built-in agent instance (lazy loading)
   */
  async create(name, config, env) {
    const entry = this.agents.get(name);
    if (!entry) {
      throw new Error(
        `Built-in agent "${name}" not found. Available: ${this.getAvailableNames().join(", ")}`
      );
    }
    entry.loaded = true;
    return await entry.factory(config, env);
  }
  /**
   * Get metadata for a built-in agent
   */
  getMetadata(name) {
    return this.agents.get(name)?.metadata;
  }
  /**
   * List all built-in agents
   */
  list() {
    return Array.from(this.agents.values()).map((entry) => entry.metadata);
  }
  /**
   * Get available agent names
   */
  getAvailableNames() {
    return Array.from(this.agents.keys());
  }
  /**
   * Get agents by type
   */
  listByType(type) {
    return this.list().filter((m) => m.operation === type);
  }
  /**
   * Get agents by tag
   */
  listByTag(tag2) {
    return this.list().filter((m) => m.tags?.includes(tag2));
  }
}
let registry = null;
function getBuiltInRegistry() {
  if (!registry) {
    registry = new BuiltInMemberRegistry();
    registerAllBuiltInMembers(registry);
  }
  return registry;
}
function registerAllBuiltInMembers(registry2) {
  registry2.register(
    {
      name: "rag",
      version: "1.0.0",
      description: "RAG system using Cloudflare Vectorize and AI embeddings",
      operation: Operation.storage,
      tags: ["rag", "vectorize", "embeddings", "search", "ai"],
      examples: [
        {
          name: "index-content",
          description: "Index content into vector database",
          input: {
            content: "Document content...",
            id: "doc-123",
            source: "https://example.com"
          },
          config: {
            operation: "index",
            chunkStrategy: "semantic",
            chunkSize: 512
          },
          output: { indexed: 10, chunks: 10 }
        },
        {
          name: "search-content",
          description: "Search for relevant content",
          input: { query: "What is the company mission?" },
          config: {
            operation: "search",
            topK: 5,
            rerank: true
          },
          output: { results: [], count: 5 }
        }
      ],
      documentation: "https://docs.conductor.dev/built-in-agents/rag"
    },
    async (config, env) => {
      const { RAGMember } = await import("./index-CfQrJyuC.js");
      return new RAGMember(config, env);
    }
  );
  registry2.register(
    {
      name: "hitl",
      version: "1.0.0",
      description: "Human-in-the-loop workflows with approval gates and notifications",
      operation: Operation.code,
      tags: ["workflow", "approval", "human-in-loop", "durable-objects"],
      examples: [
        {
          name: "approval-gate",
          description: "Suspend workflow for manual approval",
          input: {
            approvalData: {
              transaction: { amount: 1e4, to: "account-123" },
              risk_score: 0.85
            }
          },
          config: {
            action: "suspend",
            timeout: 864e5,
            notificationChannel: "slack"
          },
          output: {
            status: "suspended",
            executionId: "exec-123",
            approvalUrl: "https://app.com/approve/exec-123"
          }
        }
      ],
      documentation: "https://docs.conductor.dev/built-in-agents/hitl"
    },
    async (config, env) => {
      const { HITLMember } = await import("./index-BAdpaQlN.js");
      return new HITLMember(config, env);
    }
  );
}
const logger$d = createLogger({ serviceName: "scoring-executor" });
class ScoringExecutor {
  /**
   * Execute a agent with scoring and retry logic
   */
  async executeWithScoring(executeAgent, evaluateOutput, config) {
    const startTime = Date.now();
    let attempts = 0;
    let lastScore;
    let lastOutput;
    let backoffMs = 1e3;
    const maxAttempts = config.retryLimit || 3;
    while (attempts < maxAttempts) {
      attempts++;
      try {
        const output = await executeAgent();
        lastOutput = output;
        const score = await evaluateOutput(output, attempts, lastScore);
        lastScore = score;
        if (score.passed) {
          return {
            output,
            score,
            attempts,
            status: "passed",
            executionTime: Date.now() - startTime
          };
        }
        if (config.requireImprovement && lastScore && attempts > 1) {
          const improvement = score.score - lastScore.score;
          const minImprovement = config.minImprovement || 0.05;
          if (improvement < minImprovement) {
            return {
              output,
              score,
              attempts,
              status: "max_retries_exceeded",
              executionTime: Date.now() - startTime
            };
          }
        }
        const onFailure = config.onFailure || "retry";
        switch (onFailure) {
          case "retry":
            if (attempts < maxAttempts) {
              await this.applyBackoff(backoffMs);
              backoffMs = this.calculateNextBackoff(backoffMs, "exponential");
            }
            break;
          case "continue":
            logger$d.warn("Score below threshold, continuing anyway", {
              score: score.score,
              threshold: config.thresholds?.minimum,
              attempts
            });
            return {
              output,
              score,
              attempts,
              status: "below_threshold",
              executionTime: Date.now() - startTime
            };
          case "abort":
            throw Errors.internal(
              `Score ${score.score} below minimum threshold ${config.thresholds?.minimum}`
            );
        }
      } catch (error) {
        if (attempts >= maxAttempts) {
          throw error;
        }
        await this.applyBackoff(backoffMs);
        backoffMs = this.calculateNextBackoff(backoffMs, "exponential");
      }
    }
    return {
      output: lastOutput,
      score: lastScore,
      attempts,
      status: "max_retries_exceeded",
      executionTime: Date.now() - startTime
    };
  }
  /**
   * Apply backoff delay
   */
  async applyBackoff(ms) {
    return new Promise((resolve2) => setTimeout(resolve2, ms));
  }
  /**
   * Calculate next backoff delay
   */
  calculateNextBackoff(current, strategy) {
    switch (strategy) {
      case "exponential":
        return Math.min(current * 2, 6e4);
      // Cap at 60s
      case "linear":
        return Math.min(current + 1e3, 3e4);
      // Cap at 30s
      case "fixed":
      default:
        return current;
    }
  }
  /**
   * Calculate composite score from breakdown
   */
  calculateCompositeScore(breakdown, weights) {
    const criteria = Object.keys(breakdown);
    if (!criteria.length) {
      return 0;
    }
    if (!weights) {
      const sum2 = criteria.reduce((acc, key) => acc + breakdown[key], 0);
      return sum2 / criteria.length;
    }
    let weightedSum = 0;
    let totalWeight = 0;
    for (const criterion of criteria) {
      const weight = weights[criterion] || 1;
      weightedSum += breakdown[criterion] * weight;
      totalWeight += weight;
    }
    return totalWeight > 0 ? weightedSum / totalWeight : 0;
  }
  /**
   * Check if score meets threshold
   */
  checkThreshold(score, threshold) {
    return score >= threshold;
  }
  /**
   * Get score range category
   */
  getScoreRange(score) {
    if (score >= 0.95) return "excellent";
    if (score >= 0.8) return "good";
    if (score >= 0.6) return "acceptable";
    return "poor";
  }
  /**
   * Get failed criteria from breakdown
   */
  getFailedCriteria(breakdown, threshold) {
    return Object.entries(breakdown).filter(([_, score]) => score < threshold).map(([criterion]) => criterion);
  }
}
class EnsembleScorer {
  constructor(config) {
    this.config = config;
  }
  /**
   * Calculate overall ensemble score from history
   */
  calculateEnsembleScore(history, weights) {
    if (!history.length) {
      return 0;
    }
    if (!weights) {
      const latestScores2 = this.getLatestScoresPerMember(history);
      const sum2 = Array.from(latestScores2.values()).reduce((acc, score) => acc + score, 0);
      return sum2 / latestScores2.size;
    }
    const latestScores = this.getLatestScoresPerMember(history);
    let weightedSum = 0;
    let totalWeight = 0;
    for (const [agent, score] of latestScores.entries()) {
      const weight = weights[agent] || 1;
      weightedSum += score * weight;
      totalWeight += weight;
    }
    return totalWeight > 0 ? weightedSum / totalWeight : 0;
  }
  /**
   * Get latest score for each agent
   */
  getLatestScoresPerMember(history) {
    const scores = /* @__PURE__ */ new Map();
    for (const entry of history) {
      if (entry.passed) {
        scores.set(entry.agent, entry.score);
      }
    }
    return scores;
  }
  /**
   * Calculate comprehensive quality metrics
   */
  calculateQualityMetrics(history) {
    if (!history.length) {
      return {
        ensembleScore: 0,
        averageScore: 0,
        minScore: 0,
        maxScore: 0,
        totalEvaluations: 0,
        passRate: 0,
        totalRetries: 0,
        averageAttempts: 0
      };
    }
    const scores = history.map((e) => e.score);
    const attempts = history.map((e) => e.attempt);
    const ensembleScore = this.calculateEnsembleScore(history);
    const averageScore = scores.reduce((a, b) => a + b, 0) / scores.length;
    const minScore = Math.min(...scores);
    const maxScore = Math.max(...scores);
    const passRate = history.filter((e) => e.passed).length / history.length;
    const totalRetries = attempts.filter((a) => a > 1).length;
    const averageAttempts = attempts.reduce((a, b) => a + b, 0) / attempts.length;
    const criteriaBreakdown = this.aggregateCriteria(history);
    return {
      ensembleScore,
      averageScore,
      minScore,
      maxScore,
      totalEvaluations: history.length,
      passRate,
      criteriaBreakdown,
      totalRetries,
      averageAttempts
    };
  }
  /**
   * Aggregate scores by criterion
   */
  aggregateCriteria(history) {
    const criteria = {};
    for (const entry of history) {
      if (entry.breakdown) {
        for (const [criterion, score] of Object.entries(entry.breakdown)) {
          if (!criteria[criterion]) {
            criteria[criterion] = { scores: [], average: 0, passRate: 0 };
          }
          criteria[criterion].scores.push(score);
        }
      }
    }
    const threshold = this.config.defaultThresholds.minimum;
    for (const criterion of Object.keys(criteria)) {
      const scores = criteria[criterion].scores;
      criteria[criterion].average = scores.reduce((a, b) => a + b, 0) / scores.length;
      criteria[criterion].passRate = scores.filter((s) => s >= threshold).length / scores.length;
    }
    return criteria;
  }
  /**
   * Update scoring state with new entry
   */
  updateScoringState(state, entry) {
    const newHistory = [...state.scoreHistory, entry];
    const retryCount = { ...state.retryCount };
    if (entry.attempt > 1) {
      retryCount[entry.agent] = (retryCount[entry.agent] || 0) + 1;
    }
    const qualityMetrics = this.calculateQualityMetrics(newHistory);
    const finalScore = qualityMetrics.ensembleScore;
    return {
      scoreHistory: newHistory,
      finalScore,
      retryCount,
      qualityMetrics
    };
  }
  /**
   * Initialize empty scoring state
   */
  initializeScoringState() {
    return {
      scoreHistory: [],
      finalScore: void 0,
      retryCount: {},
      qualityMetrics: void 0
    };
  }
  /**
   * Check if ensemble quality is degrading
   */
  isQualityDegrading(history, windowSize = 5) {
    if (history.length < windowSize * 2) {
      return false;
    }
    const recentScores = history.slice(-windowSize).map((e) => e.score);
    const olderScores = history.slice(-windowSize * 2, -windowSize).map((e) => e.score);
    const recentAvg = recentScores.reduce((a, b) => a + b, 0) / recentScores.length;
    const olderAvg = olderScores.reduce((a, b) => a + b, 0) / olderScores.length;
    const degradationThreshold = 0.1;
    return recentAvg < olderAvg - degradationThreshold;
  }
  /**
   * Get recommendations based on quality metrics
   */
  getRecommendations(metrics) {
    const recommendations = [];
    if (metrics.ensembleScore < 0.7) {
      recommendations.push(
        "Overall ensemble score is low. Review agent configurations and criteria."
      );
    }
    if (metrics.totalRetries > metrics.totalEvaluations * 0.5) {
      recommendations.push(
        "High retry rate detected. Consider adjusting thresholds or improving agent quality."
      );
    }
    if (metrics.passRate < 0.8) {
      recommendations.push(
        `Pass rate is ${(metrics.passRate * 100).toFixed(0)}%. Review failing criteria.`
      );
    }
    if (metrics.criteriaBreakdown) {
      for (const [criterion, data] of Object.entries(metrics.criteriaBreakdown)) {
        if (data.passRate < 0.7) {
          recommendations.push(
            `Criterion '${criterion}' has low pass rate (${(data.passRate * 100).toFixed(0)}%). Focus improvement efforts here.`
          );
        }
      }
    }
    return recommendations;
  }
  /**
   * Get score trend (improving, declining, stable)
   */
  getScoreTrend(history, windowSize = 5) {
    if (history.length < windowSize * 2) {
      return "stable";
    }
    const recentScores = history.slice(-windowSize).map((e) => e.score);
    const olderScores = history.slice(-windowSize * 2, -windowSize).map((e) => e.score);
    const recentAvg = recentScores.reduce((a, b) => a + b, 0) / recentScores.length;
    const olderAvg = olderScores.reduce((a, b) => a + b, 0) / olderScores.length;
    const changeThreshold = 0.05;
    if (recentAvg > olderAvg + changeThreshold) {
      return "improving";
    } else if (recentAvg < olderAvg - changeThreshold) {
      return "declining";
    }
    return "stable";
  }
}
const logger$c = createLogger({ serviceName: "webhook-notifier" });
class WebhookNotifier {
  constructor(config) {
    this.config = {
      retries: config.retries || 3,
      timeout: config.timeout || 5e3,
      ...config
    };
  }
  /**
   * Send webhook notification with retry logic
   */
  async send(eventData) {
    const startTime = Date.now();
    const maxRetries = this.config.retries || 0;
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        const result = await this.sendRequest(eventData, attempt);
        return {
          success: true,
          type: "webhook",
          target: this.config.url,
          event: eventData.event,
          duration: Date.now() - startTime,
          statusCode: result.status,
          attempts: attempt + 1
        };
      } catch (error) {
        logger$c.error("Webhook notification failed", error instanceof Error ? error : void 0, {
          url: this.config.url,
          attempt: attempt + 1,
          maxRetries: maxRetries + 1
        });
        if (attempt === maxRetries) {
          return {
            success: false,
            type: "webhook",
            target: this.config.url,
            event: eventData.event,
            duration: Date.now() - startTime,
            error: error instanceof Error ? error.message : "Unknown error",
            attempts: attempt + 1
          };
        }
        const delay = this.calculateBackoff(attempt);
        await this.sleep(delay);
      }
    }
    return {
      success: false,
      type: "webhook",
      target: this.config.url,
      event: eventData.event,
      duration: Date.now() - startTime,
      error: "Maximum retries exceeded",
      attempts: maxRetries + 1
    };
  }
  /**
   * Send webhook HTTP request
   */
  async sendRequest(eventData, attempt) {
    const timestamp2 = Math.floor(Date.now() / 1e3);
    const payload = {
      event: eventData.event,
      timestamp: eventData.timestamp,
      data: eventData.data
    };
    const body = JSON.stringify(payload);
    const headers = {
      "Content-Type": "application/json",
      "User-Agent": "Conductor-Webhook/1.0",
      "X-Conductor-Event": eventData.event,
      "X-Conductor-Timestamp": timestamp2.toString(),
      "X-Conductor-Delivery-Attempt": (attempt + 1).toString()
    };
    if (this.config.secret) {
      const signature = await this.generateSignature(body, timestamp2, this.config.secret);
      headers["X-Conductor-Signature"] = signature;
    }
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.config.timeout);
    try {
      const response = await fetch(this.config.url, {
        method: "POST",
        headers,
        body,
        signal: controller.signal
      });
      if (!response.ok && response.status >= 400) {
        throw new Error(`Webhook returned ${response.status}: ${response.statusText}`);
      }
      return { status: response.status };
    } finally {
      clearTimeout(timeoutId);
    }
  }
  /**
   * Generate HMAC signature for webhook verification
   */
  async generateSignature(body, timestamp2, secret) {
    const payload = `${timestamp2}.${body}`;
    const encoder2 = new TextEncoder();
    const key = await crypto.subtle.importKey(
      "raw",
      encoder2.encode(secret),
      { name: "HMAC", hash: "SHA-256" },
      false,
      ["sign"]
    );
    const signature = await crypto.subtle.sign("HMAC", key, encoder2.encode(payload));
    const hashArray = Array.from(new Uint8Array(signature));
    const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
    return `sha256=${hashHex}`;
  }
  /**
   * Calculate exponential backoff delay
   */
  calculateBackoff(attempt) {
    const delays = [1e3, 5e3, 3e4, 12e4, 3e5];
    return delays[Math.min(attempt, delays.length - 1)];
  }
  /**
   * Sleep for specified milliseconds
   */
  sleep(ms) {
    return new Promise((resolve2) => setTimeout(resolve2, ms));
  }
}
const logger$b = createLogger({ serviceName: "email-notifier" });
class EmailNotifier {
  constructor(config) {
    this.config = config;
  }
  /**
   * Send email notification
   */
  async send(eventData, env) {
    const startTime = Date.now();
    try {
      const emailData = this.buildEmailData(eventData);
      await this.sendEmail(emailData, env);
      logger$b.info("Email notification sent", {
        to: emailData.to,
        event: eventData.event
      });
      return {
        success: true,
        type: "email",
        target: emailData.to.join(", "),
        event: eventData.event,
        duration: Date.now() - startTime
      };
    } catch (error) {
      logger$b.error("Email notification failed", error instanceof Error ? error : void 0, {
        to: this.config.to,
        event: eventData.event
      });
      return {
        success: false,
        type: "email",
        target: this.config.to.join(", "),
        event: eventData.event,
        duration: Date.now() - startTime,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  /**
   * Build email data from event
   */
  buildEmailData(eventData) {
    const subject = this.interpolateSubject(eventData);
    const text = this.buildTextBody(eventData);
    const html = this.buildHtmlBody(eventData);
    return {
      to: this.config.to,
      from: this.config.from || "notifications@conductor.dev",
      subject,
      text,
      html,
      event: eventData.event,
      eventData: eventData.data
    };
  }
  /**
   * Interpolate subject template with event data
   */
  interpolateSubject(eventData) {
    if (!this.config.subject) {
      return `Conductor: ${eventData.event}`;
    }
    let subject = this.config.subject;
    subject = subject.replace(/\${event}/g, eventData.event);
    subject = subject.replace(
      /\${ensemble\.name}/g,
      eventData.data.ensemble || "Unknown"
    );
    subject = subject.replace(/\${timestamp}/g, eventData.timestamp);
    return subject;
  }
  /**
   * Build plain text email body
   */
  buildTextBody(eventData) {
    const lines = [
      `Event: ${eventData.event}`,
      `Timestamp: ${eventData.timestamp}`,
      "",
      "Details:",
      JSON.stringify(eventData.data, null, 2),
      "",
      "---",
      "This is an automated notification from Conductor."
    ];
    return lines.join("\n");
  }
  /**
   * Build HTML email body
   */
  buildHtmlBody(eventData) {
    eventData.event.split(".")[0];
    const eventAction = eventData.event.split(".")[1] || "";
    let color = "#2563eb";
    if (eventAction === "failed" || eventAction === "timeout") {
      color = "#dc2626";
    } else if (eventAction === "completed") {
      color = "#16a34a";
    }
    return `
<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<style>
		body {
			font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
			line-height: 1.6;
			color: #333;
			max-width: 600px;
			margin: 0 auto;
			padding: 20px;
		}
		.header {
			background-color: ${color};
			color: white;
			padding: 20px;
			border-radius: 8px 8px 0 0;
		}
		.header h1 {
			margin: 0;
			font-size: 24px;
		}
		.content {
			background-color: #f9fafb;
			padding: 20px;
			border: 1px solid #e5e7eb;
			border-top: none;
			border-radius: 0 0 8px 8px;
		}
		.detail {
			margin: 10px 0;
		}
		.label {
			font-weight: 600;
			color: #6b7280;
		}
		.value {
			color: #111827;
		}
		.data {
			background-color: white;
			border: 1px solid #e5e7eb;
			border-radius: 4px;
			padding: 15px;
			margin-top: 15px;
			overflow-x: auto;
		}
		pre {
			margin: 0;
			font-size: 12px;
		}
		.footer {
			margin-top: 20px;
			padding-top: 20px;
			border-top: 1px solid #e5e7eb;
			text-align: center;
			color: #6b7280;
			font-size: 14px;
		}
	</style>
</head>
<body>
	<div class="header">
		<h1>${eventData.event}</h1>
	</div>
	<div class="content">
		<div class="detail">
			<span class="label">Timestamp:</span>
			<span class="value">${eventData.timestamp}</span>
		</div>
		<div class="data">
			<pre>${JSON.stringify(eventData.data, null, 2)}</pre>
		</div>
	</div>
	<div class="footer">
		This is an automated notification from Conductor.
	</div>
</body>
</html>
		`.trim();
  }
  /**
   * Send email using MailChannels API
   */
  async sendEmail(emailData, _env) {
    const response = await fetch("https://api.mailchannels.net/tx/v1/send", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        personalizations: [
          {
            to: emailData.to.map((email) => ({ email }))
          }
        ],
        from: {
          email: emailData.from,
          name: "Conductor Notifications"
        },
        subject: emailData.subject,
        content: [
          {
            type: "text/plain",
            value: emailData.text
          },
          {
            type: "text/html",
            value: emailData.html || emailData.text
          }
        ]
      })
    });
    if (!response.ok) {
      const errorText = await response.text().catch(() => "Unknown error");
      throw new Error(`MailChannels API error: ${response.status} - ${errorText}`);
    }
  }
}
const logger$a = createLogger({ serviceName: "notification-manager" });
class NotificationManager {
  /**
   * Send notifications for an event
   */
  static async notify(ensemble, event, eventData, env) {
    if (!ensemble.notifications || ensemble.notifications.length === 0) {
      return [];
    }
    const notificationEvent = {
      event,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      data: {
        ensemble: ensemble.name,
        ...eventData
      }
    };
    const relevantNotifications = ensemble.notifications.filter(
      (notification) => notification.events.includes(event)
    );
    if (relevantNotifications.length === 0) {
      return [];
    }
    logger$a.info("Sending notifications", {
      ensemble: ensemble.name,
      event,
      count: relevantNotifications.length
    });
    const results = await Promise.all(
      relevantNotifications.map(
        (notification) => this.sendNotification(notification, notificationEvent, env)
      )
    );
    const successful = results.filter((r) => r.success).length;
    const failed = results.filter((r) => !r.success).length;
    logger$a.info("Notifications sent", {
      ensemble: ensemble.name,
      event,
      total: results.length,
      successful,
      failed
    });
    return results;
  }
  /**
   * Send a single notification
   */
  static async sendNotification(config, eventData, env) {
    try {
      switch (config.type) {
        case "webhook": {
          const notifier = new WebhookNotifier({
            url: config.url,
            secret: config.secret,
            retries: config.retries,
            timeout: config.timeout
          });
          return await notifier.send(eventData);
        }
        case "email": {
          const notifier = new EmailNotifier({
            to: config.to,
            from: config.from,
            subject: config.subject,
            events: config.events
          });
          return await notifier.send(eventData, env);
        }
        default: {
          const exhaustiveCheck = config;
          throw new Error(`Unknown notification type: ${exhaustiveCheck.type}`);
        }
      }
    } catch (error) {
      logger$a.error("Notification failed", error instanceof Error ? error : void 0, {
        type: config.type,
        event: eventData.event
      });
      const target = config.type === "webhook" ? config.url : config.type === "email" ? config.to.join(", ") : "unknown";
      return {
        success: false,
        type: config.type,
        target,
        event: eventData.event,
        duration: 0,
        error: error instanceof Error ? error.message : "Unknown error"
      };
    }
  }
  /**
   * Emit an event (convenience method for common events)
   */
  static async emitExecutionStarted(ensemble, executionId, input, env) {
    return this.notify(
      ensemble,
      "execution.started",
      {
        id: executionId,
        input
      },
      env
    );
  }
  static async emitExecutionCompleted(ensemble, executionId, output, duration, env) {
    return this.notify(
      ensemble,
      "execution.completed",
      {
        id: executionId,
        status: "completed",
        output,
        duration
      },
      env
    );
  }
  static async emitExecutionFailed(ensemble, executionId, error, duration, env) {
    return this.notify(
      ensemble,
      "execution.failed",
      {
        id: executionId,
        status: "failed",
        error: {
          message: error.message,
          stack: error.stack
        },
        duration
      },
      env
    );
  }
  static async emitExecutionTimeout(ensemble, executionId, duration, timeout, env) {
    return this.notify(
      ensemble,
      "execution.timeout",
      {
        id: executionId,
        duration,
        timeout
      },
      env
    );
  }
  static async emitAgentCompleted(ensemble, executionId, agentName, output, duration, env) {
    return this.notify(
      ensemble,
      "agent.completed",
      {
        executionId,
        agent: agentName,
        output,
        duration
      },
      env
    );
  }
  static async emitStateUpdated(ensemble, executionId, state, env) {
    return this.notify(
      ensemble,
      "state.updated",
      {
        executionId,
        state
      },
      env
    );
  }
}
class SchemaRegistry {
  constructor(parent) {
    this.parent = parent;
  }
  /**
   * Get a schema by name (with optional @version)
   *
   * @param nameOrRef - Schema name with optional version
   * @returns JSON Schema object
   *
   * @example
   * ```typescript
   * ctx.schemas.get('order')           // order@latest
   * ctx.schemas.get('order@v1.0.0')    // exact version
   * ctx.schemas.get('order@^2.0.0')    // semver range
   * ```
   */
  async get(nameOrRef) {
    const { name, version } = parseNameWithVersion(nameOrRef);
    const ref2 = `schemas/${name}@${version}`;
    return this.parent.resolve(ref2);
  }
  /**
   * Validate data against a schema
   *
   * Uses a lightweight JSON Schema validator optimized for Workers.
   * Supports most JSON Schema Draft 7 features.
   *
   * @param nameOrRef - Schema name with optional version
   * @param data - Data to validate
   * @returns Validation result with errors
   *
   * @example
   * ```typescript
   * const result = await ctx.schemas.validate('order@v1.0.0', orderData)
   * if (!result.valid) {
   *   console.log('Validation errors:', result.errors)
   * }
   * ```
   */
  async validate(nameOrRef, data) {
    const schema2 = await this.get(nameOrRef);
    return validateJsonSchema(schema2, data);
  }
  /**
   * Check if data matches schema (returns boolean)
   *
   * Convenience method for simple valid/invalid checks.
   *
   * @param nameOrRef - Schema name with optional version
   * @param data - Data to validate
   * @returns True if valid
   *
   * @example
   * ```typescript
   * if (await ctx.schemas.isValid('order', orderData)) {
   *   await processOrder(orderData)
   * }
   * ```
   */
  async isValid(nameOrRef, data) {
    const result = await this.validate(nameOrRef, data);
    return result.valid;
  }
  /**
   * Check if a schema exists
   *
   * @param nameOrRef - Schema name with optional version
   * @returns True if schema exists
   */
  async exists(nameOrRef) {
    try {
      await this.get(nameOrRef);
      return true;
    } catch {
      return false;
    }
  }
}
function validateJsonSchema(schema2, data, path = "") {
  const errors = [];
  const addError = (keyword, message2, expected, actual) => {
    errors.push({ path: path || "/", keyword, message: message2, expected, actual });
  };
  if (schema2 === true) {
    return { valid: true, errors: [] };
  }
  if (schema2 === false) {
    addError("false", "Schema is false - no data is valid");
    return { valid: false, errors };
  }
  if (schema2 === null || schema2 === void 0) {
    return { valid: true, errors: [] };
  }
  if (schema2.type !== void 0) {
    const types = Array.isArray(schema2.type) ? schema2.type : [schema2.type];
    const actualType = getJsonType(data);
    if (!types.includes(actualType)) {
      if (!(types.includes("integer") && actualType === "number" && Number.isInteger(data))) {
        addError("type", `Expected ${types.join(" or ")}, got ${actualType}`, types, actualType);
      }
    }
  }
  if (schema2.const !== void 0) {
    if (!deepEqual(data, schema2.const)) {
      addError("const", `Value must be ${JSON.stringify(schema2.const)}`, schema2.const, data);
    }
  }
  if (schema2.enum !== void 0) {
    if (!schema2.enum.some((e) => deepEqual(data, e))) {
      addError("enum", `Value must be one of: ${JSON.stringify(schema2.enum)}`, schema2.enum, data);
    }
  }
  if (typeof data === "string") {
    if (schema2.minLength !== void 0 && data.length < schema2.minLength) {
      addError(
        "minLength",
        `String must be at least ${schema2.minLength} characters`,
        schema2.minLength,
        data.length
      );
    }
    if (schema2.maxLength !== void 0 && data.length > schema2.maxLength) {
      addError(
        "maxLength",
        `String must be at most ${schema2.maxLength} characters`,
        schema2.maxLength,
        data.length
      );
    }
    if (schema2.pattern !== void 0) {
      const regex = new RegExp(schema2.pattern);
      if (!regex.test(data)) {
        addError("pattern", `String must match pattern: ${schema2.pattern}`, schema2.pattern, data);
      }
    }
    if (schema2.format !== void 0) {
      const formatError = validateFormat(data, schema2.format);
      if (formatError) {
        addError("format", formatError, schema2.format, data);
      }
    }
  }
  if (typeof data === "number") {
    if (schema2.minimum !== void 0 && data < schema2.minimum) {
      addError("minimum", `Number must be >= ${schema2.minimum}`, schema2.minimum, data);
    }
    if (schema2.maximum !== void 0 && data > schema2.maximum) {
      addError("maximum", `Number must be <= ${schema2.maximum}`, schema2.maximum, data);
    }
    if (schema2.exclusiveMinimum !== void 0 && data <= schema2.exclusiveMinimum) {
      addError(
        "exclusiveMinimum",
        `Number must be > ${schema2.exclusiveMinimum}`,
        schema2.exclusiveMinimum,
        data
      );
    }
    if (schema2.exclusiveMaximum !== void 0 && data >= schema2.exclusiveMaximum) {
      addError(
        "exclusiveMaximum",
        `Number must be < ${schema2.exclusiveMaximum}`,
        schema2.exclusiveMaximum,
        data
      );
    }
    if (schema2.multipleOf !== void 0 && data % schema2.multipleOf !== 0) {
      addError(
        "multipleOf",
        `Number must be a multiple of ${schema2.multipleOf}`,
        schema2.multipleOf,
        data
      );
    }
  }
  if (Array.isArray(data)) {
    if (schema2.minItems !== void 0 && data.length < schema2.minItems) {
      addError(
        "minItems",
        `Array must have at least ${schema2.minItems} items`,
        schema2.minItems,
        data.length
      );
    }
    if (schema2.maxItems !== void 0 && data.length > schema2.maxItems) {
      addError(
        "maxItems",
        `Array must have at most ${schema2.maxItems} items`,
        schema2.maxItems,
        data.length
      );
    }
    if (schema2.uniqueItems && new Set(data.map((item) => JSON.stringify(item))).size !== data.length) {
      addError("uniqueItems", "Array items must be unique");
    }
    if (schema2.items) {
      if (Array.isArray(schema2.items)) {
        schema2.items.forEach((itemSchema, i) => {
          if (i < data.length) {
            const itemResult = validateJsonSchema(itemSchema, data[i], `${path}[${i}]`);
            errors.push(...itemResult.errors);
          }
        });
      } else {
        data.forEach((item, i) => {
          const itemResult = validateJsonSchema(schema2.items, item, `${path}[${i}]`);
          errors.push(...itemResult.errors);
        });
      }
    }
  }
  if (typeof data === "object" && data !== null && !Array.isArray(data)) {
    const dataKeys = Object.keys(data);
    if (schema2.minProperties !== void 0 && dataKeys.length < schema2.minProperties) {
      addError(
        "minProperties",
        `Object must have at least ${schema2.minProperties} properties`,
        schema2.minProperties,
        dataKeys.length
      );
    }
    if (schema2.maxProperties !== void 0 && dataKeys.length > schema2.maxProperties) {
      addError(
        "maxProperties",
        `Object must have at most ${schema2.maxProperties} properties`,
        schema2.maxProperties,
        dataKeys.length
      );
    }
    if (schema2.required) {
      for (const req of schema2.required) {
        if (!(req in data)) {
          errors.push({
            path: `${path}/${req}`,
            keyword: "required",
            message: `Missing required property: ${req}`,
            expected: req
          });
        }
      }
    }
    if (schema2.properties) {
      for (const [key, propSchema] of Object.entries(schema2.properties)) {
        if (key in data) {
          const propResult = validateJsonSchema(propSchema, data[key], `${path}/${key}`);
          errors.push(...propResult.errors);
        }
      }
    }
    if (schema2.additionalProperties === false) {
      const allowedKeys = Object.keys(schema2.properties || {});
      const patternKeys = Object.keys(schema2.patternProperties || {});
      for (const key of dataKeys) {
        if (!allowedKeys.includes(key) && !patternKeys.some((p) => new RegExp(p).test(key))) {
          addError("additionalProperties", `Additional property not allowed: ${key}`, false, key);
        }
      }
    }
  }
  if (schema2.allOf) {
    for (let i = 0; i < schema2.allOf.length; i++) {
      const result = validateJsonSchema(schema2.allOf[i], data, path);
      errors.push(...result.errors);
    }
  }
  if (schema2.anyOf) {
    const anyValid = schema2.anyOf.some((s) => validateJsonSchema(s, data, path).valid);
    if (!anyValid) {
      addError("anyOf", "Data must match at least one schema in anyOf");
    }
  }
  if (schema2.oneOf) {
    const matchCount = schema2.oneOf.filter(
      (s) => validateJsonSchema(s, data, path).valid
    ).length;
    if (matchCount !== 1) {
      addError("oneOf", `Data must match exactly one schema in oneOf (matched ${matchCount})`);
    }
  }
  if (schema2.not) {
    if (validateJsonSchema(schema2.not, data, path).valid) {
      addError("not", "Data must not match the schema in not");
    }
  }
  if (schema2.if) {
    const ifValid = validateJsonSchema(schema2.if, data, path).valid;
    if (ifValid && schema2.then) {
      const thenResult = validateJsonSchema(schema2.then, data, path);
      errors.push(...thenResult.errors);
    } else if (!ifValid && schema2.else) {
      const elseResult = validateJsonSchema(schema2.else, data, path);
      errors.push(...elseResult.errors);
    }
  }
  return {
    valid: errors.length === 0,
    errors
  };
}
function getJsonType(value) {
  if (value === null) return "null";
  if (Array.isArray(value)) return "array";
  return typeof value;
}
function deepEqual(a, b) {
  if (a === b) return true;
  if (typeof a !== typeof b) return false;
  if (typeof a !== "object" || a === null || b === null) return false;
  if (Array.isArray(a) !== Array.isArray(b)) return false;
  if (Array.isArray(a)) {
    if (a.length !== b.length) return false;
    return a.every((item, i) => deepEqual(item, b[i]));
  }
  const keysA = Object.keys(a);
  const keysB = Object.keys(b);
  if (keysA.length !== keysB.length) return false;
  return keysA.every((key) => key in b && deepEqual(a[key], b[key]));
}
function validateFormat(value, format2) {
  switch (format2) {
    case "email":
      if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(value)) {
        return "Invalid email format";
      }
      break;
    case "uri":
    case "url":
      try {
        new URL(value);
      } catch {
        return "Invalid URL format";
      }
      break;
    case "uuid":
      if (!/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(value)) {
        return "Invalid UUID format";
      }
      break;
    case "date":
      if (!/^\d{4}-\d{2}-\d{2}$/.test(value) || isNaN(Date.parse(value))) {
        return "Invalid date format (expected YYYY-MM-DD)";
      }
      break;
    case "date-time":
      if (isNaN(Date.parse(value))) {
        return "Invalid date-time format";
      }
      break;
    case "time":
      if (!/^\d{2}:\d{2}:\d{2}/.test(value)) {
        return "Invalid time format (expected HH:MM:SS)";
      }
      break;
    case "ipv4":
      if (!/^(\d{1,3}\.){3}\d{1,3}$/.test(value) || value.split(".").some((n) => parseInt(n) > 255)) {
        return "Invalid IPv4 address";
      }
      break;
    case "ipv6":
      if (!/^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$/.test(value) && !/^([0-9a-fA-F]{1,4}:)*:([0-9a-fA-F]{1,4}:)*[0-9a-fA-F]{1,4}$/.test(value)) {
        return "Invalid IPv6 address";
      }
      break;
  }
  return null;
}
class PromptRegistry {
  constructor(parent) {
    this.parent = parent;
  }
  /**
   * Get a prompt template by name (with optional @version)
   *
   * Returns the raw prompt template string.
   *
   * @param nameOrRef - Prompt name with optional version
   * @returns Prompt template string
   *
   * @example
   * ```typescript
   * ctx.prompts.get('extraction')           // extraction@latest
   * ctx.prompts.get('extraction@v1.0.0')    // exact version
   * ```
   */
  async get(nameOrRef) {
    const { name, version } = parseNameWithVersion(nameOrRef);
    const ref2 = `prompts/${name}@${version}`;
    const content = await this.parent.resolve(ref2);
    if (typeof content === "string") {
      return content;
    }
    if (content && typeof content.content === "string") {
      return content.content;
    }
    return String(content);
  }
  /**
   * Get prompt with metadata
   *
   * @param nameOrRef - Prompt name with optional version
   * @returns Prompt template with metadata
   */
  async getWithMetadata(nameOrRef) {
    const { name, version } = parseNameWithVersion(nameOrRef);
    const ref2 = `prompts/${name}@${version}`;
    const resolved = await this.parent.resolveWithMetadata(ref2);
    const content = resolved.content;
    if (typeof content === "string") {
      return {
        content,
        metadata: {
          name,
          version: resolved.metadata?.version || version
        }
      };
    }
    if (content && typeof content.content === "string") {
      return {
        content: content.content,
        metadata: {
          name,
          description: content.description,
          variables: content.variables,
          version: resolved.metadata?.version || version
        }
      };
    }
    return {
      content: String(content),
      metadata: { name, version }
    };
  }
  /**
   * Render a prompt with variables (Handlebars)
   *
   * Uses Handlebars templating to replace variables in the prompt.
   *
   * @param nameOrRef - Prompt name with optional version
   * @param variables - Variables to inject into the template
   * @returns Rendered prompt string
   *
   * @example
   * ```typescript
   * const rendered = await ctx.prompts.render('docs-writer@v1.0.0', {
   *   page: 'getting-started',
   *   projectName: 'MyApp'
   * })
   * ```
   */
  async render(nameOrRef, variables) {
    const template2 = await this.get(nameOrRef);
    return renderHandlebars(template2, variables);
  }
  /**
   * Check if a prompt exists
   *
   * @param nameOrRef - Prompt name with optional version
   * @returns True if prompt exists
   */
  async exists(nameOrRef) {
    try {
      await this.get(nameOrRef);
      return true;
    } catch {
      return false;
    }
  }
  /**
   * List variables used in a prompt template
   *
   * Extracts Handlebars variable references from the template.
   *
   * @param nameOrRef - Prompt name with optional version
   * @returns Array of variable names
   *
   * @example
   * ```typescript
   * const vars = await ctx.prompts.listVariables('docs-writer')
   * // ['page', 'projectName', 'description']
   * ```
   */
  async listVariables(nameOrRef) {
    const template2 = await this.get(nameOrRef);
    return extractHandlebarsVariables(template2);
  }
}
function renderHandlebars(template2, variables) {
  return renderLightweightHandlebars(template2, variables);
}
function renderLightweightHandlebars(template2, context) {
  let result = template2;
  const getValue = (path, ctx) => {
    const parts = path.split(".");
    let value = ctx;
    for (const part of parts) {
      if (value === null || value === void 0) return void 0;
      value = value[part];
    }
    return value;
  };
  result = result.replace(
    /\{\{#each\s+(\w+(?:\.\w+)*)\}\}([\s\S]*?)\{\{\/each\}\}/g,
    (_, path, content) => {
      const items = getValue(path, context);
      if (!Array.isArray(items)) return "";
      return items.map((item, index) => {
        let itemContent = content;
        itemContent = itemContent.replace(/\{\{this\}\}/g, String(item ?? ""));
        itemContent = itemContent.replace(/\{\{@index\}\}/g, String(index));
        if (typeof item === "object" && item !== null) {
          itemContent = renderLightweightHandlebars(itemContent, { ...context, ...item });
        }
        return itemContent;
      }).join("");
    }
  );
  result = result.replace(
    /\{\{#if\s+(\w+(?:\.\w+)*)\}\}([\s\S]*?)(?:\{\{else\}\}([\s\S]*?))?\{\{\/if\}\}/g,
    (_, path, ifContent, elseContent = "") => {
      const value = getValue(path, context);
      const isTruthy2 = value !== false && value !== null && value !== void 0 && value !== "" && value !== 0;
      return isTruthy2 ? renderLightweightHandlebars(ifContent, context) : renderLightweightHandlebars(elseContent, context);
    }
  );
  result = result.replace(
    /\{\{#unless\s+(\w+(?:\.\w+)*)\}\}([\s\S]*?)\{\{\/unless\}\}/g,
    (_, path, content) => {
      const value = getValue(path, context);
      const isTruthy2 = value !== false && value !== null && value !== void 0 && value !== "" && value !== 0;
      return isTruthy2 ? "" : renderLightweightHandlebars(content, context);
    }
  );
  result = result.replace(
    /\{\{#with\s+(\w+(?:\.\w+)*)\}\}([\s\S]*?)\{\{\/with\}\}/g,
    (_, path, content) => {
      const value = getValue(path, context);
      if (typeof value !== "object" || value === null) return "";
      return renderLightweightHandlebars(content, { ...context, ...value });
    }
  );
  result = result.replace(/\{\{([^#/][^}]*)\}\}/g, (_, path) => {
    const trimmedPath = path.trim();
    const value = getValue(trimmedPath, context);
    if (value === void 0 || value === null) return "";
    if (typeof value === "object") return JSON.stringify(value);
    return String(value);
  });
  return result;
}
function extractHandlebarsVariables(template2) {
  const variables = /* @__PURE__ */ new Set();
  const varRegex = /\{\{([^#/][^}]*)\}\}/g;
  let match;
  while ((match = varRegex.exec(template2)) !== null) {
    const path = match[1].trim();
    if (!path.startsWith("@")) {
      const rootVar = path.split(".")[0];
      variables.add(rootVar);
    }
  }
  const eachRegex = /\{\{#each\s+(\w+)/g;
  while ((match = eachRegex.exec(template2)) !== null) {
    variables.add(match[1]);
  }
  const ifRegex = /\{\{#if\s+(\w+(?:\.\w+)*)\}\}/g;
  while ((match = ifRegex.exec(template2)) !== null) {
    const rootVar = match[1].split(".")[0];
    variables.add(rootVar);
  }
  const unlessRegex = /\{\{#unless\s+(\w+(?:\.\w+)*)\}\}/g;
  while ((match = unlessRegex.exec(template2)) !== null) {
    const rootVar = match[1].split(".")[0];
    variables.add(rootVar);
  }
  const withRegex = /\{\{#with\s+(\w+)/g;
  while ((match = withRegex.exec(template2)) !== null) {
    variables.add(match[1]);
  }
  return Array.from(variables).sort();
}
class ConfigRegistry {
  constructor(parent) {
    this.parent = parent;
  }
  /**
   * Get a config component by name (with optional @version)
   *
   * @param nameOrRef - Config name with optional version
   * @returns Config object (typed with generic parameter)
   *
   * @example
   * ```typescript
   * ctx.configs.get('settings')           // settings@latest
   * ctx.configs.get('settings@v1.0.0')    // exact version
   * ctx.configs.get<MySettings>('settings') // typed
   * ```
   */
  async get(nameOrRef) {
    const { name, version } = parseNameWithVersion(nameOrRef);
    const ref2 = `configs/${name}@${version}`;
    return this.parent.resolve(ref2);
  }
  /**
   * Get a config value at a specific path
   *
   * Allows accessing nested properties directly.
   *
   * @param nameOrRef - Config name with optional version
   * @param path - Dot-separated path to the value
   * @returns Value at the path
   *
   * @example
   * ```typescript
   * // Get nested value
   * const theme = await ctx.configs.getValue('docs-settings', 'theme.primaryColor')
   * const aiEnabled = await ctx.configs.getValue('docs-settings', 'ai.enabled')
   * ```
   */
  async getValue(nameOrRef, path) {
    const config = await this.get(nameOrRef);
    return getNestedValue(config, path);
  }
  /**
   * Get a config value with a default fallback
   *
   * @param nameOrRef - Config name with optional version
   * @param path - Dot-separated path to the value
   * @param defaultValue - Default value if path doesn't exist
   * @returns Value at the path or default
   *
   * @example
   * ```typescript
   * const theme = await ctx.configs.getValueOrDefault(
   *   'docs-settings',
   *   'theme.primaryColor',
   *   '#3B82F6'
   * )
   * ```
   */
  async getValueOrDefault(nameOrRef, path, defaultValue) {
    const value = await this.getValue(nameOrRef, path);
    return value !== void 0 ? value : defaultValue;
  }
  /**
   * Check if a config component exists
   *
   * @param nameOrRef - Config name with optional version
   * @returns True if config exists
   */
  async exists(nameOrRef) {
    try {
      await this.get(nameOrRef);
      return true;
    } catch {
      return false;
    }
  }
  /**
   * Check if a config has a specific path
   *
   * @param nameOrRef - Config name with optional version
   * @param path - Dot-separated path to check
   * @returns True if path exists
   */
  async hasPath(nameOrRef, path) {
    const value = await this.getValue(nameOrRef, path);
    return value !== void 0;
  }
  /**
   * Merge a config with overrides
   *
   * Returns a new object with overrides applied (does not modify stored config).
   *
   * @param nameOrRef - Config name with optional version
   * @param overrides - Values to override
   * @returns Merged config object
   *
   * @example
   * ```typescript
   * const customSettings = await ctx.configs.merge('docs-settings', {
   *   theme: { primaryColor: '#FF0000' }
   * })
   * ```
   */
  async merge(nameOrRef, overrides) {
    const base = await this.get(nameOrRef);
    return deepMerge(base, overrides);
  }
}
function getNestedValue(obj, path) {
  const parts = path.split(".");
  let current = obj;
  for (const part of parts) {
    if (current === null || current === void 0) {
      return void 0;
    }
    current = current[part];
  }
  return current;
}
function deepMerge(target, source) {
  const result = { ...target };
  for (const key of Object.keys(source)) {
    const sourceValue = source[key];
    const targetValue = target[key];
    if (sourceValue !== null && typeof sourceValue === "object" && !Array.isArray(sourceValue) && targetValue !== null && typeof targetValue === "object" && !Array.isArray(targetValue)) {
      result[key] = deepMerge(
        targetValue,
        sourceValue
      );
    } else if (sourceValue !== void 0) {
      result[key] = sourceValue;
    }
  }
  return result;
}
class QueryRegistry {
  constructor(parent) {
    this.parent = parent;
  }
  /**
   * Get a query template by name (with optional @version)
   *
   * @param nameOrRef - Query name with optional version (e.g., "find-users" or "find-users@v1.0.0")
   * @returns Query template object
   *
   * @example
   * queries.get('find-users')           // find-users@latest
   * queries.get('find-users@v1.0.0')    // exact version
   */
  async get(nameOrRef) {
    const { name, version } = parseNameWithVersion(nameOrRef);
    const ref2 = `queries/${name}@${version}`;
    const content = await this.parent.resolve(ref2);
    if (typeof content === "string") {
      return { sql: content };
    }
    return content;
  }
  /**
   * Get raw SQL string from a query template
   *
   * @param nameOrRef - Query name with optional version
   * @returns Raw SQL string
   */
  async getSql(nameOrRef) {
    const template2 = await this.get(nameOrRef);
    return template2.sql;
  }
  /**
   * Check if a query exists
   *
   * @param nameOrRef - Query name with optional version
   * @returns True if query exists
   */
  async exists(nameOrRef) {
    try {
      await this.get(nameOrRef);
      return true;
    } catch {
      return false;
    }
  }
}
class ScriptRegistry {
  constructor(parent) {
    this.parent = parent;
  }
  /**
   * Get a script by name (with optional @version)
   *
   * @param nameOrRef - Script name with optional version (e.g., "transform" or "transform@v1.0.0")
   * @returns Loaded script with content
   *
   * @example
   * scripts.get('transform')           // transform@latest
   * scripts.get('transform@v1.0.0')    // exact version
   */
  async get(nameOrRef) {
    const { name, version } = parseNameWithVersion(nameOrRef);
    const ref2 = `scripts/${name}@${version}`;
    const content = await this.parent.resolve(ref2);
    if (typeof content === "string") {
      return {
        content,
        metadata: { name, version }
      };
    }
    return {
      content: content.content || content.code || String(content),
      metadata: {
        name,
        version,
        description: content.description,
        exports: content.exports
      }
    };
  }
  /**
   * Get raw script content as string
   *
   * @param nameOrRef - Script name with optional version
   * @returns Raw script content
   */
  async getContent(nameOrRef) {
    const script = await this.get(nameOrRef);
    return script.content;
  }
  /**
   * Check if a script exists
   *
   * @param nameOrRef - Script name with optional version
   * @returns True if script exists
   */
  async exists(nameOrRef) {
    try {
      await this.get(nameOrRef);
      return true;
    } catch {
      return false;
    }
  }
}
class TemplateRegistry {
  constructor(parent) {
    this.parent = parent;
  }
  /**
   * Get a template by name (with optional @version)
   *
   * @param nameOrRef - Template name with optional version (e.g., "header" or "header@v1.0.0")
   * @returns Template object with content
   *
   * @example
   * templates.get('header')           // header@latest
   * templates.get('header@v1.0.0')    // exact version
   */
  async get(nameOrRef) {
    const { name, version } = parseNameWithVersion(nameOrRef);
    const ref2 = `templates/${name}@${version}`;
    const content = await this.parent.resolve(ref2);
    if (typeof content === "string") {
      return { content, engine: "handlebars" };
    }
    return {
      content: content.content || content.template || String(content),
      engine: content.engine || "handlebars",
      description: content.description
    };
  }
  /**
   * Get raw template content as string
   *
   * @param nameOrRef - Template name with optional version
   * @returns Raw template content
   */
  async getContent(nameOrRef) {
    const template2 = await this.get(nameOrRef);
    return template2.content;
  }
  /**
   * Render a template with variables
   *
   * Uses Handlebars for rendering by default.
   *
   * @param nameOrRef - Template name with optional version
   * @param variables - Variables to substitute in the template
   * @returns Rendered HTML string
   *
   * @example
   * const html = await templates.render('email-template', {
   *   userName: 'John',
   *   orderNumber: '12345',
   * })
   */
  async render(nameOrRef, variables) {
    const template2 = await this.get(nameOrRef);
    if (template2.engine === "handlebars" || !template2.engine) {
      return renderHandlebars(template2.content, variables);
    }
    if (template2.engine === "html") {
      return template2.content;
    }
    return renderHandlebars(template2.content, variables);
  }
  /**
   * Check if a template exists
   *
   * @param nameOrRef - Template name with optional version
   * @returns True if template exists
   */
  async exists(nameOrRef) {
    try {
      await this.get(nameOrRef);
      return true;
    } catch {
      return false;
    }
  }
}
function parseNameWithVersion(nameOrRef) {
  if (nameOrRef.includes("@")) {
    const atIndex = nameOrRef.lastIndexOf("@");
    const name = nameOrRef.substring(0, atIndex);
    const version = nameOrRef.substring(atIndex + 1);
    return { name, version };
  }
  return { name: nameOrRef, version: "latest" };
}
class ComponentRegistry {
  constructor(context) {
    this.cache = /* @__PURE__ */ new Map();
    this.resolutionContext = context;
  }
  /**
   * Schema registry - access and validate against schemas
   */
  get schemas() {
    if (!this._schemas) {
      this._schemas = new SchemaRegistry(this);
    }
    return this._schemas;
  }
  /**
   * Prompt registry - access and render prompts
   */
  get prompts() {
    if (!this._prompts) {
      this._prompts = new PromptRegistry(this);
    }
    return this._prompts;
  }
  /**
   * Config component registry - access config components
   */
  get configs() {
    if (!this._configs) {
      this._configs = new ConfigRegistry(this);
    }
    return this._configs;
  }
  /**
   * Query registry - access SQL query templates
   */
  get queries() {
    if (!this._queries) {
      this._queries = new QueryRegistry(this);
    }
    return this._queries;
  }
  /**
   * Script registry - access JavaScript/TypeScript scripts
   */
  get scripts() {
    if (!this._scripts) {
      this._scripts = new ScriptRegistry(this);
    }
    return this._scripts;
  }
  /**
   * Template registry - access HTML/Handlebars templates
   */
  get templates() {
    if (!this._templates) {
      this._templates = new TemplateRegistry(this);
    }
    return this._templates;
  }
  /**
   * Resolve any component reference
   *
   * This is the core resolution method that delegates to resolveValue()
   * from component-resolver.ts. Results are cached within the execution.
   *
   * @param ref - Component reference (e.g., "schemas/order@v1.0.0")
   * @returns Resolved component content
   */
  async resolve(ref2) {
    if (this.cache.has(ref2)) {
      return this.cache.get(ref2);
    }
    const resolved = await resolveValue(ref2, this.resolutionContext);
    this.cache.set(ref2, resolved.content);
    return resolved.content;
  }
  /**
   * Resolve with full metadata (source, version, etc.)
   *
   * @param ref - Component reference
   * @returns Full resolved component with metadata
   */
  async resolveWithMetadata(ref2) {
    return resolveValue(ref2, this.resolutionContext);
  }
  /**
   * Check if a component exists
   *
   * @param ref - Component reference
   * @returns True if component exists
   */
  async exists(ref2) {
    try {
      await this.resolve(ref2);
      return true;
    } catch {
      return false;
    }
  }
  /**
   * Clear component cache
   *
   * Useful for testing or long-running processes that need fresh data.
   */
  clearCache() {
    this.cache.clear();
  }
  /**
   * Get cache statistics
   *
   * @returns Cache hit information
   */
  getCacheStats() {
    return {
      size: this.cache.size,
      keys: Array.from(this.cache.keys())
    };
  }
  /**
   * Get the resolution context
   *
   * Useful for passing to other functions that need KV access.
   */
  getContext() {
    return this.resolutionContext;
  }
}
function createComponentRegistry(env) {
  return new ComponentRegistry({ env });
}
function createAgentRegistry(agents) {
  return {
    list() {
      const result = [];
      for (const [name, agent] of agents) {
        result.push(extractAgentMetadata(name, agent));
      }
      return result;
    },
    get(name) {
      const agent = agents.get(name);
      if (!agent) return void 0;
      return extractAgentMetadata(name, agent);
    },
    has(name) {
      return agents.has(name);
    }
  };
}
function extractAgentMetadata(name, agent) {
  const config = agent.getConfig?.() || {};
  return {
    name,
    operation: agent.getType?.() || config.operation || "unknown",
    description: config.description,
    // AgentConfig stores input/output schema under config.schema
    inputSchema: config.schema?.input,
    outputSchema: config.schema?.output,
    builtIn: isBuiltInAgent(name)
  };
}
function isBuiltInAgent(name) {
  const builtInNames = [
    "scrape",
    "validate",
    "rag",
    "hitl",
    "fetch",
    "html",
    "form",
    "storage",
    "queue",
    "pdf",
    "email",
    "sms"
  ];
  return builtInNames.includes(name);
}
function createEnsembleRegistry(ensembles) {
  return {
    list() {
      const result = [];
      for (const [name, { config, source }] of ensembles) {
        result.push(extractEnsembleMetadata(name, config, source));
      }
      return result;
    },
    get(name) {
      const entry = ensembles.get(name);
      if (!entry) return void 0;
      return extractEnsembleMetadata(name, entry.config, entry.source);
    },
    has(name) {
      return ensembles.has(name);
    }
  };
}
function extractEnsembleMetadata(name, config, source) {
  const triggers = config.trigger?.map((t) => ({
    type: t.type,
    path: t.path || t.paths?.[0]?.path,
    methods: t.methods || t.paths?.[0]?.methods,
    cron: t.cron
  })) || [];
  const agentNames = [];
  if (Array.isArray(config.flow)) {
    for (const step2 of config.flow) {
      if ("agent" in step2 && typeof step2.agent === "string") {
        agentNames.push(step2.agent);
      }
    }
  }
  return {
    name,
    description: config.description,
    triggers,
    inputSchema: config.inputs,
    outputSchema: config.output,
    source,
    agentNames,
    stepCount: Array.isArray(config.flow) ? config.flow.length : 0
  };
}
function resolveOutput(output, context) {
  if (!output) {
    return { status: 200 };
  }
  const blocks = normalizeOutput(output);
  for (const block of blocks) {
    if (!block.when) {
      return resolveOutputBlock(block, context);
    }
    const condition = evaluateCondition(block.when, context);
    if (condition) {
      return resolveOutputBlock(block, context);
    }
  }
  return { status: 200 };
}
function resolveOutputBlock(block, context) {
  const resolved = {
    status: block.status || 200
  };
  if (block.headers) {
    resolved.headers = {};
    for (const [key, value] of Object.entries(block.headers)) {
      resolved.headers[key] = String(Parser$1.resolveInterpolation(value, context));
    }
  }
  if (block.redirect) {
    resolved.redirect = {
      url: String(Parser$1.resolveInterpolation(block.redirect.url, context)),
      status: block.redirect.status
    };
    return resolved;
  }
  if (block.rawBody !== void 0) {
    resolved.rawBody = String(Parser$1.resolveInterpolation(block.rawBody, context));
    return resolved;
  }
  if (block.body !== void 0) {
    resolved.body = Parser$1.resolveInterpolation(block.body, context);
  }
  return resolved;
}
function evaluateCondition(condition, context) {
  const resolved = Parser$1.resolveInterpolation(condition, context);
  if (typeof resolved === "boolean") {
    return resolved;
  }
  if (typeof resolved === "string") {
    if (resolved === "true") return true;
    if (resolved === "false") return false;
    const comparisonMatch = resolved.match(/^(.+?)\s*(==|!=|>=|<=|>|<)\s*(.+)$/);
    if (comparisonMatch) {
      const [, left, op, right] = comparisonMatch;
      return evaluateComparison(left.trim(), op, right.trim());
    }
  }
  return Boolean(resolved);
}
function evaluateComparison(left, op, right) {
  const leftVal = parseValue(left);
  const rightVal = parseValue(right);
  switch (op) {
    case "==":
      return leftVal === rightVal;
    case "!=":
      return leftVal !== rightVal;
    case ">":
      return Number(leftVal) > Number(rightVal);
    case ">=":
      return Number(leftVal) >= Number(rightVal);
    case "<":
      return Number(leftVal) < Number(rightVal);
    case "<=":
      return Number(leftVal) <= Number(rightVal);
    default:
      return false;
  }
}
function parseValue(value) {
  if (value.startsWith("'") && value.endsWith("'") || value.startsWith('"') && value.endsWith('"')) {
    return value.slice(1, -1);
  }
  if (value === "true") return true;
  if (value === "false") return false;
  if (value === "null") return "";
  const num = Number(value);
  if (!isNaN(num)) return num;
  return value;
}
class WorkingMemory {
  constructor() {
    this.memory = /* @__PURE__ */ new Map();
  }
  /**
   * Set a value in working memory
   */
  set(key, value) {
    this.memory.set(key, value);
  }
  /**
   * Get a value from working memory
   */
  get(key) {
    return this.memory.get(key);
  }
  /**
   * Check if key exists
   */
  has(key) {
    return this.memory.has(key);
  }
  /**
   * Delete a key
   */
  delete(key) {
    return this.memory.delete(key);
  }
  /**
   * Get all keys
   */
  keys() {
    return Array.from(this.memory.keys());
  }
  /**
   * Get all values as object
   */
  getAll() {
    return Object.fromEntries(this.memory);
  }
  /**
   * Clear all memory
   */
  clear() {
    this.memory.clear();
  }
  /**
   * Get memory size
   */
  size() {
    return this.memory.size;
  }
  /**
   * Merge another object into working memory
   */
  merge(data) {
    for (const [key, value] of Object.entries(data)) {
      this.memory.set(key, value);
    }
  }
  /**
   * Create a snapshot of working memory
   */
  snapshot() {
    return { ...this.getAll() };
  }
  /**
   * Restore from a snapshot
   */
  restore(snapshot) {
    this.memory.clear();
    this.merge(snapshot);
  }
}
class SessionMemory {
  constructor(env, sessionId, config) {
    this.env = env;
    this.sessionId = sessionId;
    this.defaultTTL = 3600;
    this.defaultMaxMessages = 50;
    this.defaultMessageMaxAgeHours = 24;
    this.defaultMaxConversationSize = 1024 * 1024;
    if (typeof config === "number") {
      this.ttl = config;
      this.maxMessages = this.defaultMaxMessages;
      this.messageMaxAgeHours = this.defaultMessageMaxAgeHours;
      this.maxConversationSize = this.defaultMaxConversationSize;
    } else {
      this.ttl = config?.ttl ?? this.defaultTTL;
      this.maxMessages = config?.maxMessages ?? this.defaultMaxMessages;
      this.messageMaxAgeHours = config?.messageMaxAgeHours ?? this.defaultMessageMaxAgeHours;
      this.maxConversationSize = config?.maxConversationSize ?? this.defaultMaxConversationSize;
    }
  }
  /**
   * Get the KV key for this session
   */
  getKey() {
    if (!this.sessionId) {
      throw new Error("Session ID is required for session memory");
    }
    return `session:${this.sessionId}`;
  }
  /**
   * Filter messages by age (sliding window memory)
   * Removes messages older than messageMaxAgeHours
   * @private
   */
  filterByAge(messages) {
    if (!Array.isArray(messages) || messages.length === 0) {
      return [];
    }
    const cutoffTime = Date.now() - this.messageMaxAgeHours * 60 * 60 * 1e3;
    return messages.filter((msg) => {
      if (!msg.timestamp) return true;
      return msg.timestamp > cutoffTime;
    });
  }
  /**
   * Enforce message count limit (keeps most recent)
   * @private
   */
  enforceMaxMessages(messages) {
    if (messages.length <= this.maxMessages) {
      return messages;
    }
    const trimmed = messages.slice(-this.maxMessages);
    if (trimmed.length > 0 && trimmed[0].role === "assistant") {
      trimmed.shift();
    }
    return trimmed;
  }
  /**
   * Enforce conversation size limit
   * Progressively removes oldest message pairs until under limit
   * @private
   */
  enforceMaxSize(messages) {
    if (!Array.isArray(messages)) return [];
    let conversationJson = JSON.stringify(messages);
    while (conversationJson.length > this.maxConversationSize && messages.length > 2) {
      messages.splice(0, 2);
      conversationJson = JSON.stringify(messages);
    }
    return messages;
  }
  /**
   * Apply all filters to messages (age, count, size)
   * @private
   */
  applyFilters(messages) {
    let filtered = this.filterByAge(messages);
    filtered = this.enforceMaxMessages(filtered);
    filtered = this.enforceMaxSize(filtered);
    return filtered;
  }
  /**
   * Get conversation history
   * Automatically filters out old messages and enforces limits
   */
  async get() {
    if (!this.sessionId) {
      return { messages: [], createdAt: Date.now(), updatedAt: Date.now() };
    }
    const key = this.getKey();
    const data = await this.env.SESSIONS?.get(key);
    if (!data) {
      return { messages: [], createdAt: Date.now(), updatedAt: Date.now() };
    }
    const history = JSON.parse(data);
    history.messages = this.applyFilters(history.messages);
    return history;
  }
  /**
   * Add a message to conversation history
   * Automatically enforces limits after adding
   */
  async add(message2) {
    if (!this.sessionId) {
      return;
    }
    const history = await this.get();
    history.messages.push(message2);
    history.messages = this.applyFilters(history.messages);
    history.updatedAt = Date.now();
    const key = this.getKey();
    await this.env.SESSIONS?.put(key, JSON.stringify(history), {
      expirationTtl: this.ttl
    });
  }
  /**
   * Add multiple messages
   * Automatically enforces limits after adding
   */
  async addMany(messages) {
    if (!this.sessionId) {
      return;
    }
    const history = await this.get();
    history.messages.push(...messages);
    history.messages = this.applyFilters(history.messages);
    history.updatedAt = Date.now();
    const key = this.getKey();
    await this.env.SESSIONS?.put(key, JSON.stringify(history), {
      expirationTtl: this.ttl
    });
  }
  /**
   * Replace entire conversation history
   */
  async replace(history) {
    if (!this.sessionId) {
      return;
    }
    history.updatedAt = Date.now();
    const key = this.getKey();
    await this.env.SESSIONS?.put(key, JSON.stringify(history), {
      expirationTtl: this.ttl
    });
  }
  /**
   * Clear conversation history
   */
  async clear() {
    if (!this.sessionId) {
      return;
    }
    const key = this.getKey();
    await this.env.SESSIONS?.delete(key);
  }
  /**
   * Get last N messages
   */
  async getLastN(n) {
    const history = await this.get();
    return history.messages.slice(-n);
  }
  /**
   * Get messages since timestamp
   */
  async getSince(timestamp2) {
    const history = await this.get();
    return history.messages.filter((m) => m.timestamp >= timestamp2);
  }
  /**
   * Count messages
   */
  async count() {
    const history = await this.get();
    return history.messages.length;
  }
  /**
   * Compress history by summarizing older messages
   */
  async compress(maxMessages) {
    if (!this.sessionId) {
      return;
    }
    const history = await this.get();
    if (history.messages.length <= maxMessages) {
      return;
    }
    const recentMessages = history.messages.slice(-maxMessages);
    const olderMessages = history.messages.slice(0, -maxMessages);
    const summaryText = `[Previous conversation summary: ${olderMessages.length} messages]`;
    const summaryMessage = {
      role: "system",
      content: summaryText,
      timestamp: olderMessages[olderMessages.length - 1]?.timestamp || Date.now(),
      metadata: { type: "summary", messageCount: olderMessages.length }
    };
    history.messages = [summaryMessage, ...recentMessages];
    history.updatedAt = Date.now();
    const key = this.getKey();
    await this.env.SESSIONS?.put(key, JSON.stringify(history), {
      expirationTtl: this.ttl
    });
  }
  /**
   * Extend TTL (reset expiration)
   */
  async extend() {
    if (!this.sessionId) {
      return;
    }
    const history = await this.get();
    const key = this.getKey();
    await this.env.SESSIONS?.put(key, JSON.stringify(history), {
      expirationTtl: this.ttl
    });
  }
  /**
   * Format messages for AI model consumption
   * Strips metadata, timestamps, model info - returns only role + content
   * Limits to maxContext most recent messages
   *
   * @param maxContext - Maximum messages to include (default: 10 = 5 exchanges)
   */
  async formatForAI(maxContext = 10) {
    const history = await this.get();
    if (history.messages.length === 0) {
      return [];
    }
    const recentMessages = history.messages.length > maxContext ? history.messages.slice(-maxContext) : history.messages;
    return recentMessages.map((msg) => ({
      role: msg.role,
      content: msg.content
    }));
  }
  /**
   * Get conversation metadata (for debugging/analytics)
   * Returns stats about the conversation without full message content
   */
  async getMetadata() {
    const history = await this.get();
    if (history.messages.length === 0) {
      return null;
    }
    const modelsUsed = [...new Set(history.messages.map((m) => m.model).filter(Boolean))];
    const totalTokens = history.messages.reduce(
      (acc, msg) => ({
        input: acc.input + (msg.tokens?.input ?? 0),
        output: acc.output + (msg.tokens?.output ?? 0)
      }),
      { input: 0, output: 0 }
    );
    return {
      sessionId: this.sessionId,
      messageCount: history.messages.length,
      modelsUsed,
      firstMessage: history.messages[0]?.timestamp,
      lastMessage: history.messages[history.messages.length - 1]?.timestamp,
      userMessages: history.messages.filter((m) => m.role === "user").length,
      assistantMessages: history.messages.filter((m) => m.role === "assistant").length,
      totalTokens
    };
  }
}
class LongTermMemory {
  constructor(env, userId) {
    this.env = env;
    this.userId = userId;
    this.tableName = "long_term_memory";
  }
  /**
   * Get a value by key
   */
  async get(key) {
    if (!this.userId || !this.env.DB) {
      return null;
    }
    const result = await this.env.DB.prepare(
      `SELECT value, updated_at FROM ${this.tableName} WHERE user_id = ? AND key = ?`
    ).bind(this.userId, key).first();
    if (!result) {
      return null;
    }
    return JSON.parse(result.value);
  }
  /**
   * Set a value
   */
  async set(key, value) {
    if (!this.userId || !this.env.DB) {
      return;
    }
    await this.env.DB.prepare(
      `INSERT INTO ${this.tableName} (user_id, key, value, updated_at)
       VALUES (?, ?, ?, ?)
       ON CONFLICT(user_id, key) DO UPDATE SET
       value = excluded.value,
       updated_at = excluded.updated_at`
    ).bind(this.userId, key, JSON.stringify(value), Date.now()).run();
  }
  /**
   * Delete a key
   */
  async delete(key) {
    if (!this.userId || !this.env.DB) {
      return;
    }
    await this.env.DB.prepare(`DELETE FROM ${this.tableName} WHERE user_id = ? AND key = ?`).bind(this.userId, key).run();
  }
  /**
   * Check if key exists
   */
  async has(key) {
    if (!this.userId || !this.env.DB) {
      return false;
    }
    const result = await this.env.DB.prepare(
      `SELECT 1 FROM ${this.tableName} WHERE user_id = ? AND key = ? LIMIT 1`
    ).bind(this.userId, key).first();
    return !!result;
  }
  /**
   * Get all keys for this user
   */
  async keys() {
    if (!this.userId || !this.env.DB) {
      return [];
    }
    const results = await this.env.DB.prepare(
      `SELECT key FROM ${this.tableName} WHERE user_id = ? ORDER BY updated_at DESC`
    ).bind(this.userId).all();
    return results.results.map((row) => row.key);
  }
  /**
   * Get all key-value pairs
   */
  async getAll() {
    if (!this.userId || !this.env.DB) {
      return {};
    }
    const results = await this.env.DB.prepare(
      `SELECT key, value FROM ${this.tableName} WHERE user_id = ? ORDER BY updated_at DESC`
    ).bind(this.userId).all();
    const data = {};
    for (const row of results.results) {
      data[row.key] = JSON.parse(row.value);
    }
    return data;
  }
  /**
   * Get multiple values by keys
   */
  async getMany(keys) {
    if (!this.userId || !this.env.DB || keys.length === 0) {
      return {};
    }
    const placeholders = keys.map(() => "?").join(",");
    const results = await this.env.DB.prepare(
      `SELECT key, value FROM ${this.tableName} WHERE user_id = ? AND key IN (${placeholders})`
    ).bind(this.userId, ...keys).all();
    const data = {};
    for (const row of results.results) {
      data[row.key] = JSON.parse(row.value);
    }
    return data;
  }
  /**
   * Set multiple key-value pairs
   */
  async setMany(data) {
    if (!this.userId || !this.env.DB) {
      return;
    }
    const timestamp2 = Date.now();
    const batch = this.env.DB.batch(
      Object.entries(data).map(
        ([key, value]) => this.env.DB.prepare(
          `INSERT INTO ${this.tableName} (user_id, key, value, updated_at)
           VALUES (?, ?, ?, ?)
           ON CONFLICT(user_id, key) DO UPDATE SET
           value = excluded.value,
           updated_at = excluded.updated_at`
        ).bind(this.userId, key, JSON.stringify(value), timestamp2)
      )
    );
    await batch;
  }
  /**
   * Clear all data for this user
   */
  async clear() {
    if (!this.userId || !this.env.DB) {
      return;
    }
    await this.env.DB.prepare(`DELETE FROM ${this.tableName} WHERE user_id = ?`).bind(this.userId).run();
  }
  /**
   * Count entries for this user
   */
  async count() {
    if (!this.userId || !this.env.DB) {
      return 0;
    }
    const result = await this.env.DB.prepare(
      `SELECT COUNT(*) as count FROM ${this.tableName} WHERE user_id = ?`
    ).bind(this.userId).first();
    return result?.count || 0;
  }
  /**
   * Search keys by prefix
   */
  async searchByPrefix(prefix) {
    if (!this.userId || !this.env.DB) {
      return {};
    }
    const results = await this.env.DB.prepare(
      `SELECT key, value FROM ${this.tableName}
       WHERE user_id = ? AND key LIKE ?
       ORDER BY updated_at DESC`
    ).bind(this.userId, `${prefix}%`).all();
    const data = {};
    for (const row of results.results) {
      data[row.key] = JSON.parse(row.value);
    }
    return data;
  }
}
const logger$9 = createLogger({ serviceName: "semantic-memory" });
class SemanticMemory {
  constructor(env, userId) {
    this.env = env;
    this.userId = userId;
    this.embeddingModel = "@cf/baai/bge-base-en-v1.5";
  }
  /**
   * Add a memory to semantic storage
   */
  async add(content, metadata) {
    if (!this.userId || !this.env.VECTORIZE || !this.env.AI) {
      return "";
    }
    const embedding = await this.generateEmbedding(content);
    const userId = this.userId;
    const id = `${userId}-${Date.now()}-${Math.random().toString(36).substring(7)}`;
    await this.env.VECTORIZE.upsert([
      {
        id,
        values: embedding,
        metadata: {
          user_id: userId,
          content,
          timestamp: Date.now(),
          ...metadata
        }
      }
    ]);
    return id;
  }
  /**
   * Add multiple memories
   */
  async addMany(memories) {
    if (!this.userId || !this.env.VECTORIZE || !this.env.AI) {
      return [];
    }
    const embeddings = await this.generateEmbeddings(memories.map((m) => m.content));
    const userId = this.userId;
    const vectors = memories.map((memory2, i) => ({
      id: `${userId}-${Date.now()}-${i}-${Math.random().toString(36).substring(7)}`,
      values: embeddings[i],
      metadata: {
        user_id: userId,
        content: memory2.content,
        timestamp: Date.now(),
        ...memory2.metadata
      }
    }));
    await this.env.VECTORIZE.upsert(vectors);
    return vectors.map((v) => v.id);
  }
  /**
   * Search for semantically similar memories
   */
  async search(query, options) {
    if (!this.userId || !this.env.VECTORIZE || !this.env.AI) {
      return [];
    }
    const queryEmbedding = await this.generateEmbedding(query);
    const results = await this.env.VECTORIZE.query(queryEmbedding, {
      topK: options?.topK || 5,
      filter: { user_id: this.userId, ...options?.filter },
      returnValues: false,
      returnMetadata: true
    });
    return results.matches.filter((match) => !options?.minScore || match.score >= options.minScore).map((match) => ({
      id: match.id,
      content: match.metadata.content,
      timestamp: match.metadata.timestamp,
      metadata: match.metadata,
      score: match.score
    }));
  }
  /**
   * Get a specific memory by ID
   */
  async get(id) {
    if (!this.userId || !this.env.VECTORIZE) {
      return null;
    }
    return null;
  }
  /**
   * Delete a memory
   */
  async delete(id) {
    if (!this.userId || !this.env.VECTORIZE) {
      return;
    }
    await this.env.VECTORIZE.deleteByIds([id]);
  }
  /**
   * Delete multiple memories
   */
  async deleteMany(ids) {
    if (!this.userId || !this.env.VECTORIZE || ids.length === 0) {
      return;
    }
    await this.env.VECTORIZE.deleteByIds(ids);
  }
  /**
   * Clear all memories for this user
   */
  async clear() {
    if (!this.userId || !this.env.VECTORIZE) {
      return;
    }
    logger$9.warn("Semantic memory clear not fully implemented - requires ID tracking", {
      userId: this.userId
    });
  }
  /**
   * Generate embedding for a single text
   */
  async generateEmbedding(text) {
    const result = await this.env.AI.run(this.embeddingModel, {
      text: [text]
    });
    return Array.isArray(result.data[0]) ? result.data[0] : result.data;
  }
  /**
   * Generate embeddings for multiple texts
   */
  async generateEmbeddings(texts) {
    const result = await this.env.AI.run(this.embeddingModel, {
      text: texts
    });
    return result.data;
  }
  /**
   * Calculate similarity between two texts
   */
  async similarity(text1, text2) {
    if (!this.env.AI) {
      return 0;
    }
    const embeddings = await this.generateEmbeddings([text1, text2]);
    return this.cosineSimilarity(embeddings[0], embeddings[1]);
  }
  /**
   * Calculate cosine similarity between two vectors
   */
  cosineSimilarity(vec1, vec2) {
    if (vec1.length !== vec2.length) {
      return 0;
    }
    let dotProduct = 0;
    let norm1 = 0;
    let norm2 = 0;
    for (let i = 0; i < vec1.length; i++) {
      dotProduct += vec1[i] * vec2[i];
      norm1 += vec1[i] * vec1[i];
      norm2 += vec2[i] * vec2[i];
    }
    norm1 = Math.sqrt(norm1);
    norm2 = Math.sqrt(norm2);
    if (norm1 === 0 || norm2 === 0) {
      return 0;
    }
    return dotProduct / (norm1 * norm2);
  }
}
class AnalyticalMemory {
  constructor(_env, config) {
    this.config = config;
    this.repositories = /* @__PURE__ */ new Map();
    this.defaultDatabase = config.defaultDatabase;
    if (config.enableCache && config.cacheKV) {
      this.cache = new QueryCache({
        kv: config.cacheKV,
        defaultTTL: config.cacheTTL || 300,
        keyPrefix: "analytical:",
        enableStats: true
      });
    }
    for (const [alias, dbConfig] of Object.entries(config.databases)) {
      const repository = new HyperdriveRepository(dbConfig.binding, {
        databaseType: dbConfig.type,
        schema: dbConfig.schema,
        options: {
          readOnly: dbConfig.readOnly,
          timeout: dbConfig.timeout,
          maxRows: dbConfig.maxRows
        }
      });
      this.repositories.set(alias, repository);
    }
  }
  /**
   * Query a specific database
   */
  async query(sql, params, database) {
    const dbAlias = database || this.defaultDatabase;
    if (!dbAlias) {
      throw new Error("No database specified and no default database configured");
    }
    const repository = this.repositories.get(dbAlias);
    if (!repository) {
      throw new Error(`Database not found: ${dbAlias}`);
    }
    if (this.cache && QueryCache.shouldCache(sql)) {
      const cachedResult = await this.cache.get(sql, params, dbAlias);
      if (cachedResult.success && cachedResult.value) {
        return cachedResult.value.rows;
      }
    }
    const result = await repository.query(sql, params);
    if (!result.success) {
      throw new Error(`Query failed: ${result.error.message}`);
    }
    if (this.cache && QueryCache.shouldCache(sql)) {
      const ttl = QueryCache.getRecommendedTTL(sql);
      await this.cache.set(sql, result.value, params, dbAlias, ttl);
    }
    return result.value.rows;
  }
  /**
   * Query with named parameters
   */
  async queryNamed(sql, params, database) {
    const dbAlias = database || this.defaultDatabase;
    if (!dbAlias) {
      throw new Error("No database specified and no default database configured");
    }
    const repository = this.repositories.get(dbAlias);
    if (!repository) {
      throw new Error(`Database not found: ${dbAlias}`);
    }
    const result = await repository.queryNamed(sql, params);
    if (!result.success) {
      throw new Error(`Query failed: ${result.error.message}`);
    }
    return result.value.rows;
  }
  /**
   * Query with full result metadata
   */
  async queryWithMetadata(sql, params, database) {
    const dbAlias = database || this.defaultDatabase;
    if (!dbAlias) {
      return Result.err(Errors.internal("No database specified and no default database configured"));
    }
    const repository = this.repositories.get(dbAlias);
    if (!repository) {
      return Result.err(Errors.internal(`Database not found: ${dbAlias}`));
    }
    return repository.query(sql, params);
  }
  /**
   * Execute a write query (INSERT, UPDATE, DELETE)
   */
  async execute(sql, params, database) {
    const dbAlias = database || this.defaultDatabase;
    if (!dbAlias) {
      throw new Error("No database specified and no default database configured");
    }
    const repository = this.repositories.get(dbAlias);
    if (!repository) {
      throw new Error(`Database not found: ${dbAlias}`);
    }
    if (repository.isReadOnly()) {
      throw new Error(`Database is read-only: ${dbAlias}`);
    }
    const result = await repository.execute(sql, params);
    if (!result.success) {
      throw new Error(`Execute failed: ${result.error.message}`);
    }
    return result.value.rowsAffected;
  }
  /**
   * Execute queries across multiple databases (federated query)
   */
  async queryMultiple(queries) {
    const results = /* @__PURE__ */ new Map();
    const promises = queries.map(async (query) => {
      const rows = await this.query(query.sql, query.params, query.database);
      return { database: query.database, rows };
    });
    const queryResults = await Promise.all(promises);
    for (const result of queryResults) {
      results.set(result.database, result.rows);
    }
    return results;
  }
  /**
   * Begin a transaction on a specific database
   */
  async transaction(database, callback) {
    const repository = this.repositories.get(database);
    if (!repository) {
      throw new Error(`Database not found: ${database}`);
    }
    const result = await repository.transaction(async (tx) => {
      return await callback(repository);
    });
    if (!result.success) {
      throw new Error(`Transaction failed: ${result.error.message}`);
    }
    return result.value;
  }
  /**
   * Get list of available databases
   */
  getDatabases() {
    return Array.from(this.repositories.keys());
  }
  /**
   * Check if a database is available
   */
  hasDatabase(alias) {
    return this.repositories.has(alias);
  }
  /**
   * Get database configuration
   */
  getDatabaseConfig(alias) {
    return this.config.databases[alias];
  }
  /**
   * Get repository for a database
   */
  getRepository(alias) {
    return this.repositories.get(alias);
  }
  /**
   * List tables in a database
   */
  async listTables(database) {
    const dbAlias = database || this.defaultDatabase;
    if (!dbAlias) {
      throw new Error("No database specified and no default database configured");
    }
    const repository = this.repositories.get(dbAlias);
    if (!repository) {
      throw new Error(`Database not found: ${dbAlias}`);
    }
    const result = await repository.listTables();
    if (!result.success) {
      throw new Error(`Failed to list tables: ${result.error.message}`);
    }
    return result.value;
  }
  /**
   * Get table metadata
   */
  async getTableInfo(tableName, database) {
    const dbAlias = database || this.defaultDatabase;
    if (!dbAlias) {
      throw new Error("No database specified and no default database configured");
    }
    const repository = this.repositories.get(dbAlias);
    if (!repository) {
      throw new Error(`Database not found: ${dbAlias}`);
    }
    const result = await repository.getTableInfo(tableName);
    if (!result.success) {
      throw new Error(`Failed to get table info: ${result.error.message}`);
    }
    return result.value;
  }
  /**
   * Get default database alias
   */
  getDefaultDatabase() {
    return this.defaultDatabase;
  }
  /**
   * Set default database
   */
  setDefaultDatabase(alias) {
    if (!this.repositories.has(alias)) {
      throw new Error(`Database not found: ${alias}`);
    }
    this.defaultDatabase = alias;
  }
  /**
   * Get cache statistics (if caching is enabled)
   */
  getCacheStats() {
    return this.cache?.getStats();
  }
  /**
   * Clear cache for a specific database
   */
  async clearCache(database) {
    if (!this.cache) {
      return 0;
    }
    if (database) {
      const result = await this.cache.clearDatabase(database);
      return result.success ? result.value : 0;
    } else {
      const result = await this.cache.clearAll();
      return result.success ? result.value : 0;
    }
  }
  /**
   * Reset cache statistics
   */
  resetCacheStats() {
    this.cache?.resetStats();
  }
  /**
   * Check if caching is enabled
   */
  isCacheEnabled() {
    return this.cache !== void 0;
  }
}
class MemoryManager {
  constructor(env, config, userId, sessionId) {
    this.env = env;
    this.config = config;
    this.userId = userId;
    this.sessionId = sessionId;
    this.sessionMemory = null;
    this.longTermMemory = null;
    this.semanticMemory = null;
    this.analyticalMemory = null;
    this.workingMemory = new WorkingMemory();
    if (config.layers.session && sessionId) {
      this.sessionMemory = new SessionMemory(env, sessionId, config.sessionTTL);
    }
    if (config.layers.longTerm && userId) {
      this.longTermMemory = new LongTermMemory(env, userId);
    }
    if (config.layers.semantic && userId) {
      this.semanticMemory = new SemanticMemory(env, userId);
    }
    if (config.layers.analytical && config.analyticalConfig) {
      this.analyticalMemory = new AnalyticalMemory(env, config.analyticalConfig);
    }
  }
  // ==================== Working Memory ====================
  /**
   * Set a value in working memory
   */
  setWorking(key, value) {
    this.workingMemory.set(key, value);
  }
  /**
   * Get a value from working memory
   */
  getWorking(key) {
    return this.workingMemory.get(key);
  }
  /**
   * Get all working memory
   */
  getWorkingAll() {
    return this.workingMemory.getAll();
  }
  /**
   * Clear working memory
   */
  clearWorking() {
    this.workingMemory.clear();
  }
  // ==================== Session Memory ====================
  /**
   * Add a message to session memory
   */
  async addMessage(message2) {
    if (!this.sessionMemory) {
      return;
    }
    await this.sessionMemory.add(message2);
  }
  /**
   * Get conversation history
   */
  async getConversationHistory() {
    if (!this.sessionMemory) {
      return [];
    }
    const history = await this.sessionMemory.get();
    return history.messages;
  }
  /**
   * Get last N messages
   */
  async getLastMessages(n) {
    if (!this.sessionMemory) {
      return [];
    }
    return await this.sessionMemory.getLastN(n);
  }
  /**
   * Clear session memory
   */
  async clearSession() {
    if (!this.sessionMemory) {
      return;
    }
    await this.sessionMemory.clear();
  }
  /**
   * Compress session memory
   */
  async compressSession(maxMessages) {
    if (!this.sessionMemory) {
      return;
    }
    await this.sessionMemory.compress(maxMessages);
  }
  /**
   * Format messages for AI model consumption
   * Strips metadata - returns only role + content
   * Limits to maxContext most recent messages
   *
   * @param maxContext - Maximum messages to include (default: 10 = 5 exchanges)
   */
  async formatMessagesForAI(maxContext = 10) {
    if (!this.sessionMemory) {
      return [];
    }
    return await this.sessionMemory.formatForAI(maxContext);
  }
  /**
   * Get conversation metadata (for debugging/analytics)
   */
  async getConversationMetadata() {
    if (!this.sessionMemory) {
      return null;
    }
    return await this.sessionMemory.getMetadata();
  }
  // ==================== Long-Term Memory ====================
  /**
   * Set a value in long-term memory
   */
  async setLongTerm(key, value) {
    if (!this.longTermMemory) {
      return;
    }
    await this.longTermMemory.set(key, value);
  }
  /**
   * Get a value from long-term memory
   */
  async getLongTerm(key) {
    if (!this.longTermMemory) {
      return null;
    }
    return await this.longTermMemory.get(key);
  }
  /**
   * Get all long-term memory
   */
  async getLongTermAll() {
    if (!this.longTermMemory) {
      return {};
    }
    return await this.longTermMemory.getAll();
  }
  /**
   * Delete from long-term memory
   */
  async deleteLongTerm(key) {
    if (!this.longTermMemory) {
      return;
    }
    await this.longTermMemory.delete(key);
  }
  /**
   * Clear long-term memory
   */
  async clearLongTerm() {
    if (!this.longTermMemory) {
      return;
    }
    await this.longTermMemory.clear();
  }
  // ==================== Semantic Memory ====================
  /**
   * Add a memory to semantic storage
   */
  async addSemantic(content, metadata) {
    if (!this.semanticMemory) {
      return "";
    }
    return await this.semanticMemory.add(content, metadata);
  }
  /**
   * Search semantic memory
   */
  async searchSemantic(query, options) {
    if (!this.semanticMemory) {
      return [];
    }
    return await this.semanticMemory.search(query, options);
  }
  /**
   * Delete from semantic memory
   */
  async deleteSemantic(id) {
    if (!this.semanticMemory) {
      return;
    }
    await this.semanticMemory.delete(id);
  }
  /**
   * Clear semantic memory
   */
  async clearSemantic() {
    if (!this.semanticMemory) {
      return;
    }
    await this.semanticMemory.clear();
  }
  // ==================== Unified Operations ====================
  /**
   * Create a complete memory snapshot
   */
  async snapshot() {
    const snapshot = {
      working: this.workingMemory.getAll()
    };
    if (this.sessionMemory) {
      snapshot.session = await this.sessionMemory.get();
    }
    if (this.longTermMemory) {
      snapshot.longTerm = await this.longTermMemory.getAll();
    }
    if (this.semanticMemory) {
      snapshot.semantic = [];
    }
    return snapshot;
  }
  /**
   * Clear all memory layers
   */
  async clearAll() {
    this.clearWorking();
    await this.clearSession();
    await this.clearLongTerm();
    await this.clearSemantic();
  }
  /**
   * Get memory statistics
   */
  async getStats() {
    const stats = {
      working: { size: this.workingMemory.size() }
    };
    if (this.sessionMemory) {
      stats.session = {
        messageCount: await this.sessionMemory.count()
      };
    }
    if (this.longTermMemory) {
      stats.longTerm = {
        keyCount: await this.longTermMemory.count()
      };
    }
    if (this.semanticMemory) {
      stats.semantic = {
        note: "Semantic memory count not available via Vectorize API"
      };
    }
    if (this.analyticalMemory) {
      stats.analytical = {
        databases: this.analyticalMemory.getDatabases(),
        databaseCount: this.analyticalMemory.getDatabases().length
      };
    }
    return stats;
  }
  /**
   * Check if a memory layer is enabled
   */
  isLayerEnabled(layer) {
    switch (layer) {
      case "working":
        return true;
      // Always enabled
      case "session":
        return !!this.sessionMemory;
      case "longTerm":
        return !!this.longTermMemory;
      case "semantic":
        return !!this.semanticMemory;
      case "analytical":
        return !!this.analyticalMemory;
      default:
        return false;
    }
  }
  // ==================== Analytical Memory ====================
  /**
   * Query analytical database
   */
  async queryAnalytical(sql, params, database) {
    if (!this.analyticalMemory) {
      return [];
    }
    return await this.analyticalMemory.query(sql, params, database);
  }
  /**
   * Query analytical database with named parameters
   */
  async queryAnalyticalNamed(sql, params, database) {
    if (!this.analyticalMemory) {
      return [];
    }
    return await this.analyticalMemory.queryNamed(sql, params, database);
  }
  /**
   * Execute write query on analytical database
   */
  async executeAnalytical(sql, params, database) {
    if (!this.analyticalMemory) {
      return 0;
    }
    return await this.analyticalMemory.execute(sql, params, database);
  }
  /**
   * Execute federated query across multiple databases
   */
  async queryMultiple(queries) {
    if (!this.analyticalMemory) {
      return /* @__PURE__ */ new Map();
    }
    return await this.analyticalMemory.queryMultiple(queries);
  }
  /**
   * Get available analytical databases
   */
  getAnalyticalDatabases() {
    if (!this.analyticalMemory) {
      return [];
    }
    return this.analyticalMemory.getDatabases();
  }
  /**
   * Check if analytical database exists
   */
  hasAnalyticalDatabase(alias) {
    if (!this.analyticalMemory) {
      return false;
    }
    return this.analyticalMemory.hasDatabase(alias);
  }
  /**
   * List tables in analytical database
   */
  async listAnalyticalTables(database) {
    if (!this.analyticalMemory) {
      return [];
    }
    return await this.analyticalMemory.listTables(database);
  }
  /**
   * Get analytical memory instance (for advanced usage)
   */
  getAnalyticalMemory() {
    return this.analyticalMemory;
  }
}
function isAgentStep(step2) {
  return "agent" in step2 && typeof step2.agent === "string";
}
const DEFAULT_AGENT_TIMEOUT_MS = 3e4;
async function withTimeout(promise, timeoutMs, agentName) {
  let timeoutId;
  const timeoutPromise = new Promise((_, reject2) => {
    timeoutId = setTimeout(() => {
      reject2(new AgentExecutionError(agentName, `Agent execution timed out after ${timeoutMs}ms`));
    }, timeoutMs);
  });
  try {
    const result = await Promise.race([promise, timeoutPromise]);
    return result;
  } finally {
    if (timeoutId !== void 0) {
      clearTimeout(timeoutId);
    }
  }
}
class Executor {
  constructor(config) {
    this.env = config.env;
    this.ctx = config.ctx;
    this.agentRegistry = /* @__PURE__ */ new Map();
    this.observabilityConfig = config.observability;
    this.requestId = config.requestId;
    this.auth = config.auth;
    this.defaultTimeout = config.defaultTimeout ?? DEFAULT_AGENT_TIMEOUT_MS;
    this.logger = config.logger || createLogger({ serviceName: "executor" }, this.env.ANALYTICS);
  }
  /**
   * Register an agent for use in ensembles
   */
  registerAgent(agent) {
    this.agentRegistry.set(agent.getName(), agent);
  }
  /**
   * Resolve an agent by reference with explicit error handling
   * Supports both simple names and versioned references (name@version)
   *
   * Loading priority:
   * 1. Check built-in agents (scrape, validate, rag, hitl, fetch)
   * 2. Check user-defined agents (registered via registerAgent)
   * 3. Error if not found
   *
   * @param agentRef - Agent reference (e.g., "greet" or "analyze-company@production")
   * @returns Result containing the agent or an error
   */
  async resolveAgent(agentRef) {
    const { name, version } = Parser$1.parseAgentReference(agentRef);
    if (!version) {
      const builtInRegistry = getBuiltInRegistry();
      if (builtInRegistry.isBuiltIn(name)) {
        try {
          const config = {
            name,
            operation: builtInRegistry.getMetadata(name)?.operation || Operation.code,
            config: {}
          };
          const agent2 = await builtInRegistry.create(name, config, this.env);
          return Result.ok(agent2);
        } catch (error) {
          return Result.err(
            Errors.agentConfig(
              name,
              `Failed to load built-in agent: ${error instanceof Error ? error.message : "Unknown error"}`
            )
          );
        }
      }
      const agent = this.agentRegistry.get(name);
      if (!agent) {
        return Result.err(Errors.agentNotFound(name));
      }
      return Result.ok(agent);
    }
    const versionedKey = `${name}@${version}`;
    if (this.agentRegistry.has(versionedKey)) {
      const agent = this.agentRegistry.get(versionedKey);
      return Result.ok(agent);
    }
    const localAgent = this.agentRegistry.get(name);
    if (localAgent) {
      this.agentRegistry.set(versionedKey, localAgent);
      return Result.ok(localAgent);
    }
    return Result.err(
      Errors.agentConfig(
        agentRef,
        "Versioned agent loading requires Edgit integration. Register agents manually using executor.registerAgent()"
      )
    );
  }
  /**
   * Create an agent instance from config
   * Used for dynamically loading agents from Edgit
   */
  createAgentFromConfig(config) {
    switch (config.operation) {
      case Operation.think:
        return Result.ok(new ThinkAgent(config));
      case Operation.storage:
        return Result.ok(new StorageAgent(config));
      case Operation.data:
        return Result.ok(new DataAgent(config));
      case Operation.http:
        return Result.ok(new APIAgent(config));
      case Operation.email:
        return Result.ok(new EmailAgent(config));
      case Operation.sms:
        return Result.ok(new SmsMember(config));
      case Operation.form:
        return Result.ok(new FormAgent(config));
      case Operation.html:
        return Result.ok(new HtmlMember(config));
      case Operation.pdf:
        return Result.ok(new PdfMember(config));
      case Operation.code:
        const codeAgent = CodeAgent.fromConfig(config);
        if (codeAgent) {
          return Result.ok(codeAgent);
        }
        const inlineAgent = FunctionAgent.fromConfig(config);
        if (inlineAgent) {
          return Result.ok(inlineAgent);
        }
        return Result.err(
          Errors.agentConfig(
            config.name,
            "Code agents require either a script:// URI or an inline handler function"
          )
        );
      case Operation.tools:
        return Result.err(Errors.agentConfig(config.name, "MCP agent type not yet implemented"));
      case Operation.scoring:
        return Result.err(Errors.agentConfig(config.name, "Scoring agent type not yet implemented"));
      default:
        return Result.err(
          Errors.agentConfig(config.name, `Unknown agent operation: ${config.operation}`)
        );
    }
  }
  /**
   * Resolve input for a step based on explicit mapping, previous output, or ensemble input
   * @private
   */
  resolveStepInput(step2, flowContext, stepIndex) {
    const { ensemble, executionContext } = flowContext;
    if (step2.input) {
      return Parser$1.resolveInterpolation(step2.input, executionContext);
    } else if (stepIndex > 0 && ensemble.flow) {
      const previousStep = ensemble.flow[stepIndex - 1];
      const previousAgentName = isAgentStep(previousStep) ? previousStep.agent : void 0;
      if (previousAgentName) {
        const previousResult = executionContext[previousAgentName];
        return previousResult?.output || {};
      }
    }
    return executionContext.input || {};
  }
  /**
   * Build the agent execution context with all necessary dependencies
   * @private
   */
  buildAgentContext(resolvedInput, flowContext, agentLogger, agentMetrics, agentConfig) {
    return {
      input: resolvedInput,
      env: this.env,
      ctx: this.ctx,
      previousOutputs: flowContext.executionContext,
      logger: agentLogger,
      metrics: agentMetrics,
      executionId: flowContext.executionId,
      requestId: this.requestId,
      auth: this.auth,
      // Component registries for TypeScript handlers
      schemas: flowContext.componentRegistry.schemas,
      prompts: flowContext.componentRegistry.prompts,
      configs: flowContext.componentRegistry.configs,
      queries: flowContext.componentRegistry.queries,
      scripts: flowContext.componentRegistry.scripts,
      templates: flowContext.componentRegistry.templates,
      // Discovery registries for agents and ensembles
      agentRegistry: flowContext.agentRegistry,
      ensembleRegistry: flowContext.ensembleRegistry,
      // Agent-specific config from ensemble definition
      config: agentConfig,
      // Memory manager for conversation history and persistent storage
      memory: flowContext.memoryManager ?? void 0
    };
  }
  /**
   * Execute agent with scoring/retry logic
   * @private
   */
  async executeAgentWithScoring(stepContext) {
    const { step: step2, flowContext, agent, agentContext, getPendingUpdates } = stepContext;
    const { ensemble, executionContext, scoringState, ensembleScorer, scoringExecutor, stateManager } = flowContext;
    const agentTimeout = step2.timeout ?? this.defaultTimeout;
    const scoringConfig = step2.scoring;
    const scoredResult = await scoringExecutor.executeWithScoring(
      // Agent execution function (with timeout)
      async () => {
        const resp = await withTimeout(
          agent.execute(agentContext),
          agentTimeout,
          step2.agent
        );
        if (stateManager && getPendingUpdates) {
          const { updates, newLog } = getPendingUpdates();
          flowContext.stateManager = stateManager.applyPendingUpdates(updates, newLog);
        }
        return resp;
      },
      // Evaluator function
      async (output, attempt, previousScore) => {
        const evaluatorResult = await this.resolveAgent(scoringConfig.evaluator);
        if (!evaluatorResult.success) {
          throw new Error(`Failed to resolve evaluator agent: ${evaluatorResult.error.message}`);
        }
        const evaluator = evaluatorResult.value;
        const evalContext = {
          input: {
            output: output.success ? output.data : null,
            attempt,
            previousScore,
            criteria: scoringConfig.criteria || ensemble.scoring?.criteria
          },
          env: this.env,
          ctx: this.ctx,
          previousOutputs: executionContext
        };
        const evalResponse = await evaluator.execute(evalContext);
        if (!evalResponse.success) {
          throw new Error(`Evaluator failed: ${evalResponse.error || "Unknown error"}`);
        }
        const evalData = evalResponse.data;
        const score = typeof evalData === "number" ? evalData : typeof evalData === "object" && evalData !== null && "score" in evalData ? evalData.score : typeof evalData === "object" && evalData !== null && "value" in evalData ? evalData.value : 0;
        const threshold = scoringConfig.thresholds?.minimum || ensemble.scoring?.defaultThresholds?.minimum || 0.7;
        return {
          score,
          passed: score >= threshold,
          feedback: typeof evalData === "object" && evalData !== null && "feedback" in evalData ? String(evalData.feedback) : typeof evalData === "object" && evalData !== null && "message" in evalData ? String(evalData.message) : "",
          breakdown: typeof evalData === "object" && evalData !== null && "breakdown" in evalData ? evalData.breakdown : {},
          metadata: {
            attempt,
            evaluator: scoringConfig.evaluator,
            timestamp: Date.now()
          }
        };
      },
      scoringConfig
    );
    const scoringResult = scoredResult.score;
    if (scoringState && ensembleScorer) {
      scoringState.scoreHistory.push({
        agent: step2.agent,
        score: scoringResult.score,
        passed: scoringResult.passed,
        feedback: scoringResult.feedback,
        breakdown: scoringResult.breakdown,
        timestamp: Date.now(),
        attempt: scoredResult.attempts
      });
      scoringState.retryCount[step2.agent] = scoredResult.attempts - 1;
      if (scoredResult.status === "max_retries_exceeded") {
        this.logger.warn("Agent exceeded max retries", {
          agentName: step2.agent,
          score: scoringResult.score,
          attempts: scoredResult.attempts,
          ensembleName: ensemble.name
        });
      }
    }
    return { response: scoredResult.output, scoringResult };
  }
  /**
   * Execute agent without scoring (normal path)
   * @private
   */
  async executeAgentDirect(stepContext) {
    const { step: step2, flowContext, agent, agentContext, getPendingUpdates } = stepContext;
    const { stateManager } = flowContext;
    const agentTimeout = step2.timeout ?? this.defaultTimeout;
    const response = await withTimeout(
      agent.execute(agentContext),
      agentTimeout,
      step2.agent
    );
    if (stateManager && getPendingUpdates) {
      const { updates, newLog } = getPendingUpdates();
      flowContext.stateManager = stateManager.applyPendingUpdates(updates, newLog);
    }
    return response;
  }
  /**
   * Record agent execution metrics
   * @private
   */
  recordAgentMetrics(stepContext, response, agentStartTime) {
    const { step: step2, flowContext, agentMetrics } = stepContext;
    const agentDuration = Date.now() - agentStartTime;
    flowContext.metrics.agents.push({
      name: step2.agent,
      duration: agentDuration,
      cached: response.cached,
      success: response.success
    });
    if (response.cached) {
      flowContext.metrics.cacheHits++;
      if (flowContext.observability.shouldLogEvent("cache:hit")) {
        stepContext.agentLogger.debug("Cache hit", { agentName: step2.agent });
      }
      agentMetrics.recordCachePerformance(true, step2.agent);
    } else {
      agentMetrics.recordCachePerformance(false, step2.agent);
    }
    agentMetrics.recordAgentExecution(step2.agent, agentDuration, response.success, response.cached);
  }
  /**
   * Execute a single flow step with all associated logic
   * Only handles AgentFlowStep - control flow steps should use GraphExecutor
   * @private
   */
  async executeStep(step2, flowContext, stepIndex) {
    const { ensemble, executionContext, stateManager, scoringState, ensembleScorer } = flowContext;
    const agentStartTime = Date.now();
    const resolvedInput = this.resolveStepInput(step2, flowContext, stepIndex);
    const agentResult = await this.resolveAgent(step2.agent);
    if (!agentResult.success) {
      return Result.err(new EnsembleExecutionError(ensemble.name, step2.agent, agentResult.error));
    }
    const agent = agentResult.value;
    const agentObservability = flowContext.observability.forAgent(step2.agent, stepIndex);
    const agentLogger = agentObservability.getLogger();
    const agentMetrics = agentObservability.getMetrics();
    if (flowContext.observability.shouldLogEvent("agent:start")) {
      agentLogger.info("Agent execution started", {
        agentName: step2.agent,
        stepIndex,
        ensembleName: ensemble.name
      });
    }
    const agentDef = ensemble.agents?.find(
      (a) => a.name === step2.agent
    );
    const agentConfig = agentDef?.config || void 0;
    const agentContext = this.buildAgentContext(
      resolvedInput,
      flowContext,
      agentLogger,
      agentMetrics,
      agentConfig
    );
    let getPendingUpdates = null;
    if (stateManager && step2.state) {
      const { context, getPendingUpdates: getUpdates } = stateManager.getStateForAgent(
        step2.agent,
        step2.state
      );
      agentContext.state = context.state;
      agentContext.setState = context.setState;
      getPendingUpdates = getUpdates;
    }
    const stepContext = {
      step: step2,
      flowContext,
      stepIndex,
      agent,
      resolvedInput,
      agentLogger,
      agentMetrics,
      agentContext,
      getPendingUpdates
    };
    let response;
    if (step2.scoring && scoringState && ensembleScorer) {
      const result = await this.executeAgentWithScoring(stepContext);
      response = result.response;
    } else {
      response = await this.executeAgentDirect(stepContext);
    }
    this.recordAgentMetrics(stepContext, response, agentStartTime);
    if (!response.success) {
      const agentDuration = Date.now() - agentStartTime;
      if (flowContext.observability.shouldLogEvent("agent:error")) {
        agentLogger.error("Agent execution failed", new Error(response.error || "Unknown error"), {
          agentName: step2.agent,
          durationMs: agentDuration,
          stepIndex
        });
      }
      agentMetrics.recordError("AgentExecutionError", step2.agent);
      return Result.err(
        new AgentExecutionError(step2.agent, response.error || "Unknown error", void 0)
      );
    }
    if (flowContext.observability.shouldLogEvent("agent:complete")) {
      const agentDuration = Date.now() - agentStartTime;
      agentLogger.info("Agent execution completed", {
        agentName: step2.agent,
        durationMs: agentDuration,
        stepIndex,
        cached: response.cached
      });
    }
    const contextKey = step2.id || step2.agent;
    executionContext[contextKey] = {
      output: response.data
    };
    if (flowContext.stateManager) {
      executionContext.state = flowContext.stateManager.getState();
    }
    if (scoringState) {
      executionContext.scoring = scoringState;
    }
    return Result.ok(void 0);
  }
  /**
   * Execute ensemble flow from a given step
   * Automatically uses GraphExecutor for flows with control flow steps (parallel, branch, etc.)
   * @private
   */
  async executeFlow(flowContext, startStep = 0) {
    const {
      ensemble,
      executionContext,
      metrics,
      stateManager,
      scoringState,
      ensembleScorer,
      startTime
    } = flowContext;
    if (!ensemble.flow || ensemble.flow.length === 0) {
      return Result.err(
        new EnsembleExecutionError(
          ensemble.name,
          "validation",
          new Error("Ensemble has no flow steps defined")
        )
      );
    }
    const flowSteps = ensemble.flow.slice(startStep);
    if (hasControlFlowSteps(flowSteps)) {
      return this.executeFlowWithGraph(flowContext, startStep);
    }
    for (let i = startStep; i < ensemble.flow.length; i++) {
      const step2 = ensemble.flow[i];
      if (!isAgentStep(step2)) {
        return Result.err(
          new EnsembleExecutionError(
            ensemble.name,
            "flow",
            new Error(`Unexpected control flow step at index ${i}`)
          )
        );
      }
      const stepResult = await this.executeStep(step2, flowContext, i);
      if (!stepResult.success) {
        return Result.err(stepResult.error);
      }
    }
    if (scoringState && ensembleScorer && scoringState.scoreHistory.length > 0) {
      scoringState.finalScore = ensembleScorer.calculateEnsembleScore(scoringState.scoreHistory);
      scoringState.qualityMetrics = ensembleScorer.calculateQualityMetrics(
        scoringState.scoreHistory
      );
    }
    let finalOutput;
    let responseMetadata;
    if (ensemble.output) {
      const resolved = resolveOutput(ensemble.output, executionContext);
      if (resolved.redirect) {
        finalOutput = {};
        responseMetadata = {
          status: resolved.status,
          headers: resolved.headers,
          redirect: resolved.redirect
        };
      } else if (resolved.rawBody !== void 0) {
        finalOutput = resolved.rawBody;
        responseMetadata = {
          status: resolved.status,
          headers: resolved.headers,
          isRawBody: true
        };
      } else {
        finalOutput = resolved.body ?? {};
        responseMetadata = {
          status: resolved.status,
          headers: resolved.headers
        };
      }
    } else if (ensemble.flow && ensemble.flow.length > 0) {
      const lastStep = ensemble.flow[ensemble.flow.length - 1];
      const lastMemberName = isAgentStep(lastStep) ? lastStep.agent : void 0;
      if (lastMemberName) {
        const lastResult = executionContext[lastMemberName];
        finalOutput = lastResult?.output;
      } else {
        finalOutput = {};
      }
    } else {
      finalOutput = {};
    }
    metrics.totalDuration = Date.now() - startTime;
    const stateReport = flowContext.stateManager?.getAccessReport();
    const executionOutput = {
      output: finalOutput,
      metrics,
      stateReport,
      response: responseMetadata
    };
    if (scoringState) {
      executionOutput.scoring = scoringState;
    }
    return Result.ok(executionOutput);
  }
  /**
   * Execute flow using GraphExecutor for control flow constructs
   * Handles parallel, branch, foreach, try/catch, switch, while, and map-reduce steps
   * @private
   */
  async executeFlowWithGraph(flowContext, startStep = 0) {
    const {
      ensemble,
      executionContext,
      metrics,
      stateManager,
      scoringState,
      ensembleScorer,
      startTime
    } = flowContext;
    const agentExecutorFn = async (step2, graphContext) => {
      for (const [key, value] of graphContext.results) {
        executionContext[key] = { output: value };
      }
      const stepIndex = ensemble.flow ? ensemble.flow.findIndex(
        (s) => isAgentStep(s) && (s.id === step2.id || s.agent === step2.agent)
      ) : -1;
      const result = await this.executeStep(step2, flowContext, stepIndex >= 0 ? stepIndex : 0);
      if (!result.success) {
        throw result.error;
      }
      const contextKey = step2.id || step2.agent;
      const agentResult = executionContext[contextKey];
      return agentResult?.output;
    };
    const graphExecutor = new GraphExecutor(agentExecutorFn, ensemble.name);
    const flowSteps = ensemble.flow?.slice(startStep) || [];
    const graphResult = await graphExecutor.execute(flowSteps, {
      input: executionContext.input,
      state: stateManager ? stateManager.getState() : void 0
    });
    if (!graphResult.success) {
      return Result.err(graphResult.error);
    }
    for (const [key, value] of Object.entries(graphResult.value)) {
      executionContext[key] = { output: value };
    }
    if (scoringState && ensembleScorer && scoringState.scoreHistory.length > 0) {
      scoringState.finalScore = ensembleScorer.calculateEnsembleScore(scoringState.scoreHistory);
      scoringState.qualityMetrics = ensembleScorer.calculateQualityMetrics(
        scoringState.scoreHistory
      );
    }
    let finalOutput;
    let responseMetadata;
    if (ensemble.output) {
      const resolved = resolveOutput(ensemble.output, executionContext);
      if (resolved.redirect) {
        finalOutput = {};
        responseMetadata = {
          status: resolved.status,
          headers: resolved.headers,
          redirect: resolved.redirect
        };
      } else if (resolved.rawBody !== void 0) {
        finalOutput = resolved.rawBody;
        responseMetadata = {
          status: resolved.status,
          headers: resolved.headers,
          isRawBody: true
        };
      } else {
        finalOutput = resolved.body ?? {};
        responseMetadata = {
          status: resolved.status,
          headers: resolved.headers
        };
      }
    } else if (ensemble.flow && ensemble.flow.length > 0) {
      const lastStep = ensemble.flow[ensemble.flow.length - 1];
      const lastKey = isAgentStep(lastStep) ? lastStep.id || lastStep.agent : `step_${ensemble.flow.length - 1}`;
      if (graphResult.value[lastKey]) {
        finalOutput = graphResult.value[lastKey];
      } else {
        const keys = Object.keys(graphResult.value);
        if (keys.length > 0) {
          finalOutput = graphResult.value[keys[keys.length - 1]];
        } else {
          finalOutput = {};
        }
      }
    } else {
      finalOutput = {};
    }
    metrics.totalDuration = Date.now() - startTime;
    const stateReport = flowContext.stateManager?.getAccessReport();
    const executionOutput = {
      output: finalOutput,
      metrics,
      stateReport,
      response: responseMetadata
    };
    if (scoringState) {
      executionOutput.scoring = scoringState;
    }
    return Result.ok(executionOutput);
  }
  /**
   * Register inline agents defined in an ensemble's agents array
   *
   * Supports:
   * 1. script:// URIs - Resolved from bundled scripts (Works in Workers!)
   * 2. Pre-compiled handlers - Function objects passed in config.handler
   * 3. Inline code strings - DEPRECATED, only works in test environments
   *
   * @private
   */
  registerInlineAgents(ensemble) {
    if (!ensemble.agents || ensemble.agents.length === 0) {
      return;
    }
    for (const agentDef of ensemble.agents) {
      if (typeof agentDef !== "object" || agentDef === null) {
        continue;
      }
      const name = agentDef.name;
      const operation = agentDef.operation;
      const config = agentDef.config;
      if (!name || !operation) {
        this.logger.warn("Skipping inline agent without name or operation", { agentDef });
        continue;
      }
      if (this.agentRegistry.has(name)) {
        this.logger.debug("Inline agent already registered", { name });
        continue;
      }
      const agentConfig = {
        name,
        operation,
        config: config || {}
      };
      if (operation === Operation.code || operation === "function") {
        const scriptRef = config?.script;
        const inlineCode = config?.code || config?.function;
        const precompiledHandler = config?.handler;
        if (isScriptReference(scriptRef)) {
          try {
            const handler = this.resolveScriptHandler(scriptRef, name);
            agentConfig.config = { ...config, handler };
          } catch (error) {
            this.logger.error(
              "Failed to resolve script",
              error instanceof Error ? error : void 0,
              { name, scriptRef }
            );
            continue;
          }
        } else if (typeof precompiledHandler === "function") {
          this.logger.debug("Using pre-compiled handler", { name });
        } else if (typeof inlineCode === "string") {
          this.logger.error(
            "Inline code is not supported",
            new Error(
              `Agent "${name}" uses inline code (config.code) which is not supported.
Cloudflare Workers block new Function() and eval() for security.

To fix this, migrate to bundled scripts:
1. Create a file: scripts/${name}.ts
2. Export your function: export default async function(context) { ... }
3. Update your ensemble to use: config.script: "scripts/${name}"

See: https://docs.ensemble.ai/conductor/guides/migrate-inline-code`
            ),
            { name }
          );
          continue;
        }
      }
      const agentResult = this.createAgentFromConfig(agentConfig);
      if (agentResult.success) {
        this.agentRegistry.set(name, agentResult.value);
        this.logger.debug("Registered inline agent", { name, operation });
      } else {
        this.logger.warn("Failed to create inline agent", {
          name,
          error: agentResult.error.message
        });
      }
    }
  }
  /**
   * Resolve a script:// URI to a handler function from bundled scripts
   * @private
   */
  resolveScriptHandler(scriptUri, agentName) {
    {
      const scriptPath = parseScriptURI(scriptUri);
      throw new Error(
        `Cannot resolve script "${scriptUri}" for agent "${agentName}".

Script loader not initialized. For Cloudflare Workers:
1. Ensure scripts/${scriptPath}.ts exists with a default export
2. Initialize the script loader in your worker entry:

   import { scriptsMap } from 'virtual:conductor-scripts'
   import { setGlobalScriptLoader, createScriptLoader } from '@ensemble-edge/conductor'
   setGlobalScriptLoader(createScriptLoader(scriptsMap))`
      );
    }
  }
  /**
   * Create memory manager from ensemble config
   * Extracts userId/sessionId from input and auth context
   * @private
   */
  createMemoryManager(ensemble, input) {
    if (!ensemble.memory || ensemble.memory.enabled === false) {
      return null;
    }
    const memoryParsed = ensemble.memory;
    const memoryConfig = {
      enabled: memoryParsed.enabled !== false,
      layers: {
        working: true,
        // Always enabled
        session: memoryParsed.session?.enabled !== false && !!memoryParsed.session,
        longTerm: memoryParsed.longTerm?.enabled !== false && !!memoryParsed.longTerm,
        semantic: memoryParsed.semantic?.enabled !== false && !!memoryParsed.semantic,
        analytical: memoryParsed.analytical?.enabled !== false && !!memoryParsed.analytical
      },
      sessionTTL: memoryParsed.session?.ttl ?? 3600,
      // Default 1 hour
      semanticModel: memoryParsed.semantic?.model
    };
    let userId;
    if (memoryParsed.longTerm?.userId) {
      const userIdTemplate = memoryParsed.longTerm.userId;
      if (userIdTemplate.includes("{{") || userIdTemplate.includes("${")) {
        userId = Parser$1.resolveInterpolation(userIdTemplate, {
          input,
          auth: this.auth
        });
      } else {
        userId = userIdTemplate;
      }
    }
    if (!userId && this.auth?.user?.id) {
      userId = String(this.auth.user.id);
    }
    const sessionId = input.sessionId || input.conversationId || input.conversation_id || void 0;
    this.logger.debug("Initializing memory manager", {
      ensembleName: ensemble.name,
      layers: memoryConfig.layers,
      hasUserId: !!userId,
      hasSessionId: !!sessionId
    });
    return new MemoryManager(this.env, memoryConfig, userId, sessionId);
  }
  /**
   * Execute an ensemble with Result-based error handling
   * @param ensemble - Parsed ensemble configuration
   * @param input - Input data for the ensemble
   * @returns Result containing execution output or error
   */
  async executeEnsemble(ensemble, input) {
    const startTime = Date.now();
    const executionId = generateExecutionId();
    const observability = createObservabilityManager(
      this.observabilityConfig,
      {
        requestId: this.requestId,
        executionId,
        ensembleName: ensemble.name,
        environment: this.env.ENVIRONMENT
      },
      this.env.ANALYTICS
    );
    const ensembleLogger = observability.getLogger();
    const ensembleMetrics = observability.getMetrics();
    if (observability.shouldLogEvent("ensemble:start")) {
      ensembleLogger.info("Ensemble execution started", {
        ensembleName: ensemble.name,
        executionId
      });
    }
    const metrics = {
      ensemble: ensemble.name,
      totalDuration: 0,
      agents: [],
      cacheHits: 0
    };
    this.registerInlineAgents(ensemble);
    this.ctx.waitUntil(
      NotificationManager.emitExecutionStarted(ensemble, executionId, input, this.env)
    );
    const stateManager = ensemble.state ? new StateManager(ensemble.state) : null;
    const memoryManager = this.createMemoryManager(ensemble, input);
    let scoringState = null;
    let ensembleScorer = null;
    const scoringExecutor = new ScoringExecutor();
    if (ensemble.scoring?.enabled) {
      ensembleScorer = new EnsembleScorer(ensemble.scoring);
      scoringState = {
        scoreHistory: [],
        retryCount: {},
        qualityMetrics: void 0,
        finalScore: void 0
      };
    }
    const executionContext = {
      input,
      state: stateManager ? stateManager.getState() : {},
      scoring: scoringState || {}
    };
    const componentRegistry = createComponentRegistry(this.env);
    const agentDiscoveryRegistry = createAgentRegistry(this.agentRegistry);
    const ensembleDiscoveryRegistry = createEnsembleRegistry(/* @__PURE__ */ new Map());
    const flowContext = {
      ensemble,
      executionContext,
      metrics,
      stateManager,
      scoringState,
      ensembleScorer,
      scoringExecutor,
      startTime,
      observability,
      executionId,
      componentRegistry,
      agentRegistry: agentDiscoveryRegistry,
      ensembleRegistry: ensembleDiscoveryRegistry,
      memoryManager
    };
    const result = await this.executeFlow(flowContext, 0);
    const totalDuration = Date.now() - startTime;
    ensembleMetrics.recordEnsembleExecution(ensemble.name, totalDuration, result.success);
    if (result.success) {
      if (observability.shouldLogEvent("ensemble:complete")) {
        ensembleLogger.info("Ensemble execution completed", {
          ensembleName: ensemble.name,
          executionId,
          durationMs: totalDuration,
          agentCount: metrics.agents.length,
          cacheHits: metrics.cacheHits
        });
      }
    } else {
      if (observability.shouldLogEvent("ensemble:error")) {
        ensembleLogger.error("Ensemble execution failed", result.error, {
          ensembleName: ensemble.name,
          executionId,
          durationMs: totalDuration
        });
      }
      ensembleMetrics.recordError("EnsembleExecutionError", result.error.code);
    }
    if (result.success) {
      this.ctx.waitUntil(
        NotificationManager.emitExecutionCompleted(
          ensemble,
          executionId,
          result.value.output,
          result.value.metrics.totalDuration,
          this.env
        )
      );
    } else {
      const error = new Error(result.error.message);
      error.stack = result.error.stack;
      this.ctx.waitUntil(
        NotificationManager.emitExecutionFailed(
          ensemble,
          executionId,
          error,
          Date.now() - startTime,
          this.env
        )
      );
    }
    return result;
  }
  /**
   * Load and execute an ensemble from YAML with Result-based error handling
   */
  async executeFromYAML(yamlContent, input) {
    const parseResult = Result.fromThrowable(() => Parser$1.parseEnsemble(yamlContent));
    if (!parseResult.success) {
      return Result.err(Errors.ensembleParse("unknown", parseResult.error.message));
    }
    const ensemble = parseResult.value;
    const availableMembers = new Set(this.agentRegistry.keys());
    const validationResult = Result.fromThrowable(
      () => Parser$1.validateAgentReferences(ensemble, availableMembers)
    );
    if (!validationResult.success) {
      return Result.err(Errors.ensembleParse(ensemble.name, validationResult.error.message));
    }
    return await this.executeEnsemble(ensemble, input);
  }
  /**
   * Get all registered agent names (both built-in and user-defined)
   */
  getRegisteredMembers() {
    const builtInRegistry = getBuiltInRegistry();
    const builtInNames = builtInRegistry.getAvailableNames();
    const userDefinedNames = Array.from(this.agentRegistry.keys());
    const allNames = /* @__PURE__ */ new Set([...builtInNames, ...userDefinedNames]);
    return Array.from(allNames);
  }
  /**
   * Check if a agent is registered (checks both built-in and user-defined)
   */
  hasMember(agentName) {
    const builtInRegistry = getBuiltInRegistry();
    return builtInRegistry.isBuiltIn(agentName) || this.agentRegistry.has(agentName);
  }
  /**
   * Get all built-in agent metadata
   */
  getBuiltInMembers() {
    const builtInRegistry = getBuiltInRegistry();
    return builtInRegistry.list();
  }
  /**
   * Resume execution from suspended state
   * Used for HITL approval workflows and webhook resumption
   */
  async resumeExecution(suspendedState, resumeInput) {
    const ensemble = suspendedState.ensemble;
    const executionContext = suspendedState.executionContext;
    if (resumeInput) {
      executionContext.resumeInput = resumeInput;
    }
    let stateManager = null;
    if (suspendedState.stateSnapshot) {
      if (ensemble.state) {
        stateManager = new StateManager(ensemble.state);
      }
    }
    let scoringState = null;
    let ensembleScorer = null;
    const scoringExecutor = new ScoringExecutor();
    if (suspendedState.scoringSnapshot) {
      scoringState = suspendedState.scoringSnapshot;
      if (ensemble.scoring?.enabled) {
        ensembleScorer = new EnsembleScorer(ensemble.scoring);
      }
    }
    const metrics = {
      ensemble: ensemble.name,
      totalDuration: 0,
      agents: suspendedState.metrics.agents || [],
      cacheHits: suspendedState.metrics.cacheHits || 0
    };
    const startTime = suspendedState.metrics.startTime || Date.now();
    if (stateManager) {
      executionContext.state = stateManager.getState();
    }
    if (scoringState) {
      executionContext.scoring = scoringState;
    }
    const executionId = suspendedState.executionId || generateExecutionId();
    const observability = createObservabilityManager(
      this.observabilityConfig,
      {
        requestId: this.requestId,
        executionId,
        ensembleName: ensemble.name,
        environment: this.env.ENVIRONMENT
      },
      this.env.ANALYTICS
    );
    const componentRegistry = createComponentRegistry(this.env);
    const agentDiscoveryRegistry = createAgentRegistry(this.agentRegistry);
    const ensembleDiscoveryRegistry = createEnsembleRegistry(/* @__PURE__ */ new Map());
    const originalInput = executionContext.input ?? {};
    const memoryManager = this.createMemoryManager(ensemble, {
      ...originalInput,
      ...resumeInput
    });
    const flowContext = {
      ensemble,
      executionContext,
      metrics,
      stateManager,
      scoringState,
      ensembleScorer,
      scoringExecutor,
      startTime,
      observability,
      executionId,
      componentRegistry,
      agentRegistry: agentDiscoveryRegistry,
      ensembleRegistry: ensembleDiscoveryRegistry,
      memoryManager
    };
    const resumeFromStep = suspendedState.resumeFromStep;
    return await this.executeFlow(flowContext, resumeFromStep);
  }
}
class PluginRegistry {
  constructor() {
    this.operations = /* @__PURE__ */ new Map();
    this.metadata = /* @__PURE__ */ new Map();
    this.registerBuiltInOperations();
  }
  /**
   * Get singleton instance
   */
  static getInstance() {
    if (!PluginRegistry.instance) {
      PluginRegistry.instance = new PluginRegistry();
    }
    return PluginRegistry.instance;
  }
  /**
   * Register an operation handler
   *
   * This operation will be available in ALL contexts (ensembles, forms, etc.)
   * Plugins use this to add custom operations.
   *
   * @example
   * ```typescript
   * registry.register('plasmic:render', plasmicHandler, {
   *   name: 'plasmic:render',
   *   description: 'Render Plasmic component',
   *   version: '1.0.0',
   *   author: '@conductor/plasmic'
   * })
   * ```
   */
  register(name, handler, metadata) {
    this.operations.set(name, handler);
    if (metadata) {
      this.metadata.set(name, {
        ...metadata,
        contexts: metadata.contexts || ["all"]
      });
    }
  }
  /**
   * Get operation handler
   */
  get(name) {
    return this.operations.get(name);
  }
  /**
   * Get operation metadata
   */
  getMetadata(name) {
    return this.metadata.get(name);
  }
  /**
   * List all registered operations
   */
  list() {
    return Array.from(this.operations.keys());
  }
  /**
   * List operations by context type
   */
  listByContext(contextType) {
    return Array.from(this.metadata.entries()).filter(([_, meta]) => {
      if (!meta.contexts || meta.contexts.length === 0) return true;
      if (meta.contexts.includes("all")) return true;
      return meta.contexts.includes(contextType);
    }).map(([name]) => name);
  }
  /**
   * List operations by tag
   */
  listByTag(tag2) {
    return Array.from(this.metadata.entries()).filter(([_, meta]) => meta.tags?.includes(tag2)).map(([name]) => name);
  }
  /**
   * Check if operation exists
   */
  has(name) {
    return this.operations.has(name);
  }
  /**
   * Execute an operation
   */
  async execute(operation, context) {
    if (operation.handler) {
      return operation.handler(context);
    }
    const handler = this.get(operation.operation);
    if (!handler) {
      throw new Error(`[PluginRegistry] Unknown operation: ${operation.operation}`);
    }
    return handler.execute(operation, context);
  }
  /**
   * Register built-in operations
   *
   * These are the core operations provided by Conductor.
   * Plugins can add additional operations via register().
   */
  registerBuiltInOperations() {
    this.register(
      "fetch-data",
      {
        async execute(operation, _context) {
          const { source, collection, query } = operation.config;
          return {
            _mock: true,
            source,
            collection,
            query,
            data: []
          };
        }
      },
      {
        name: "fetch-data",
        description: "Fetch data from various sources (Payload, D1, KV, R2, APIs)",
        contexts: ["all"],
        tags: ["data", "fetch", "database"],
        inputs: {
          source: "string (payload, d1, kv, r2, api)",
          collection: "string (collection/table name)",
          query: "object (query parameters)"
        },
        outputs: {
          data: "array (fetched records)"
        }
      }
    );
    this.register(
      "transform-data",
      {
        async execute(operation, _context) {
          const { input, transform } = operation.config;
          return {
            _mock: true,
            input,
            transform,
            output: input
            // Mock: return input unchanged
          };
        }
      },
      {
        name: "transform-data",
        description: "Transform data using JSONata, JavaScript, or templates",
        contexts: ["all"],
        tags: ["data", "transform", "processing"],
        inputs: {
          input: "any (data to transform)",
          transform: "string (transformation expression)"
        },
        outputs: {
          output: "any (transformed data)"
        }
      }
    );
    this.register(
      "custom-code",
      {
        async execute(operation, _context) {
          const { code, input } = operation.config;
          return {
            _mock: true,
            code,
            input,
            output: null
          };
        }
      },
      {
        name: "custom-code",
        description: "Execute custom JavaScript/TypeScript code",
        contexts: ["all"],
        tags: ["code", "custom", "javascript"],
        inputs: {
          code: "string (JavaScript code)",
          input: "any (input data)"
        },
        outputs: {
          output: "any (code execution result)"
        }
      }
    );
    this.register(
      "agent",
      {
        async execute(operation, context) {
          const { agent: agentName, input } = operation.config;
          if (!agentName) {
            throw new Error("[agent] Missing required config: agent (name of agent to invoke)");
          }
          if (!context.agentRegistry) {
            throw new Error(
              "[agent] Agent registry not available in operation context. Make sure agents are registered before using the agent operation."
            );
          }
          const agentInstance = context.agentRegistry.get(agentName);
          if (!agentInstance) {
            const availableAgents = Array.from(context.agentRegistry.keys()).join(", ");
            throw new Error(
              `[agent] Agent "${agentName}" not found. Available agents: ${availableAgents || "none"}`
            );
          }
          try {
            const result = await agentInstance.execute({
              input: input || {},
              env: context.env,
              ctx: context.ctx
            });
            if (result.success === false) {
              throw new Error(result.error || "Agent execution failed");
            }
            return result.data || result.output || result;
          } catch (error) {
            throw new Error(
              `[agent] Failed to execute agent "${agentName}": ${error instanceof Error ? error.message : String(error)}`
            );
          }
        }
      },
      {
        name: "agent",
        description: "Invoke a registered Conductor agent (think, code, storage, etc.)",
        contexts: ["all"],
        tags: ["agent", "invoke", "conductor"],
        inputs: {
          agent: "string (name of agent to invoke)",
          input: "object (input data to pass to agent)"
        },
        outputs: {
          output: "any (agent execution result)"
        }
      }
    );
  }
  /**
   * Unregister an operation (for testing)
   */
  unregister(name) {
    const deleted = this.operations.delete(name);
    this.metadata.delete(name);
    return deleted;
  }
  /**
   * Clear all operations (for testing)
   */
  clear() {
    this.operations.clear();
    this.metadata.clear();
  }
  /**
   * Reset registry to initial state (for testing)
   */
  reset() {
    this.clear();
    this.registerBuiltInOperations();
  }
}
function getPluginRegistry() {
  return PluginRegistry.getInstance();
}
const OperationRegistry = PluginRegistry;
const getOperationRegistry = getPluginRegistry;
const logger$8 = createLogger({ serviceName: "trigger-registry" });
class TriggerRegistry {
  constructor() {
    this.handlers = /* @__PURE__ */ new Map();
    this.metadata = /* @__PURE__ */ new Map();
  }
  static {
    this.instance = null;
  }
  /**
   * Get singleton instance
   */
  static getInstance() {
    if (!TriggerRegistry.instance) {
      TriggerRegistry.instance = new TriggerRegistry();
    }
    return TriggerRegistry.instance;
  }
  /**
   * Reset registry (for testing)
   */
  reset() {
    this.handlers.clear();
    this.metadata.clear();
  }
  /**
   * Register a new trigger type
   */
  register(handler, metadata) {
    const { type } = metadata;
    if (this.handlers.has(type)) {
      logger$8.warn(`[TriggerRegistry] Overwriting existing trigger type: ${type}`);
    }
    this.handlers.set(type, handler);
    this.metadata.set(type, metadata);
    logger$8.info(`[TriggerRegistry] Registered trigger: ${type}`, {
      name: metadata.name,
      plugin: metadata.plugin
    });
  }
  /**
   * Get handler for a trigger type
   */
  getHandler(type) {
    return this.handlers.get(type);
  }
  /**
   * Get metadata for a trigger type
   */
  getMetadata(type) {
    return this.metadata.get(type);
  }
  /**
   * Check if a trigger type is registered
   */
  has(type) {
    return this.handlers.has(type);
  }
  /**
   * Get all registered trigger types
   */
  getAllTypes() {
    return Array.from(this.handlers.keys());
  }
  /**
   * Get all registered trigger metadata
   */
  getAllMetadata() {
    return Array.from(this.metadata.values());
  }
  /**
   * Register all triggers for an ensemble
   * Called during auto-discovery initialization
   */
  async registerEnsembleTriggers(app, ensemble, agents, env, ctx) {
    if (!ensemble.trigger || ensemble.trigger.length === 0) {
      return;
    }
    for (const trigger of ensemble.trigger) {
      const handler = this.getHandler(trigger.type);
      if (!handler) {
        logger$8.warn(`[TriggerRegistry] No handler found for trigger type: ${trigger.type}`, {
          ensemble: ensemble.name,
          availableTypes: this.getAllTypes()
        });
        continue;
      }
      try {
        await handler({
          app,
          ensemble,
          trigger,
          agents,
          env,
          ctx
        });
        logger$8.info(
          `[TriggerRegistry] Registered ${trigger.type} trigger for ensemble: ${ensemble.name}`
        );
      } catch (error) {
        logger$8.error(
          `[TriggerRegistry] Failed to register ${trigger.type} trigger for ${ensemble.name}`,
          error instanceof Error ? error : void 0
        );
      }
    }
  }
}
function getTriggerRegistry() {
  return TriggerRegistry.getInstance();
}
const logger$7 = createLogger({ serviceName: "http-middleware-registry" });
class HttpMiddlewareRegistry {
  constructor() {
    this.middleware = /* @__PURE__ */ new Map();
    this.metadata = /* @__PURE__ */ new Map();
  }
  static {
    this.instance = null;
  }
  /**
   * Get singleton instance
   */
  static getInstance() {
    if (!HttpMiddlewareRegistry.instance) {
      HttpMiddlewareRegistry.instance = new HttpMiddlewareRegistry();
    }
    return HttpMiddlewareRegistry.instance;
  }
  /**
   * Reset registry (for testing)
   */
  reset() {
    this.middleware.clear();
    this.metadata.clear();
  }
  /**
   * Register a middleware handler
   */
  register(name, handler, metadata) {
    if (this.middleware.has(name)) {
      logger$7.warn(`[HttpMiddlewareRegistry] Overwriting middleware: ${name}`);
    }
    this.middleware.set(name, handler);
    const fullMetadata = {
      name,
      description: metadata?.description || name,
      package: metadata?.package,
      configurable: metadata?.configurable || false
    };
    this.metadata.set(name, fullMetadata);
    logger$7.info(`[HttpMiddlewareRegistry] Registered middleware: ${name}`, {
      package: fullMetadata.package
    });
  }
  /**
   * Get middleware handler by name
   */
  get(name) {
    return this.middleware.get(name);
  }
  /**
   * Get metadata for a middleware
   */
  getMetadata(name) {
    return this.metadata.get(name);
  }
  /**
   * Check if middleware exists
   */
  has(name) {
    return this.middleware.has(name);
  }
  /**
   * List all registered middleware names
   */
  list() {
    return Array.from(this.middleware.keys());
  }
  /**
   * Get all middleware metadata
   */
  getAllMetadata() {
    return Array.from(this.metadata.values());
  }
  /**
   * Resolve middleware array from mixed string/function array
   * Supports both YAML (strings) and TypeScript (functions)
   */
  resolve(middlewareArray) {
    const resolved = [];
    for (const item of middlewareArray) {
      if (typeof item === "string") {
        const handler = this.get(item);
        if (!handler) {
          logger$7.warn(`[HttpMiddlewareRegistry] Middleware not found: ${item}`, {
            available: this.list()
          });
          continue;
        }
        resolved.push(handler);
      } else if (typeof item === "function") {
        resolved.push(item);
      } else {
        logger$7.warn(`[HttpMiddlewareRegistry] Invalid middleware type: ${typeof item}`, { item });
      }
    }
    return resolved;
  }
}
function getHttpMiddlewareRegistry() {
  return HttpMiddlewareRegistry.getInstance();
}
class QueueMember extends BaseAgent {
  constructor(config) {
    super(config);
    this.queueConfig = config.config || {};
    this.validateConfig();
  }
  /**
   * Validate agent configuration
   */
  validateConfig() {
    if (!this.queueConfig.queue) {
      throw new Error("Queue agent requires queue binding name");
    }
    if (this.queueConfig.retry) {
      if (this.queueConfig.retry.maxAttempts < 1) {
        throw new Error("Retry maxAttempts must be at least 1");
      }
    }
    if (this.queueConfig.dlq) {
      if (!this.queueConfig.dlq.queueName) {
        throw new Error("DLQ configuration requires queueName");
      }
      if (this.queueConfig.dlq.maxDeliveryAttempts < 1) {
        throw new Error("DLQ maxDeliveryAttempts must be at least 1");
      }
    }
  }
  /**
   * Execute queue operation
   */
  async run(context) {
    const input = context.input;
    const mode = input.mode || this.queueConfig.mode || "send";
    switch (mode) {
      case "send":
        return this.sendMessage(input, context);
      case "send-batch":
        return this.sendBatch(input, context);
      case "consume":
        return this.consumeMessages(input, context);
      default:
        throw new Error(`Unknown queue mode: ${mode}`);
    }
  }
  /**
   * Send single message
   */
  async sendMessage(input, context) {
    if (!input.message) {
      throw new Error("Send mode requires message in input");
    }
    const queue = this.getQueue(context);
    const message2 = this.prepareMessage(input.message);
    try {
      await queue.send(message2.body, {
        contentType: this.queueConfig.contentType || "json",
        delaySeconds: message2.delaySeconds
      });
      return {
        mode: "send",
        success: true,
        messageId: message2.id || this.generateMessageId(),
        messageCount: 1
      };
    } catch (error) {
      return {
        mode: "send",
        success: false,
        error: error.message
      };
    }
  }
  /**
   * Send batch of messages
   */
  async sendBatch(input, context) {
    const messages = input.messages || input.batchOptions?.messages;
    if (!messages || messages.length === 0) {
      throw new Error("Send-batch mode requires messages array");
    }
    const queue = this.getQueue(context);
    const atomic = input.batchOptions?.atomic || false;
    const messageIds = [];
    const failedMessages = [];
    for (const msg of messages) {
      try {
        const preparedMsg = this.prepareMessage(msg);
        await queue.send(preparedMsg.body, {
          contentType: this.queueConfig.contentType || "json",
          delaySeconds: preparedMsg.delaySeconds
        });
        const msgId = preparedMsg.id || this.generateMessageId();
        messageIds.push(msgId);
      } catch (error) {
        failedMessages.push({
          message: msg,
          error: error.message
        });
        if (atomic) {
          break;
        }
      }
    }
    const success = atomic ? failedMessages.length === 0 : messageIds.length > 0;
    return {
      mode: "send-batch",
      success,
      messageIds,
      messageCount: messageIds.length,
      failedMessages: failedMessages.length > 0 ? failedMessages : void 0,
      error: !success ? "Some messages failed to send" : void 0
    };
  }
  /**
   * Consume messages (called by Cloudflare Queue consumer)
   */
  async consumeMessages(input, context) {
    const consumerConfig = this.queueConfig.consumer;
    if (!consumerConfig) {
      throw new Error("Consume mode requires consumer configuration");
    }
    const results = [];
    return {
      mode: "consume",
      success: true,
      consumerResults: results
    };
  }
  /**
   * Process a single message with retry logic
   */
  async processMessage(message2, context) {
    const maxRetries = this.queueConfig.retry?.maxAttempts || 3;
    const exponentialBackoff = this.queueConfig.retry?.exponentialBackoff !== false;
    let lastError = null;
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        const output = await this.executeHandler(message2, context);
        return {
          messageId: message2.id,
          success: true,
          output,
          retryCount: attempt
        };
      } catch (error) {
        lastError = error;
        if (attempt < maxRetries && exponentialBackoff) {
          const delay = this.calculateBackoff(attempt);
          await this.sleep(delay);
        }
      }
    }
    const shouldSendToDLQ = this.queueConfig.dlq && message2.attempts >= this.queueConfig.dlq.maxDeliveryAttempts;
    if (shouldSendToDLQ) {
      await this.sendToDLQ(message2, context);
    }
    return {
      messageId: message2.id,
      success: false,
      error: lastError?.message || "Unknown error",
      retryCount: maxRetries,
      sentToDLQ: shouldSendToDLQ
    };
  }
  /**
   * Execute handler ensemble for message
   */
  async executeHandler(message2, context) {
    return message2.body;
  }
  /**
   * Send message to dead letter queue
   */
  async sendToDLQ(message2, context) {
    if (!this.queueConfig.dlq) return;
    const dlqName = this.queueConfig.dlq.queueName;
    const dlqBinding = context.env[dlqName];
    if (dlqBinding && typeof dlqBinding === "object" && "send" in dlqBinding) {
      const queue = dlqBinding;
      await queue.send({
        originalMessage: message2,
        failedAt: (/* @__PURE__ */ new Date()).toISOString(),
        attempts: message2.attempts
      });
    }
  }
  /**
   * Calculate exponential backoff delay
   */
  calculateBackoff(attempt) {
    const initialDelay = this.queueConfig.retry?.initialDelay || 1e3;
    const maxDelay = this.queueConfig.retry?.maxDelay || 6e4;
    const multiplier = this.queueConfig.retry?.backoffMultiplier || 2;
    const jitter = this.queueConfig.retry?.jitter || 0.1;
    let delay = initialDelay * Math.pow(multiplier, attempt);
    delay = Math.min(delay, maxDelay);
    const jitterAmount = delay * jitter * (Math.random() * 2 - 1);
    delay += jitterAmount;
    return Math.max(0, Math.floor(delay));
  }
  /**
   * Sleep utility
   */
  sleep(ms) {
    return new Promise((resolve2) => setTimeout(resolve2, ms));
  }
  /**
   * Get queue binding from environment
   */
  getQueue(context) {
    const queueName = this.queueConfig.queue;
    const queue = context.env[queueName];
    if (!queue) {
      throw new Error(`Queue binding "${queueName}" not found. Add it to wrangler.toml`);
    }
    return queue;
  }
  /**
   * Prepare message for sending
   */
  prepareMessage(message2) {
    return {
      id: message2.id || this.generateMessageId(),
      body: message2.body,
      metadata: message2.metadata,
      delaySeconds: message2.delaySeconds,
      headers: message2.headers
    };
  }
  /**
   * Generate unique message ID
   */
  generateMessageId() {
    return `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
}
const logger$6 = createLogger({ serviceName: "agent-loader" });
class AgentLoader {
  constructor(config) {
    this.config = {
      membersDir: config.membersDir || "./agents",
      ensemblesDir: config.ensemblesDir || "./ensembles",
      env: config.env,
      ctx: config.ctx
    };
    this.loadedMembers = /* @__PURE__ */ new Map();
  }
  /**
   * Auto-discover and register agents from virtual module
   *
   * This method is designed to work with the Vite plugin system that generates
   * a virtual module containing all agent definitions at build time.
   *
   * @param discoveredAgents - Array of agent definitions from virtual:conductor-agents
   *
   * @example
   * ```typescript
   * import { agents as discoveredAgents } from 'virtual:conductor-agents';
   *
   * const loader = new MemberLoader({ env, ctx });
   * await loader.autoDiscover(discoveredAgents);
   * ```
   */
  async autoDiscover(discoveredAgents) {
    for (const agentDef of discoveredAgents) {
      try {
        const config = Parser$1.parseAgent(agentDef.config);
        let implementation;
        if (agentDef.handler) {
          const handlerModule = await agentDef.handler();
          implementation = handlerModule?.default || handlerModule;
        }
        this.registerAgent(config, implementation);
        logger$6.debug(`Auto-discovered agent: ${agentDef.name}`, { agentName: agentDef.name });
      } catch (error) {
        logger$6.error(`Failed to load agent "${agentDef.name}"`, error instanceof Error ? error : void 0, {
          agentName: agentDef.name
        });
      }
    }
    logger$6.info(`Auto-discovery complete: ${this.loadedMembers.size} agents loaded`, {
      agentCount: this.loadedMembers.size
    });
  }
  /**
   * Register a agent manually
   *
   * @example
   * ```typescript
   * import greetConfig from './agents/greet/agent.yaml.js';
   * import greetFunction from './agents/greet/index.js';
   *
   * loader.registerAgent(greetConfig, greetFunction);
   * ```
   */
  registerAgent(agentConfig, implementation) {
    const config = typeof agentConfig === "string" ? Parser$1.parseAgent(agentConfig) : agentConfig;
    const instance = this.createMemberInstance(config, implementation);
    this.loadedMembers.set(config.name, {
      config,
      instance
    });
    return instance;
  }
  /**
   * Load a agent from Edgit by version reference
   *
   * This enables loading versioned agent configs at runtime for A/B testing,
   * environment-specific configs, and config-only deployments.
   *
   * @example
   * ```typescript
   * // Load specific version
   * await loader.loadMemberFromEdgit('analyze-company@v1.0.0');
   *
   * // Load production deployment
   * await loader.loadMemberFromEdgit('analyze-company@production');
   * ```
   */
  async loadMemberFromEdgit(memberRef) {
    const { name, version } = Parser$1.parseAgentReference(memberRef);
    if (!version) {
      throw new Error(`Agent reference must include version: ${memberRef}`);
    }
    const versionedKey = `${name}@${version}`;
    if (this.loadedMembers.has(versionedKey)) {
      return this.loadedMembers.get(versionedKey).instance;
    }
    throw new Error(
      `Cannot load versioned agent from Edgit: ${memberRef}. Edgit integration not yet available. Use loader.registerAgent() for now.`
    );
  }
  /**
   * Create a agent instance based on type
   */
  createMemberInstance(config, implementation) {
    switch (config.operation) {
      case "code":
        if (!implementation) {
          throw new Error(`Code agent "${config.name}" requires an implementation function`);
        }
        return new FunctionAgent(config, implementation);
      case "think":
        return new ThinkAgent(config);
      case "storage":
        return new DataAgent(config);
      case "data":
        return new DataAgent(config);
      case "http":
        return new APIAgent(config);
      case "email":
        return new EmailAgent(config);
      case "sms":
        return new SmsMember(config);
      case "form":
        return new FormAgent(config);
      case "html":
        return new HtmlMember(config);
      case "pdf":
        return new PdfMember(config);
      case "queue":
        return new QueueMember(config);
      default:
        throw new Error(
          `Unknown agent operation type: "${config.operation}". If using tools, validate, or autorag, these are now template-based agents. Use 'operation: code' with a handler instead. See: catalog/cloud/cloudflare/templates/agents/system/`
        );
    }
  }
  /**
   * Get a loaded agent by name
   */
  getAgent(name) {
    return this.loadedMembers.get(name)?.instance;
  }
  /**
   * Get agent config by name
   */
  getAgentConfig(name) {
    return this.loadedMembers.get(name)?.config;
  }
  /**
   * Get all loaded agents
   */
  getAllMembers() {
    return Array.from(this.loadedMembers.values()).map((m) => m.instance);
  }
  /**
   * Get all agent names
   */
  getMemberNames() {
    return Array.from(this.loadedMembers.keys());
  }
  /**
   * Check if a agent is loaded
   */
  hasMember(name) {
    return this.loadedMembers.has(name);
  }
  /**
   * Clear all loaded agents
   */
  clear() {
    this.loadedMembers.clear();
  }
}
function createLoader(config) {
  return new AgentLoader(config);
}
const MemberLoader = AgentLoader;
const logger$5 = createLogger({ serviceName: "ensemble-loader" });
class EnsembleLoader {
  constructor(config) {
    this.config = {
      ensemblesDir: config.ensemblesDir || "./ensembles",
      env: config.env,
      ctx: config.ctx
    };
    this.loadedEnsembles = /* @__PURE__ */ new Map();
  }
  /**
   * Auto-discover and register ensembles from virtual module
   *
   * This method is designed to work with the Vite plugin system that generates
   * a virtual module containing all ensemble definitions at build time.
   *
   * Supports both YAML configs and TypeScript Ensemble instances.
   *
   * @param discoveredEnsembles - Array of ensemble definitions from virtual:conductor-ensembles
   *
   * @example
   * ```typescript
   * // YAML ensembles
   * import { ensembles as discoveredEnsembles } from 'virtual:conductor-ensembles';
   *
   * // TypeScript ensembles
   * import dataPipeline from './ensembles/data-pipeline.ts';
   *
   * const loader = new EnsembleLoader({ env, ctx });
   * await loader.autoDiscover([
   *   ...discoveredEnsembles,
   *   { name: 'data-pipeline', instance: dataPipeline }
   * ]);
   * ```
   */
  async autoDiscover(discoveredEnsembles) {
    for (const ensembleDef of discoveredEnsembles) {
      try {
        if (ensembleDef.instance && isEnsemble(ensembleDef.instance)) {
          this.registerEnsembleInstance(ensembleDef.instance);
          logger$5.debug(`Auto-discovered TypeScript ensemble: ${ensembleDef.name}`);
        } else if (ensembleDef.config) {
          const config = Parser$1.parseEnsemble(ensembleDef.config);
          this.registerEnsemble(config);
          logger$5.debug(`Auto-discovered YAML ensemble: ${ensembleDef.name}`);
        } else {
          logger$5.warn(`Skipping ensemble "${ensembleDef.name}": no config or instance`);
        }
      } catch (error) {
        logger$5.error(`Failed to load ensemble "${ensembleDef.name}"`, error);
      }
    }
    logger$5.info(`Auto-discovery complete: ${this.loadedEnsembles.size} ensembles loaded`);
  }
  /**
   * Register an ensemble from a config object or YAML string
   *
   * @example
   * ```typescript
   * import blogWorkflowConfig from './ensembles/blog-workflow.yaml.js';
   *
   * loader.registerEnsemble(blogWorkflowConfig);
   * ```
   */
  registerEnsemble(ensembleConfig) {
    const config = typeof ensembleConfig === "string" ? Parser$1.parseEnsemble(ensembleConfig) : ensembleConfig;
    const instance = ensembleFromConfig(
      config
    );
    if (config.agents && config.agents.length > 0 && this.config.agentLoader) {
      for (const agentDef of config.agents) {
        try {
          const agentConfig = agentDef;
          this.config.agentLoader.registerAgent(agentConfig);
          logger$5.debug(
            `Registered inline agent "${agentConfig.name}" from ensemble "${config.name}"`
          );
        } catch (error) {
          logger$5.error(
            `Failed to register inline agent "${agentDef.name}"`,
            error
          );
        }
      }
    }
    this.loadedEnsembles.set(config.name, {
      config,
      instance,
      source: "yaml"
    });
    return instance;
  }
  /**
   * Register a TypeScript Ensemble instance directly
   *
   * Use this when you have an Ensemble created via createEnsemble() in TypeScript.
   *
   * @example
   * ```typescript
   * import { createEnsemble, step, parallel } from '@ensemble-edge/conductor';
   *
   * const myPipeline = createEnsemble({
   *   name: 'my-pipeline',
   *   steps: [
   *     parallel([step('fetch-a'), step('fetch-b')]),
   *     step('merge')
   *   ]
   * });
   *
   * loader.registerEnsembleInstance(myPipeline);
   * ```
   */
  registerEnsembleInstance(ensemble) {
    if (!isEnsemble(ensemble)) {
      throw new Error("registerEnsembleInstance expects an Ensemble instance");
    }
    if (ensemble.agents && ensemble.agents.length > 0 && this.config.agentLoader) {
      for (const agentDef of ensemble.agents) {
        try {
          const agentConfig = agentDef;
          this.config.agentLoader.registerAgent(agentConfig);
          logger$5.debug(
            `Registered inline agent "${agentConfig.name}" from TypeScript ensemble "${ensemble.name}"`
          );
        } catch (error) {
          logger$5.error(`Failed to register inline agent "${agentDef.name}"`, error);
        }
      }
    }
    this.loadedEnsembles.set(ensemble.name, {
      config: ensemble.toConfig(),
      instance: ensemble,
      source: "typescript"
    });
    return ensemble;
  }
  /**
   * Get an ensemble config by name
   * @deprecated Use getEnsembleInstance() to get the Ensemble instance directly
   */
  getEnsemble(name) {
    return this.loadedEnsembles.get(name)?.config;
  }
  /**
   * Get an Ensemble instance by name
   *
   * This is the preferred method - returns the canonical Ensemble object
   * that can be directly executed.
   */
  getEnsembleInstance(name) {
    return this.loadedEnsembles.get(name)?.instance;
  }
  /**
   * Get full loaded ensemble data (config, instance, and source)
   */
  getLoadedEnsemble(name) {
    return this.loadedEnsembles.get(name);
  }
  /**
   * Get all loaded ensemble configs
   * @deprecated Use getAllEnsembleInstances() to get Ensemble instances directly
   */
  getAllEnsembles() {
    return Array.from(this.loadedEnsembles.values()).map((e) => e.config);
  }
  /**
   * Get all loaded Ensemble instances
   *
   * This is the preferred method - returns canonical Ensemble objects
   * that can be directly executed.
   */
  getAllEnsembleInstances() {
    return Array.from(this.loadedEnsembles.values()).map((e) => e.instance);
  }
  /**
   * Get all loaded ensemble data
   */
  getAllLoadedEnsembles() {
    return Array.from(this.loadedEnsembles.values());
  }
  /**
   * Get all ensemble names
   */
  getEnsembleNames() {
    return Array.from(this.loadedEnsembles.keys());
  }
  /**
   * Check if an ensemble is loaded
   */
  hasEnsemble(name) {
    return this.loadedEnsembles.has(name);
  }
  /**
   * Clear all loaded ensembles
   */
  clear() {
    this.loadedEnsembles.clear();
  }
}
function createEnsembleLoader(config) {
  return new EnsembleLoader(config);
}
const encoder = new TextEncoder();
const decoder = new TextDecoder();
function concat(...buffers) {
  const size2 = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size2);
  let i = 0;
  for (const buffer of buffers) {
    buf.set(buffer, i);
    i += buffer.length;
  }
  return buf;
}
function encode(string2) {
  const bytes = new Uint8Array(string2.length);
  for (let i = 0; i < string2.length; i++) {
    const code = string2.charCodeAt(i);
    if (code > 127) {
      throw new TypeError("non-ASCII string encountered in encode()");
    }
    bytes[i] = code;
  }
  return bytes;
}
function decodeBase64(encoded) {
  if (Uint8Array.fromBase64) {
    return Uint8Array.fromBase64(encoded);
  }
  const binary2 = atob(encoded);
  const bytes = new Uint8Array(binary2.length);
  for (let i = 0; i < binary2.length; i++) {
    bytes[i] = binary2.charCodeAt(i);
  }
  return bytes;
}
function decode(input) {
  if (Uint8Array.fromBase64) {
    return Uint8Array.fromBase64(typeof input === "string" ? input : decoder.decode(input), {
      alphabet: "base64url"
    });
  }
  let encoded = input;
  if (encoded instanceof Uint8Array) {
    encoded = decoder.decode(encoded);
  }
  encoded = encoded.replace(/-/g, "+").replace(/_/g, "/");
  try {
    return decodeBase64(encoded);
  } catch {
    throw new TypeError("The input to be decoded is not correctly encoded.");
  }
}
class JOSEError extends Error {
  static code = "ERR_JOSE_GENERIC";
  code = "ERR_JOSE_GENERIC";
  constructor(message2, options) {
    super(message2, options);
    this.name = this.constructor.name;
    Error.captureStackTrace?.(this, this.constructor);
  }
}
class JWTClaimValidationFailed extends JOSEError {
  static code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
  code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
  claim;
  reason;
  payload;
  constructor(message2, payload, claim = "unspecified", reason = "unspecified") {
    super(message2, { cause: { claim, reason, payload } });
    this.claim = claim;
    this.reason = reason;
    this.payload = payload;
  }
}
class JWTExpired extends JOSEError {
  static code = "ERR_JWT_EXPIRED";
  code = "ERR_JWT_EXPIRED";
  claim;
  reason;
  payload;
  constructor(message2, payload, claim = "unspecified", reason = "unspecified") {
    super(message2, { cause: { claim, reason, payload } });
    this.claim = claim;
    this.reason = reason;
    this.payload = payload;
  }
}
class JOSEAlgNotAllowed extends JOSEError {
  static code = "ERR_JOSE_ALG_NOT_ALLOWED";
  code = "ERR_JOSE_ALG_NOT_ALLOWED";
}
class JOSENotSupported extends JOSEError {
  static code = "ERR_JOSE_NOT_SUPPORTED";
  code = "ERR_JOSE_NOT_SUPPORTED";
}
class JWSInvalid extends JOSEError {
  static code = "ERR_JWS_INVALID";
  code = "ERR_JWS_INVALID";
}
class JWTInvalid extends JOSEError {
  static code = "ERR_JWT_INVALID";
  code = "ERR_JWT_INVALID";
}
class JWKSInvalid extends JOSEError {
  static code = "ERR_JWKS_INVALID";
  code = "ERR_JWKS_INVALID";
}
class JWKSNoMatchingKey extends JOSEError {
  static code = "ERR_JWKS_NO_MATCHING_KEY";
  code = "ERR_JWKS_NO_MATCHING_KEY";
  constructor(message2 = "no applicable key found in the JSON Web Key Set", options) {
    super(message2, options);
  }
}
class JWKSMultipleMatchingKeys extends JOSEError {
  [Symbol.asyncIterator];
  static code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
  code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
  constructor(message2 = "multiple matching keys found in the JSON Web Key Set", options) {
    super(message2, options);
  }
}
class JWKSTimeout extends JOSEError {
  static code = "ERR_JWKS_TIMEOUT";
  code = "ERR_JWKS_TIMEOUT";
  constructor(message2 = "request timed out", options) {
    super(message2, options);
  }
}
class JWSSignatureVerificationFailed extends JOSEError {
  static code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
  code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
  constructor(message2 = "signature verification failed", options) {
    super(message2, options);
  }
}
const unusable = (name, prop = "algorithm.name") => new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
const isAlgorithm = (algorithm, name) => algorithm.name === name;
function getHashLength(hash) {
  return parseInt(hash.name.slice(4), 10);
}
function getNamedCurve(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
function checkUsage(key, usage) {
  if (!key.usages.includes(usage)) {
    throw new TypeError(`CryptoKey does not support this operation, its usages must include ${usage}.`);
  }
}
function checkSigCryptoKey(key, alg, usage) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "Ed25519":
    case "EdDSA": {
      if (!isAlgorithm(key.algorithm, "Ed25519"))
        throw unusable("Ed25519");
      break;
    }
    case "ML-DSA-44":
    case "ML-DSA-65":
    case "ML-DSA-87": {
      if (!isAlgorithm(key.algorithm, alg))
        throw unusable(alg);
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected = getNamedCurve(alg);
      const actual = key.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usage);
}
function message(msg, actual, ...types) {
  types = types.filter(Boolean);
  if (types.length > 2) {
    const last2 = types.pop();
    msg += `one of type ${types.join(", ")}, or ${last2}.`;
  } else if (types.length === 2) {
    msg += `one of type ${types[0]} or ${types[1]}.`;
  } else {
    msg += `of type ${types[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor?.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
}
const invalidKeyInput = (actual, ...types) => message("Key must be ", actual, ...types);
const withAlg = (alg, actual, ...types) => message(`Key for the ${alg} algorithm must be `, actual, ...types);
const isCryptoKey = (key) => {
  if (key?.[Symbol.toStringTag] === "CryptoKey")
    return true;
  try {
    return key instanceof CryptoKey;
  } catch {
    return false;
  }
};
const isKeyObject = (key) => key?.[Symbol.toStringTag] === "KeyObject";
const isKeyLike = (key) => isCryptoKey(key) || isKeyObject(key);
function isDisjoint(...headers) {
  const sources = headers.filter(Boolean);
  if (sources.length === 0 || sources.length === 1) {
    return true;
  }
  let acc;
  for (const header of sources) {
    const parameters = Object.keys(header);
    if (!acc || acc.size === 0) {
      acc = new Set(parameters);
      continue;
    }
    for (const parameter of parameters) {
      if (acc.has(parameter)) {
        return false;
      }
      acc.add(parameter);
    }
  }
  return true;
}
const isObjectLike = (value) => typeof value === "object" && value !== null;
function isObject(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}
function checkKeyLength(alg, key) {
  if (alg.startsWith("RS") || alg.startsWith("PS")) {
    const { modulusLength } = key.algorithm;
    if (typeof modulusLength !== "number" || modulusLength < 2048) {
      throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
    }
  }
}
function subtleMapping(jwk) {
  let algorithm;
  let keyUsages;
  switch (jwk.kty) {
    case "AKP": {
      switch (jwk.alg) {
        case "ML-DSA-44":
        case "ML-DSA-65":
        case "ML-DSA-87":
          algorithm = { name: jwk.alg };
          keyUsages = jwk.priv ? ["sign"] : ["verify"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "RSA": {
      switch (jwk.alg) {
        case "PS256":
        case "PS384":
        case "PS512":
          algorithm = { name: "RSA-PSS", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RS256":
        case "RS384":
        case "RS512":
          algorithm = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          algorithm = {
            name: "RSA-OAEP",
            hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`
          };
          keyUsages = jwk.d ? ["decrypt", "unwrapKey"] : ["encrypt", "wrapKey"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "EC": {
      switch (jwk.alg) {
        case "ES256":
          algorithm = { name: "ECDSA", namedCurve: "P-256" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES384":
          algorithm = { name: "ECDSA", namedCurve: "P-384" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES512":
          algorithm = { name: "ECDSA", namedCurve: "P-521" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: "ECDH", namedCurve: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "OKP": {
      switch (jwk.alg) {
        case "Ed25519":
        case "EdDSA":
          algorithm = { name: "Ed25519" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
  }
  return { algorithm, keyUsages };
}
async function jwkToKey(jwk) {
  if (!jwk.alg) {
    throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
  }
  const { algorithm, keyUsages } = subtleMapping(jwk);
  const keyData = { ...jwk };
  if (keyData.kty !== "AKP") {
    delete keyData.alg;
  }
  delete keyData.use;
  return crypto.subtle.importKey("jwk", keyData, algorithm, jwk.ext ?? (jwk.d || jwk.priv ? false : true), jwk.key_ops ?? keyUsages);
}
async function importJWK(jwk, alg, options) {
  if (!isObject(jwk)) {
    throw new TypeError("JWK must be an object");
  }
  let ext;
  alg ??= jwk.alg;
  ext ??= jwk.ext;
  switch (jwk.kty) {
    case "oct":
      if (typeof jwk.k !== "string" || !jwk.k) {
        throw new TypeError('missing "k" (Key Value) Parameter value');
      }
      return decode(jwk.k);
    case "RSA":
      if ("oth" in jwk && jwk.oth !== void 0) {
        throw new JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
      }
      return jwkToKey({ ...jwk, alg, ext });
    case "AKP": {
      if (typeof jwk.alg !== "string" || !jwk.alg) {
        throw new TypeError('missing "alg" (Algorithm) Parameter value');
      }
      if (alg !== void 0 && alg !== jwk.alg) {
        throw new TypeError("JWK alg and alg option value mismatch");
      }
      return jwkToKey({ ...jwk, ext });
    }
    case "EC":
    case "OKP":
      return jwkToKey({ ...jwk, alg, ext });
    default:
      throw new JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
  }
}
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== void 0 && protectedHeader?.crit === void 0) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === void 0) {
    return /* @__PURE__ */ new Set();
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== void 0) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    }
    if (recognized.get(parameter) && protectedHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
}
function validateAlgorithms(option, algorithms) {
  if (algorithms !== void 0 && (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== "string"))) {
    throw new TypeError(`"${option}" option must be an array of strings`);
  }
  if (!algorithms) {
    return void 0;
  }
  return new Set(algorithms);
}
const isJWK = (key) => isObject(key) && typeof key.kty === "string";
const isPrivateJWK = (key) => key.kty !== "oct" && (key.kty === "AKP" && typeof key.priv === "string" || typeof key.d === "string");
const isPublicJWK = (key) => key.kty !== "oct" && key.d === void 0 && key.priv === void 0;
const isSecretJWK = (key) => key.kty === "oct" && typeof key.k === "string";
let cache;
const handleJWK = async (key, jwk, alg, freeze = false) => {
  cache ||= /* @__PURE__ */ new WeakMap();
  let cached = cache.get(key);
  if (cached?.[alg]) {
    return cached[alg];
  }
  const cryptoKey = await jwkToKey({ ...jwk, alg });
  if (freeze)
    Object.freeze(key);
  if (!cached) {
    cache.set(key, { [alg]: cryptoKey });
  } else {
    cached[alg] = cryptoKey;
  }
  return cryptoKey;
};
const handleKeyObject = (keyObject, alg) => {
  cache ||= /* @__PURE__ */ new WeakMap();
  let cached = cache.get(keyObject);
  if (cached?.[alg]) {
    return cached[alg];
  }
  const isPublic = keyObject.type === "public";
  const extractable = isPublic ? true : false;
  let cryptoKey;
  if (keyObject.asymmetricKeyType === "x25519") {
    switch (alg) {
      case "ECDH-ES":
      case "ECDH-ES+A128KW":
      case "ECDH-ES+A192KW":
      case "ECDH-ES+A256KW":
        break;
      default:
        throw new TypeError("given KeyObject instance cannot be used for this algorithm");
    }
    cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, isPublic ? [] : ["deriveBits"]);
  }
  if (keyObject.asymmetricKeyType === "ed25519") {
    if (alg !== "EdDSA" && alg !== "Ed25519") {
      throw new TypeError("given KeyObject instance cannot be used for this algorithm");
    }
    cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, [
      isPublic ? "verify" : "sign"
    ]);
  }
  switch (keyObject.asymmetricKeyType) {
    case "ml-dsa-44":
    case "ml-dsa-65":
    case "ml-dsa-87": {
      if (alg !== keyObject.asymmetricKeyType.toUpperCase()) {
        throw new TypeError("given KeyObject instance cannot be used for this algorithm");
      }
      cryptoKey = keyObject.toCryptoKey(keyObject.asymmetricKeyType, extractable, [
        isPublic ? "verify" : "sign"
      ]);
    }
  }
  if (keyObject.asymmetricKeyType === "rsa") {
    let hash;
    switch (alg) {
      case "RSA-OAEP":
        hash = "SHA-1";
        break;
      case "RS256":
      case "PS256":
      case "RSA-OAEP-256":
        hash = "SHA-256";
        break;
      case "RS384":
      case "PS384":
      case "RSA-OAEP-384":
        hash = "SHA-384";
        break;
      case "RS512":
      case "PS512":
      case "RSA-OAEP-512":
        hash = "SHA-512";
        break;
      default:
        throw new TypeError("given KeyObject instance cannot be used for this algorithm");
    }
    if (alg.startsWith("RSA-OAEP")) {
      return keyObject.toCryptoKey({
        name: "RSA-OAEP",
        hash
      }, extractable, isPublic ? ["encrypt"] : ["decrypt"]);
    }
    cryptoKey = keyObject.toCryptoKey({
      name: alg.startsWith("PS") ? "RSA-PSS" : "RSASSA-PKCS1-v1_5",
      hash
    }, extractable, [isPublic ? "verify" : "sign"]);
  }
  if (keyObject.asymmetricKeyType === "ec") {
    const nist = /* @__PURE__ */ new Map([
      ["prime256v1", "P-256"],
      ["secp384r1", "P-384"],
      ["secp521r1", "P-521"]
    ]);
    const namedCurve = nist.get(keyObject.asymmetricKeyDetails?.namedCurve);
    if (!namedCurve) {
      throw new TypeError("given KeyObject instance cannot be used for this algorithm");
    }
    if (alg === "ES256" && namedCurve === "P-256") {
      cryptoKey = keyObject.toCryptoKey({
        name: "ECDSA",
        namedCurve
      }, extractable, [isPublic ? "verify" : "sign"]);
    }
    if (alg === "ES384" && namedCurve === "P-384") {
      cryptoKey = keyObject.toCryptoKey({
        name: "ECDSA",
        namedCurve
      }, extractable, [isPublic ? "verify" : "sign"]);
    }
    if (alg === "ES512" && namedCurve === "P-521") {
      cryptoKey = keyObject.toCryptoKey({
        name: "ECDSA",
        namedCurve
      }, extractable, [isPublic ? "verify" : "sign"]);
    }
    if (alg.startsWith("ECDH-ES")) {
      cryptoKey = keyObject.toCryptoKey({
        name: "ECDH",
        namedCurve
      }, extractable, isPublic ? [] : ["deriveBits"]);
    }
  }
  if (!cryptoKey) {
    throw new TypeError("given KeyObject instance cannot be used for this algorithm");
  }
  if (!cached) {
    cache.set(keyObject, { [alg]: cryptoKey });
  } else {
    cached[alg] = cryptoKey;
  }
  return cryptoKey;
};
async function normalizeKey(key, alg) {
  if (key instanceof Uint8Array) {
    return key;
  }
  if (isCryptoKey(key)) {
    return key;
  }
  if (isKeyObject(key)) {
    if (key.type === "secret") {
      return key.export();
    }
    if ("toCryptoKey" in key && typeof key.toCryptoKey === "function") {
      try {
        return handleKeyObject(key, alg);
      } catch (err) {
        if (err instanceof TypeError) {
          throw err;
        }
      }
    }
    let jwk = key.export({ format: "jwk" });
    return handleJWK(key, jwk, alg);
  }
  if (isJWK(key)) {
    if (key.k) {
      return decode(key.k);
    }
    return handleJWK(key, key, alg, true);
  }
  throw new Error("unreachable");
}
const tag = (key) => key?.[Symbol.toStringTag];
const jwkMatchesOp = (alg, key, usage) => {
  if (key.use !== void 0) {
    let expected;
    switch (usage) {
      case "sign":
      case "verify":
        expected = "sig";
        break;
      case "encrypt":
      case "decrypt":
        expected = "enc";
        break;
    }
    if (key.use !== expected) {
      throw new TypeError(`Invalid key for this operation, its "use" must be "${expected}" when present`);
    }
  }
  if (key.alg !== void 0 && key.alg !== alg) {
    throw new TypeError(`Invalid key for this operation, its "alg" must be "${alg}" when present`);
  }
  if (Array.isArray(key.key_ops)) {
    let expectedKeyOp;
    switch (true) {
      case usage === "verify":
      case alg === "dir":
      case alg.includes("CBC-HS"):
        expectedKeyOp = usage;
        break;
      case alg.startsWith("PBES2"):
        expectedKeyOp = "deriveBits";
        break;
      case /^A\d{3}(?:GCM)?(?:KW)?$/.test(alg):
        if (!alg.includes("GCM") && alg.endsWith("KW")) {
          expectedKeyOp = "unwrapKey";
        } else {
          expectedKeyOp = usage;
        }
        break;
      case usage === "encrypt":
        expectedKeyOp = "wrapKey";
        break;
      case usage === "decrypt":
        expectedKeyOp = alg.startsWith("RSA") ? "unwrapKey" : "deriveBits";
        break;
    }
    if (expectedKeyOp && key.key_ops?.includes?.(expectedKeyOp) === false) {
      throw new TypeError(`Invalid key for this operation, its "key_ops" must include "${expectedKeyOp}" when present`);
    }
  }
  return true;
};
const symmetricTypeCheck = (alg, key, usage) => {
  if (key instanceof Uint8Array)
    return;
  if (isJWK(key)) {
    if (isSecretJWK(key) && jwkMatchesOp(alg, key, usage))
      return;
    throw new TypeError(`JSON Web Key for symmetric algorithms must have JWK "kty" (Key Type) equal to "oct" and the JWK "k" (Key Value) present`);
  }
  if (!isKeyLike(key)) {
    throw new TypeError(withAlg(alg, key, "CryptoKey", "KeyObject", "JSON Web Key", "Uint8Array"));
  }
  if (key.type !== "secret") {
    throw new TypeError(`${tag(key)} instances for symmetric algorithms must be of type "secret"`);
  }
};
const asymmetricTypeCheck = (alg, key, usage) => {
  if (isJWK(key)) {
    switch (usage) {
      case "decrypt":
      case "sign":
        if (isPrivateJWK(key) && jwkMatchesOp(alg, key, usage))
          return;
        throw new TypeError(`JSON Web Key for this operation be a private JWK`);
      case "encrypt":
      case "verify":
        if (isPublicJWK(key) && jwkMatchesOp(alg, key, usage))
          return;
        throw new TypeError(`JSON Web Key for this operation be a public JWK`);
    }
  }
  if (!isKeyLike(key)) {
    throw new TypeError(withAlg(alg, key, "CryptoKey", "KeyObject", "JSON Web Key"));
  }
  if (key.type === "secret") {
    throw new TypeError(`${tag(key)} instances for asymmetric algorithms must not be of type "secret"`);
  }
  if (key.type === "public") {
    switch (usage) {
      case "sign":
        throw new TypeError(`${tag(key)} instances for asymmetric algorithm signing must be of type "private"`);
      case "decrypt":
        throw new TypeError(`${tag(key)} instances for asymmetric algorithm decryption must be of type "private"`);
    }
  }
  if (key.type === "private") {
    switch (usage) {
      case "verify":
        throw new TypeError(`${tag(key)} instances for asymmetric algorithm verifying must be of type "public"`);
      case "encrypt":
        throw new TypeError(`${tag(key)} instances for asymmetric algorithm encryption must be of type "public"`);
    }
  }
};
function checkKeyType(alg, key, usage) {
  switch (alg.substring(0, 2)) {
    case "A1":
    case "A2":
    case "di":
    case "HS":
    case "PB":
      symmetricTypeCheck(alg, key, usage);
      break;
    default:
      asymmetricTypeCheck(alg, key, usage);
  }
}
function subtleAlgorithm(alg, algorithm) {
  const hash = `SHA-${alg.slice(-3)}`;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      return { hash, name: "HMAC" };
    case "PS256":
    case "PS384":
    case "PS512":
      return { hash, name: "RSA-PSS", saltLength: parseInt(alg.slice(-3), 10) >> 3 };
    case "RS256":
    case "RS384":
    case "RS512":
      return { hash, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
    case "ES384":
    case "ES512":
      return { hash, name: "ECDSA", namedCurve: algorithm.namedCurve };
    case "Ed25519":
    case "EdDSA":
      return { name: "Ed25519" };
    case "ML-DSA-44":
    case "ML-DSA-65":
    case "ML-DSA-87":
      return { name: alg };
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}
async function getSigKey(alg, key, usage) {
  if (key instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalidKeyInput(key, "CryptoKey", "KeyObject", "JSON Web Key"));
    }
    return crypto.subtle.importKey("raw", key, { hash: `SHA-${alg.slice(-3)}`, name: "HMAC" }, false, [usage]);
  }
  checkSigCryptoKey(key, alg, usage);
  return key;
}
async function verify(alg, key, signature, data) {
  const cryptoKey = await getSigKey(alg, key, "verify");
  checkKeyLength(alg, cryptoKey);
  const algorithm = subtleAlgorithm(alg, cryptoKey.algorithm);
  try {
    return await crypto.subtle.verify(algorithm, cryptoKey, signature, data);
  } catch {
    return false;
  }
}
async function flattenedVerify(jws, key, options) {
  if (!isObject(jws)) {
    throw new JWSInvalid("Flattened JWS must be an object");
  }
  if (jws.protected === void 0 && jws.header === void 0) {
    throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
  }
  if (jws.protected !== void 0 && typeof jws.protected !== "string") {
    throw new JWSInvalid("JWS Protected Header incorrect type");
  }
  if (jws.payload === void 0) {
    throw new JWSInvalid("JWS Payload missing");
  }
  if (typeof jws.signature !== "string") {
    throw new JWSInvalid("JWS Signature missing or incorrect type");
  }
  if (jws.header !== void 0 && !isObject(jws.header)) {
    throw new JWSInvalid("JWS Unprotected Header incorrect type");
  }
  let parsedProt = {};
  if (jws.protected) {
    try {
      const protectedHeader = decode(jws.protected);
      parsedProt = JSON.parse(decoder.decode(protectedHeader));
    } catch {
      throw new JWSInvalid("JWS Protected Header is invalid");
    }
  }
  if (!isDisjoint(parsedProt, jws.header)) {
    throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jws.header
  };
  const extensions = validateCrit(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options?.crit, parsedProt, joseHeader);
  let b64 = true;
  if (extensions.has("b64")) {
    b64 = parsedProt.b64;
    if (typeof b64 !== "boolean") {
      throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
    }
  }
  const { alg } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
  }
  const algorithms = options && validateAlgorithms("algorithms", options.algorithms);
  if (algorithms && !algorithms.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter value not allowed');
  }
  if (b64) {
    if (typeof jws.payload !== "string") {
      throw new JWSInvalid("JWS Payload must be a string");
    }
  } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
    throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jws);
    resolvedKey = true;
  }
  checkKeyType(alg, key, "verify");
  const data = concat(jws.protected !== void 0 ? encode(jws.protected) : new Uint8Array(), encode("."), typeof jws.payload === "string" ? b64 ? encode(jws.payload) : encoder.encode(jws.payload) : jws.payload);
  let signature;
  try {
    signature = decode(jws.signature);
  } catch {
    throw new JWSInvalid("Failed to base64url decode the signature");
  }
  const k = await normalizeKey(key, alg);
  const verified = await verify(alg, k, signature, data);
  if (!verified) {
    throw new JWSSignatureVerificationFailed();
  }
  let payload;
  if (b64) {
    try {
      payload = decode(jws.payload);
    } catch {
      throw new JWSInvalid("Failed to base64url decode the payload");
    }
  } else if (typeof jws.payload === "string") {
    payload = encoder.encode(jws.payload);
  } else {
    payload = jws.payload;
  }
  const result = { payload };
  if (jws.protected !== void 0) {
    result.protectedHeader = parsedProt;
  }
  if (jws.header !== void 0) {
    result.unprotectedHeader = jws.header;
  }
  if (resolvedKey) {
    return { ...result, key: k };
  }
  return result;
}
async function compactVerify(jws, key, options) {
  if (jws instanceof Uint8Array) {
    jws = decoder.decode(jws);
  }
  if (typeof jws !== "string") {
    throw new JWSInvalid("Compact JWS must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split(".");
  if (length !== 3) {
    throw new JWSInvalid("Invalid Compact JWS");
  }
  const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);
  const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}
const epoch = (date2) => Math.floor(date2.getTime() / 1e3);
const minute = 60;
const hour = minute * 60;
const day = hour * 24;
const week = day * 7;
const year = day * 365.25;
const REGEX = /^(\+|\-)? ?(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)(?: (ago|from now))?$/i;
function secs(str) {
  const matched = REGEX.exec(str);
  if (!matched || matched[4] && matched[1]) {
    throw new TypeError("Invalid time period format");
  }
  const value = parseFloat(matched[2]);
  const unit = matched[3].toLowerCase();
  let numericDate;
  switch (unit) {
    case "sec":
    case "secs":
    case "second":
    case "seconds":
    case "s":
      numericDate = Math.round(value);
      break;
    case "minute":
    case "minutes":
    case "min":
    case "mins":
    case "m":
      numericDate = Math.round(value * minute);
      break;
    case "hour":
    case "hours":
    case "hr":
    case "hrs":
    case "h":
      numericDate = Math.round(value * hour);
      break;
    case "day":
    case "days":
    case "d":
      numericDate = Math.round(value * day);
      break;
    case "week":
    case "weeks":
    case "w":
      numericDate = Math.round(value * week);
      break;
    default:
      numericDate = Math.round(value * year);
      break;
  }
  if (matched[1] === "-" || matched[4] === "ago") {
    return -numericDate;
  }
  return numericDate;
}
const normalizeTyp = (value) => {
  if (value.includes("/")) {
    return value.toLowerCase();
  }
  return `application/${value.toLowerCase()}`;
};
const checkAudiencePresence = (audPayload, audOption) => {
  if (typeof audPayload === "string") {
    return audOption.includes(audPayload);
  }
  if (Array.isArray(audPayload)) {
    return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
  }
  return false;
};
function validateClaimsSet(protectedHeader, encodedPayload, options = {}) {
  let payload;
  try {
    payload = JSON.parse(decoder.decode(encodedPayload));
  } catch {
  }
  if (!isObject(payload)) {
    throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");
  }
  const { typ } = options;
  if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
    throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', payload, "typ", "check_failed");
  }
  const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;
  const presenceCheck = [...requiredClaims];
  if (maxTokenAge !== void 0)
    presenceCheck.push("iat");
  if (audience !== void 0)
    presenceCheck.push("aud");
  if (subject !== void 0)
    presenceCheck.push("sub");
  if (issuer !== void 0)
    presenceCheck.push("iss");
  for (const claim of new Set(presenceCheck.reverse())) {
    if (!(claim in payload)) {
      throw new JWTClaimValidationFailed(`missing required "${claim}" claim`, payload, claim, "missing");
    }
  }
  if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
    throw new JWTClaimValidationFailed('unexpected "iss" claim value', payload, "iss", "check_failed");
  }
  if (subject && payload.sub !== subject) {
    throw new JWTClaimValidationFailed('unexpected "sub" claim value', payload, "sub", "check_failed");
  }
  if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
    throw new JWTClaimValidationFailed('unexpected "aud" claim value', payload, "aud", "check_failed");
  }
  let tolerance;
  switch (typeof options.clockTolerance) {
    case "string":
      tolerance = secs(options.clockTolerance);
      break;
    case "number":
      tolerance = options.clockTolerance;
      break;
    case "undefined":
      tolerance = 0;
      break;
    default:
      throw new TypeError("Invalid clockTolerance option type");
  }
  const { currentDate } = options;
  const now = epoch(currentDate || /* @__PURE__ */ new Date());
  if ((payload.iat !== void 0 || maxTokenAge) && typeof payload.iat !== "number") {
    throw new JWTClaimValidationFailed('"iat" claim must be a number', payload, "iat", "invalid");
  }
  if (payload.nbf !== void 0) {
    if (typeof payload.nbf !== "number") {
      throw new JWTClaimValidationFailed('"nbf" claim must be a number', payload, "nbf", "invalid");
    }
    if (payload.nbf > now + tolerance) {
      throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', payload, "nbf", "check_failed");
    }
  }
  if (payload.exp !== void 0) {
    if (typeof payload.exp !== "number") {
      throw new JWTClaimValidationFailed('"exp" claim must be a number', payload, "exp", "invalid");
    }
    if (payload.exp <= now - tolerance) {
      throw new JWTExpired('"exp" claim timestamp check failed', payload, "exp", "check_failed");
    }
  }
  if (maxTokenAge) {
    const age = now - payload.iat;
    const max = typeof maxTokenAge === "number" ? maxTokenAge : secs(maxTokenAge);
    if (age - tolerance > max) {
      throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', payload, "iat", "check_failed");
    }
    if (age < 0 - tolerance) {
      throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', payload, "iat", "check_failed");
    }
  }
  return payload;
}
async function jwtVerify(jwt, key, options) {
  const verified = await compactVerify(jwt, key, options);
  if (verified.protectedHeader.crit?.includes("b64") && verified.protectedHeader.b64 === false) {
    throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
  }
  const payload = validateClaimsSet(verified.protectedHeader, verified.payload, options);
  const result = { payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}
function getKtyFromAlg(alg) {
  switch (typeof alg === "string" && alg.slice(0, 2)) {
    case "RS":
    case "PS":
      return "RSA";
    case "ES":
      return "EC";
    case "Ed":
      return "OKP";
    case "ML":
      return "AKP";
    default:
      throw new JOSENotSupported('Unsupported "alg" value for a JSON Web Key Set');
  }
}
function isJWKSLike(jwks) {
  return jwks && typeof jwks === "object" && Array.isArray(jwks.keys) && jwks.keys.every(isJWKLike);
}
function isJWKLike(key) {
  return isObject(key);
}
class LocalJWKSet {
  #jwks;
  #cached = /* @__PURE__ */ new WeakMap();
  constructor(jwks) {
    if (!isJWKSLike(jwks)) {
      throw new JWKSInvalid("JSON Web Key Set malformed");
    }
    this.#jwks = structuredClone(jwks);
  }
  jwks() {
    return this.#jwks;
  }
  async getKey(protectedHeader, token) {
    const { alg, kid } = { ...protectedHeader, ...token?.header };
    const kty = getKtyFromAlg(alg);
    const candidates = this.#jwks.keys.filter((jwk2) => {
      let candidate = kty === jwk2.kty;
      if (candidate && typeof kid === "string") {
        candidate = kid === jwk2.kid;
      }
      if (candidate && (typeof jwk2.alg === "string" || kty === "AKP")) {
        candidate = alg === jwk2.alg;
      }
      if (candidate && typeof jwk2.use === "string") {
        candidate = jwk2.use === "sig";
      }
      if (candidate && Array.isArray(jwk2.key_ops)) {
        candidate = jwk2.key_ops.includes("verify");
      }
      if (candidate) {
        switch (alg) {
          case "ES256":
            candidate = jwk2.crv === "P-256";
            break;
          case "ES384":
            candidate = jwk2.crv === "P-384";
            break;
          case "ES512":
            candidate = jwk2.crv === "P-521";
            break;
          case "Ed25519":
          case "EdDSA":
            candidate = jwk2.crv === "Ed25519";
            break;
        }
      }
      return candidate;
    });
    const { 0: jwk, length } = candidates;
    if (length === 0) {
      throw new JWKSNoMatchingKey();
    }
    if (length !== 1) {
      const error = new JWKSMultipleMatchingKeys();
      const _cached = this.#cached;
      error[Symbol.asyncIterator] = async function* () {
        for (const jwk2 of candidates) {
          try {
            yield await importWithAlgCache(_cached, jwk2, alg);
          } catch {
          }
        }
      };
      throw error;
    }
    return importWithAlgCache(this.#cached, jwk, alg);
  }
}
async function importWithAlgCache(cache2, jwk, alg) {
  const cached = cache2.get(jwk) || cache2.set(jwk, {}).get(jwk);
  if (cached[alg] === void 0) {
    const key = await importJWK({ ...jwk, ext: true }, alg);
    if (key instanceof Uint8Array || key.type !== "public") {
      throw new JWKSInvalid("JSON Web Key Set members must be public keys");
    }
    cached[alg] = key;
  }
  return cached[alg];
}
function createLocalJWKSet(jwks) {
  const set2 = new LocalJWKSet(jwks);
  const localJWKSet = async (protectedHeader, token) => set2.getKey(protectedHeader, token);
  Object.defineProperties(localJWKSet, {
    jwks: {
      value: () => structuredClone(set2.jwks()),
      enumerable: false,
      configurable: false,
      writable: false
    }
  });
  return localJWKSet;
}
function isCloudflareWorkers() {
  return typeof WebSocketPair !== "undefined" || typeof navigator !== "undefined" && navigator.userAgent === "Cloudflare-Workers" || typeof EdgeRuntime !== "undefined" && EdgeRuntime === "vercel";
}
let USER_AGENT;
if (typeof navigator === "undefined" || !navigator.userAgent?.startsWith?.("Mozilla/5.0 ")) {
  const NAME = "jose";
  const VERSION = "v6.1.2";
  USER_AGENT = `${NAME}/${VERSION}`;
}
const customFetch = Symbol();
async function fetchJwks(url, headers, signal, fetchImpl = fetch) {
  const response = await fetchImpl(url, {
    method: "GET",
    signal,
    redirect: "manual",
    headers
  }).catch((err) => {
    if (err.name === "TimeoutError") {
      throw new JWKSTimeout();
    }
    throw err;
  });
  if (response.status !== 200) {
    throw new JOSEError("Expected 200 OK from the JSON Web Key Set HTTP response");
  }
  try {
    return await response.json();
  } catch {
    throw new JOSEError("Failed to parse the JSON Web Key Set HTTP response as JSON");
  }
}
const jwksCache$1 = Symbol();
function isFreshJwksCache(input, cacheMaxAge) {
  if (typeof input !== "object" || input === null) {
    return false;
  }
  if (!("uat" in input) || typeof input.uat !== "number" || Date.now() - input.uat >= cacheMaxAge) {
    return false;
  }
  if (!("jwks" in input) || !isObject(input.jwks) || !Array.isArray(input.jwks.keys) || !Array.prototype.every.call(input.jwks.keys, isObject)) {
    return false;
  }
  return true;
}
class RemoteJWKSet {
  #url;
  #timeoutDuration;
  #cooldownDuration;
  #cacheMaxAge;
  #jwksTimestamp;
  #pendingFetch;
  #headers;
  #customFetch;
  #local;
  #cache;
  constructor(url, options) {
    if (!(url instanceof URL)) {
      throw new TypeError("url must be an instance of URL");
    }
    this.#url = new URL(url.href);
    this.#timeoutDuration = typeof options?.timeoutDuration === "number" ? options?.timeoutDuration : 5e3;
    this.#cooldownDuration = typeof options?.cooldownDuration === "number" ? options?.cooldownDuration : 3e4;
    this.#cacheMaxAge = typeof options?.cacheMaxAge === "number" ? options?.cacheMaxAge : 6e5;
    this.#headers = new Headers(options?.headers);
    if (USER_AGENT && !this.#headers.has("User-Agent")) {
      this.#headers.set("User-Agent", USER_AGENT);
    }
    if (!this.#headers.has("accept")) {
      this.#headers.set("accept", "application/json");
      this.#headers.append("accept", "application/jwk-set+json");
    }
    this.#customFetch = options?.[customFetch];
    if (options?.[jwksCache$1] !== void 0) {
      this.#cache = options?.[jwksCache$1];
      if (isFreshJwksCache(options?.[jwksCache$1], this.#cacheMaxAge)) {
        this.#jwksTimestamp = this.#cache.uat;
        this.#local = createLocalJWKSet(this.#cache.jwks);
      }
    }
  }
  pendingFetch() {
    return !!this.#pendingFetch;
  }
  coolingDown() {
    return typeof this.#jwksTimestamp === "number" ? Date.now() < this.#jwksTimestamp + this.#cooldownDuration : false;
  }
  fresh() {
    return typeof this.#jwksTimestamp === "number" ? Date.now() < this.#jwksTimestamp + this.#cacheMaxAge : false;
  }
  jwks() {
    return this.#local?.jwks();
  }
  async getKey(protectedHeader, token) {
    if (!this.#local || !this.fresh()) {
      await this.reload();
    }
    try {
      return await this.#local(protectedHeader, token);
    } catch (err) {
      if (err instanceof JWKSNoMatchingKey) {
        if (this.coolingDown() === false) {
          await this.reload();
          return this.#local(protectedHeader, token);
        }
      }
      throw err;
    }
  }
  async reload() {
    if (this.#pendingFetch && isCloudflareWorkers()) {
      this.#pendingFetch = void 0;
    }
    this.#pendingFetch ||= fetchJwks(this.#url.href, this.#headers, AbortSignal.timeout(this.#timeoutDuration), this.#customFetch).then((json2) => {
      this.#local = createLocalJWKSet(json2);
      if (this.#cache) {
        this.#cache.uat = Date.now();
        this.#cache.jwks = json2;
      }
      this.#jwksTimestamp = Date.now();
      this.#pendingFetch = void 0;
    }).catch((err) => {
      this.#pendingFetch = void 0;
      throw err;
    });
    await this.#pendingFetch;
  }
}
function createRemoteJWKSet(url, options) {
  const set2 = new RemoteJWKSet(url, options);
  const remoteJWKSet = async (protectedHeader, token) => set2.getKey(protectedHeader, token);
  Object.defineProperties(remoteJWKSet, {
    coolingDown: {
      get: () => set2.coolingDown(),
      enumerable: true,
      configurable: false
    },
    fresh: {
      get: () => set2.fresh(),
      enumerable: true,
      configurable: false
    },
    reload: {
      value: () => set2.reload(),
      enumerable: true,
      configurable: false,
      writable: false
    },
    reloading: {
      get: () => set2.pendingFetch(),
      enumerable: true,
      configurable: false
    },
    jwks: {
      value: () => set2.jwks(),
      enumerable: true,
      configurable: false,
      writable: false
    }
  });
  return remoteJWKSet;
}
const jwksCache = /* @__PURE__ */ new Map();
class BearerValidator {
  constructor(config = {}) {
    this.config = config;
  }
  /**
   * Extract bearer token from Authorization header
   */
  extractToken(request) {
    const authHeader = request.headers.get("Authorization");
    if (!authHeader?.startsWith("Bearer ")) {
      return null;
    }
    return authHeader.substring(7);
  }
  /**
   * Get JWKS key resolver for RSA/EC algorithms
   */
  getJWKS() {
    if (!this.config.jwksUrl) {
      return null;
    }
    let jwks = jwksCache.get(this.config.jwksUrl);
    if (!jwks) {
      jwks = createRemoteJWKSet(new URL(this.config.jwksUrl));
      jwksCache.set(this.config.jwksUrl, jwks);
    }
    return jwks;
  }
  /**
   * Get HMAC secret key for HS256/384/512 algorithms
   */
  getSecretKey() {
    if (!this.config.secret) {
      return null;
    }
    return new TextEncoder().encode(this.config.secret);
  }
  /**
   * Verify JWT token with cryptographic signature verification
   *
   * Uses the jose library to properly verify:
   * 1. Signature integrity (HMAC or RSA/EC)
   * 2. Expiration time (exp claim)
   * 3. Not-before time (nbf claim)
   * 4. Issuer (iss claim) if configured
   * 5. Audience (aud claim) if configured
   */
  async verifyToken(token) {
    if (this.config.customDecoder) {
      try {
        return await this.config.customDecoder(token);
      } catch {
        return null;
      }
    }
    try {
      const options = {};
      if (this.config.issuer) {
        options.issuer = this.config.issuer;
      }
      if (this.config.audience) {
        options.audience = this.config.audience;
      }
      if (this.config.algorithms) {
        options.algorithms = this.config.algorithms;
      }
      const jwks = this.getJWKS();
      if (jwks) {
        const { payload } = await jwtVerify(token, jwks, options);
        return payload;
      }
      const secretKey = this.getSecretKey();
      if (secretKey) {
        const { payload } = await jwtVerify(token, secretKey, options);
        return payload;
      }
      throw new Error("No JWT secret or JWKS URL configured");
    } catch (error) {
      return null;
    }
  }
  /**
   * Validate bearer token
   */
  async validate(request, _env) {
    const token = this.extractToken(request);
    if (!token) {
      return {
        valid: false,
        error: "invalid_token",
        message: "No bearer token provided"
      };
    }
    const payload = await this.verifyToken(token);
    if (!payload) {
      return {
        valid: false,
        error: "invalid_token",
        message: "Invalid or expired bearer token"
      };
    }
    const context = {
      authenticated: true,
      method: "bearer",
      token,
      user: {
        id: payload.sub,
        email: payload.email,
        roles: payload.roles || [],
        permissions: payload.permissions || [],
        metadata: {}
      },
      expiresAt: payload.exp
    };
    const standardClaims = ["sub", "email", "roles", "permissions", "exp", "iat", "iss", "aud"];
    for (const [key, value] of Object.entries(payload)) {
      if (!standardClaims.includes(key)) {
        context.user.metadata[key] = value;
      }
    }
    return {
      valid: true,
      context
    };
  }
}
function createBearerValidator(env) {
  if (!env.JWT_SECRET && !env.JWT_JWKS_URL) {
    return null;
  }
  return new BearerValidator({
    secret: env.JWT_SECRET,
    jwksUrl: env.JWT_JWKS_URL,
    issuer: env.JWT_ISSUER,
    audience: env.JWT_AUDIENCE,
    algorithms: env.JWT_ALGORITHMS ? env.JWT_ALGORITHMS.split(",") : void 0
  });
}
const logger$4 = createLogger({ serviceName: "auth-apikey" });
class ApiKeyValidator {
  constructor(config) {
    this.config = config;
  }
  /**
   * Extract API key from request
   *
   * Checks sources in order of preference: header  cookie  query
   * Query is checked last and only if explicitly enabled (security risk)
   */
  extractToken(request) {
    const sources = this.config.sources || ["header"];
    const headerName = this.config.headerName || "X-API-Key";
    const queryName = this.config.queryName || "api_key";
    const cookieName = this.config.cookieName || "api_key";
    if (sources.includes("header")) {
      const headerValue = request.headers.get(headerName);
      if (headerValue) return headerValue;
    }
    if (sources.includes("cookie")) {
      const cookieHeader = request.headers.get("Cookie");
      if (cookieHeader) {
        const cookies = cookieHeader.split(";").map((c) => c.trim());
        for (const cookie of cookies) {
          const [name, value] = cookie.split("=");
          if (name === cookieName && value) {
            return decodeURIComponent(value);
          }
        }
      }
    }
    if (sources.includes("query")) {
      const url = new URL(request.url);
      const queryValue = url.searchParams.get(queryName);
      if (queryValue) {
        logger$4.warn(
          "API key extracted from query parameter - this is insecure",
          { source: "query", warning: "URLs appear in logs, browser history, and Referer headers" }
        );
        return queryValue;
      }
    }
    return null;
  }
  /**
   * Validate key format
   */
  isValidFormat(apiKey) {
    if (!apiKey) return false;
    if (this.config.prefix && !apiKey.startsWith(this.config.prefix)) {
      return false;
    }
    return apiKey.length >= 8 && apiKey.length <= 256;
  }
  /**
   * Validate API key
   */
  async validate(request, env) {
    const apiKey = this.extractToken(request);
    if (!apiKey) {
      return {
        valid: false,
        error: "invalid_token",
        message: "No API key provided"
      };
    }
    if (!this.isValidFormat(apiKey)) {
      return {
        valid: false,
        error: "invalid_token",
        message: "Invalid API key format"
      };
    }
    const kv = env[this.config.kvNamespace];
    if (!kv) {
      logger$4.error(`KV namespace "${this.config.kvNamespace}" not found in env`, void 0, {
        kvNamespace: this.config.kvNamespace
      });
      return {
        valid: false,
        error: "unknown",
        message: "Authentication service error"
      };
    }
    try {
      const metadataJson = await kv.get(apiKey);
      if (!metadataJson) {
        return {
          valid: false,
          error: "invalid_token",
          message: "Invalid API key"
        };
      }
      const metadata = JSON.parse(metadataJson);
      if (metadata.expiresAt && Date.now() > metadata.expiresAt) {
        return {
          valid: false,
          error: "expired",
          message: "API key has expired"
        };
      }
      const context = {
        authenticated: true,
        method: "apiKey",
        token: apiKey,
        user: {
          id: metadata.userId || metadata.keyId,
          permissions: metadata.permissions || [],
          roles: [],
          metadata: {
            ...metadata.metadata,
            keyId: metadata.keyId,
            keyName: metadata.name
          }
        },
        expiresAt: metadata.expiresAt
      };
      return {
        valid: true,
        context,
        ratelimit: metadata.rateLimit ? {
          limit: metadata.rateLimit.requests,
          remaining: metadata.rateLimit.requests,
          // TODO: Implement actual rate limiting
          reset: Math.floor(Date.now() / 1e3) + metadata.rateLimit.window
        } : void 0
      };
    } catch (error) {
      logger$4.error("API key validation error", error instanceof Error ? error : void 0);
      return {
        valid: false,
        error: "unknown",
        message: "Authentication validation failed"
      };
    }
  }
}
function createApiKeyValidator(env) {
  const kvNamespace = env.API_KEY_KV_NAMESPACE || "API_KEYS";
  if (!env[kvNamespace]) {
    return null;
  }
  let sources = ["header"];
  if (env.API_KEY_SOURCES) {
    sources = env.API_KEY_SOURCES.split(",").map(
      (s) => s.trim()
    );
    if (sources.includes("query")) {
      logger$4.warn(
        'API_KEY_SOURCES includes "query" - this is insecure',
        { warning: "API keys in URLs appear in logs, browser history, and Referer headers" }
      );
    }
  }
  return new ApiKeyValidator({
    kvNamespace,
    sources,
    headerName: env.API_KEY_HEADER_NAME || "X-API-Key",
    queryName: env.API_KEY_QUERY_NAME || "api_key",
    cookieName: env.API_KEY_COOKIE_NAME || "api_key",
    prefix: env.API_KEY_PREFIX,
    stealthMode: env.API_KEY_STEALTH_MODE === "true"
  });
}
const logger$3 = createLogger({ serviceName: "auth-cookie" });
class CookieValidator {
  constructor(config) {
    this.config = config;
  }
  /**
   * Extract session token from cookie
   */
  extractToken(request) {
    const cookieName = this.config.cookieName || "session_token";
    const cookieHeader = request.headers.get("Cookie");
    if (!cookieHeader) {
      return null;
    }
    const cookies = cookieHeader.split(";").map((c) => c.trim());
    for (const cookie of cookies) {
      const [name, value] = cookie.split("=");
      if (name === cookieName && value) {
        return decodeURIComponent(value);
      }
    }
    return null;
  }
  /**
   * Validate session token format
   */
  isValidFormat(token) {
    return Boolean(token && token.length >= 16 && token.length <= 512);
  }
  /**
   * Validate cookie session
   */
  async validate(request, env) {
    const sessionToken = this.extractToken(request);
    if (!sessionToken) {
      return {
        valid: false,
        error: "invalid_token",
        message: "No session token provided"
      };
    }
    if (!this.isValidFormat(sessionToken)) {
      return {
        valid: false,
        error: "invalid_token",
        message: "Invalid session token format"
      };
    }
    const kv = env[this.config.kvNamespace];
    if (!kv) {
      logger$3.error(`KV namespace "${this.config.kvNamespace}" not found in env`);
      return {
        valid: false,
        error: "unknown",
        message: "Authentication service error"
      };
    }
    try {
      const sessionJson = await kv.get(`session:${sessionToken}`);
      if (!sessionJson) {
        return {
          valid: false,
          error: "invalid_token",
          message: "Invalid or expired session"
        };
      }
      const session = JSON.parse(sessionJson);
      if (session.expiresAt && Date.now() > session.expiresAt) {
        await kv.delete(`session:${sessionToken}`);
        return {
          valid: false,
          error: "expired",
          message: "Session has expired"
        };
      }
      const context = {
        authenticated: true,
        method: "cookie",
        token: sessionToken,
        user: {
          id: session.userId,
          email: session.email,
          roles: session.roles || [],
          permissions: session.permissions || [],
          metadata: {
            ...session.metadata,
            sessionId: session.sessionId,
            sessionCreated: session.createdAt
          }
        },
        expiresAt: session.expiresAt
      };
      return {
        valid: true,
        context
      };
    } catch (error) {
      logger$3.error("Cookie session validation error", error);
      return {
        valid: false,
        error: "unknown",
        message: "Authentication validation failed"
      };
    }
  }
  /**
   * Create session cookie header
   */
  createCookie(sessionToken, options) {
    const cookieName = this.config.cookieName || "session_token";
    const parts = [`${cookieName}=${encodeURIComponent(sessionToken)}`];
    if (this.config.domain) {
      parts.push(`Domain=${this.config.domain}`);
    }
    if (this.config.path || this.config.path === "") {
      parts.push(`Path=${this.config.path}`);
    } else {
      parts.push("Path=/");
    }
    if (options?.maxAge !== void 0) {
      parts.push(`Max-Age=${options.maxAge}`);
    } else if (options?.expires) {
      parts.push(`Expires=${options.expires.toUTCString()}`);
    }
    if (this.config.secure !== false) {
      parts.push("Secure");
    }
    if (this.config.httpOnly !== false) {
      parts.push("HttpOnly");
    }
    const sameSite = this.config.sameSite || "lax";
    parts.push(`SameSite=${sameSite.charAt(0).toUpperCase() + sameSite.slice(1)}`);
    return parts.join("; ");
  }
  /**
   * Create session in KV
   */
  async createSession(kv, sessionData) {
    const sessionToken = crypto.randomUUID();
    const sessionId = crypto.randomUUID();
    const now = Date.now();
    const ttl = this.config.sessionTTL || 86400;
    const expiresAt = sessionData.expiresAt || now + ttl * 1e3;
    const session = {
      ...sessionData,
      sessionId,
      createdAt: now,
      expiresAt
    };
    await kv.put(`session:${sessionToken}`, JSON.stringify(session), { expirationTtl: ttl });
    return sessionToken;
  }
  /**
   * Delete session from KV
   */
  async deleteSession(kv, sessionToken) {
    await kv.delete(`session:${sessionToken}`);
  }
}
function createCookieValidator(env) {
  const kvNamespace = env.SESSION_KV_NAMESPACE || "SESSIONS";
  if (!env[kvNamespace]) {
    return null;
  }
  return new CookieValidator({
    kvNamespace,
    cookieName: env.SESSION_COOKIE_NAME || "session_token",
    domain: env.SESSION_COOKIE_DOMAIN,
    path: env.SESSION_COOKIE_PATH || "/",
    secure: env.SESSION_COOKIE_SECURE !== "false",
    httpOnly: env.SESSION_COOKIE_HTTP_ONLY !== "false",
    sameSite: env.SESSION_COOKIE_SAME_SITE || "lax",
    sessionTTL: env.SESSION_TTL ? parseInt(env.SESSION_TTL) : 86400
  });
}
const logger$2 = createLogger({ serviceName: "auth-unkey" });
class UnkeyValidator {
  constructor(config) {
    this.config = config;
  }
  /**
   * Extract API key from request
   * Checks multiple locations: X-API-Key header, Authorization header, query param
   */
  extractToken(request) {
    const apiKeyHeader = request.headers.get("X-API-Key");
    if (apiKeyHeader) {
      return apiKeyHeader;
    }
    const authHeader = request.headers.get("Authorization");
    if (authHeader?.startsWith("Bearer ")) {
      return authHeader.substring(7);
    }
    const url = new URL(request.url);
    const apiKeyQuery = url.searchParams.get("api_key");
    if (apiKeyQuery) {
      return apiKeyQuery;
    }
    return null;
  }
  /**
   * Validate API key format
   */
  isValidKeyFormat(apiKey) {
    if (!apiKey) return false;
    if (this.config.keyPrefix && this.config.keyPrefix.length > 0) {
      return this.config.keyPrefix.some((prefix) => apiKey.startsWith(prefix));
    }
    return true;
  }
  /**
   * Check if key is a service account
   */
  isServiceAccount(apiKey) {
    return Boolean(apiKey && apiKey.includes("_service"));
  }
  /**
   * Validate with Unkey API
   */
  async validate(request, env) {
    const apiKey = this.extractToken(request);
    if (!apiKey) {
      return {
        valid: false,
        error: "invalid_token",
        message: "No API key provided"
      };
    }
    if (!this.isValidKeyFormat(apiKey)) {
      return {
        valid: false,
        error: "invalid_token",
        message: "Invalid API key format"
      };
    }
    try {
      const response = await fetch("https://api.unkey.dev/v1/keys.verifyKey", {
        method: "POST",
        headers: {
          Authorization: `Bearer ${this.config.rootKey}`,
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          ...this.config.apiId && { apiId: this.config.apiId },
          key: apiKey
        })
      });
      if (!response.ok) {
        logger$2.error("Unkey API error", void 0, {
          status: response.status,
          statusText: response.statusText
        });
        return {
          valid: false,
          error: "unknown",
          message: "Authentication service error"
        };
      }
      const result = await response.json();
      if (!result.valid) {
        if (result.code === "RATE_LIMITED" || result.ratelimit && result.ratelimit.remaining <= 0) {
          return {
            valid: false,
            error: "rate_limited",
            message: "Rate limit exceeded",
            ratelimit: result.ratelimit
          };
        }
        return {
          valid: false,
          error: "invalid_token",
          message: "Invalid API key"
        };
      }
      const context = {
        authenticated: true,
        method: "unkey",
        token: apiKey,
        user: {
          id: result.ownerId || "unknown",
          permissions: result.permissions || [],
          metadata: result.meta || {}
        },
        unkey: {
          keyId: result.keyId,
          ownerId: result.ownerId,
          isServiceAccount: this.isServiceAccount(apiKey),
          ratelimit: result.ratelimit
        }
      };
      return {
        valid: true,
        context,
        ratelimit: result.ratelimit
      };
    } catch (error) {
      logger$2.error("Unkey validation error", error);
      return {
        valid: false,
        error: "unknown",
        message: "Authentication validation failed"
      };
    }
  }
}
function createUnkeyValidator(env) {
  if (!env.UNKEY_ROOT_KEY) {
    return null;
  }
  return new UnkeyValidator({
    rootKey: env.UNKEY_ROOT_KEY,
    apiId: env.UNKEY_API_ID,
    keyPrefix: env.UNKEY_KEY_PREFIX ? env.UNKEY_KEY_PREFIX.split(",") : ["ownerco_", "oiq_"],
    stealthMode: env.UNKEY_STEALTH_MODE === "true"
  });
}
const unkey = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  UnkeyValidator,
  createUnkeyValidator
}, Symbol.toStringTag, { value: "Module" }));
const logger$1 = createLogger({ serviceName: "auth-custom" });
class StripeSignatureValidator {
  constructor(webhookSecret) {
    this.webhookSecret = webhookSecret;
  }
  extractToken(request) {
    return request.headers.get("stripe-signature");
  }
  async validate(request, _env) {
    const signature = this.extractToken(request);
    if (!signature) {
      return {
        valid: false,
        error: "invalid_token",
        message: "Missing Stripe signature"
      };
    }
    const body = await request.text();
    const isValid2 = await this.verifyStripeSignature(body, signature);
    if (!isValid2) {
      return {
        valid: false,
        error: "invalid_token",
        message: "Invalid Stripe signature"
      };
    }
    return {
      valid: true,
      context: {
        authenticated: true,
        method: "custom",
        custom: {
          provider: "stripe",
          signature
        }
      }
    };
  }
  async verifyStripeSignature(payload, signature) {
    try {
      const elements = signature.split(",");
      const signatureData = {};
      for (const element of elements) {
        const [key, value] = element.split("=");
        signatureData[key] = value;
      }
      const timestamp2 = signatureData["t"];
      const signatures = [signatureData["v1"]];
      if (!timestamp2 || !signatures[0]) {
        return false;
      }
      const timestampAge = Math.floor(Date.now() / 1e3) - parseInt(timestamp2);
      if (timestampAge > 300) {
        return false;
      }
      const signedPayload = `${timestamp2}.${payload}`;
      const expectedSignature = await this.computeHMAC(signedPayload, this.webhookSecret);
      return signatures.some((sig) => this.secureCompare(sig, expectedSignature));
    } catch (error) {
      logger$1.error("Stripe signature verification error", error instanceof Error ? error : void 0);
      return false;
    }
  }
  async computeHMAC(data, secret) {
    const encoder2 = new TextEncoder();
    const keyData = encoder2.encode(secret);
    const messageData = encoder2.encode(data);
    const key = await crypto.subtle.importKey(
      "raw",
      keyData,
      { name: "HMAC", hash: "SHA-256" },
      false,
      ["sign"]
    );
    const signature = await crypto.subtle.sign("HMAC", key, messageData);
    return Array.from(new Uint8Array(signature)).map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  secureCompare(a, b) {
    if (a.length !== b.length) return false;
    let result = 0;
    for (let i = 0; i < a.length; i++) {
      result |= a.charCodeAt(i) ^ b.charCodeAt(i);
    }
    return result === 0;
  }
}
class GitHubSignatureValidator {
  constructor(webhookSecret) {
    this.webhookSecret = webhookSecret;
  }
  extractToken(request) {
    return request.headers.get("x-hub-signature-256");
  }
  async validate(request, _env) {
    const signature = this.extractToken(request);
    if (!signature) {
      return {
        valid: false,
        error: "invalid_token",
        message: "Missing GitHub signature"
      };
    }
    const body = await request.text();
    const isValid2 = await this.verifyGitHubSignature(body, signature);
    if (!isValid2) {
      return {
        valid: false,
        error: "invalid_token",
        message: "Invalid GitHub signature"
      };
    }
    return {
      valid: true,
      context: {
        authenticated: true,
        method: "custom",
        custom: {
          provider: "github",
          signature
        }
      }
    };
  }
  async verifyGitHubSignature(payload, signature) {
    try {
      if (!signature.startsWith("sha256=")) {
        return false;
      }
      const receivedSignature = signature.substring(7);
      const expectedSignature = await this.computeHMAC(payload, this.webhookSecret);
      return this.secureCompare(receivedSignature, expectedSignature);
    } catch (error) {
      logger$1.error("GitHub signature verification error", error instanceof Error ? error : void 0);
      return false;
    }
  }
  async computeHMAC(data, secret) {
    const encoder2 = new TextEncoder();
    const keyData = encoder2.encode(secret);
    const messageData = encoder2.encode(data);
    const key = await crypto.subtle.importKey(
      "raw",
      keyData,
      { name: "HMAC", hash: "SHA-256" },
      false,
      ["sign"]
    );
    const signature = await crypto.subtle.sign("HMAC", key, messageData);
    return Array.from(new Uint8Array(signature)).map((b) => b.toString(16).padStart(2, "0")).join("");
  }
  secureCompare(a, b) {
    if (a.length !== b.length) return false;
    let result = 0;
    for (let i = 0; i < a.length; i++) {
      result |= a.charCodeAt(i) ^ b.charCodeAt(i);
    }
    return result === 0;
  }
}
class TwilioSignatureValidator {
  constructor(authToken) {
    this.authToken = authToken;
  }
  extractToken(request) {
    return request.headers.get("x-twilio-signature");
  }
  async validate(request, _env) {
    const signature = this.extractToken(request);
    if (!signature) {
      return {
        valid: false,
        error: "invalid_token",
        message: "Missing Twilio signature"
      };
    }
    const url = request.url;
    const body = await request.text();
    const isValid2 = await this.verifyTwilioSignature(url, body, signature);
    if (!isValid2) {
      return {
        valid: false,
        error: "invalid_token",
        message: "Invalid Twilio signature"
      };
    }
    return {
      valid: true,
      context: {
        authenticated: true,
        method: "custom",
        custom: {
          provider: "twilio",
          signature
        }
      }
    };
  }
  async verifyTwilioSignature(url, body, signature) {
    try {
      const params = new URLSearchParams(body);
      const sortedParams = Array.from(params.entries()).sort(([a], [b]) => a.localeCompare(b));
      let data = url;
      for (const [key, value] of sortedParams) {
        data += key + value;
      }
      const expectedSignature = await this.computeHMAC(data, this.authToken);
      return this.secureCompare(signature, expectedSignature);
    } catch (error) {
      logger$1.error("Twilio signature verification error", error instanceof Error ? error : void 0);
      return false;
    }
  }
  async computeHMAC(data, secret) {
    const encoder2 = new TextEncoder();
    const keyData = encoder2.encode(secret);
    const messageData = encoder2.encode(data);
    const key = await crypto.subtle.importKey(
      "raw",
      keyData,
      { name: "HMAC", hash: "SHA-1" },
      false,
      ["sign"]
    );
    const signature = await crypto.subtle.sign("HMAC", key, messageData);
    const bytes = new Uint8Array(signature);
    let binary2 = "";
    for (let i = 0; i < bytes.length; i++) {
      binary2 += String.fromCharCode(bytes[i]);
    }
    return btoa(binary2);
  }
  secureCompare(a, b) {
    if (a.length !== b.length) return false;
    let result = 0;
    for (let i = 0; i < a.length; i++) {
      result |= a.charCodeAt(i) ^ b.charCodeAt(i);
    }
    return result === 0;
  }
}
class CustomValidatorRegistry {
  constructor() {
    this.validators = /* @__PURE__ */ new Map();
  }
  /**
   * Register a custom validator
   */
  register(name, validator) {
    this.validators.set(name, validator);
  }
  /**
   * Get a validator by name
   */
  get(name) {
    return this.validators.get(name);
  }
  /**
   * Check if validator exists
   */
  has(name) {
    return this.validators.has(name);
  }
  /**
   * Register built-in validators from environment
   */
  registerBuiltIn(env) {
    if (env.STRIPE_WEBHOOK_SECRET) {
      this.register("stripe-signature", new StripeSignatureValidator(env.STRIPE_WEBHOOK_SECRET));
    }
    if (env.GITHUB_WEBHOOK_SECRET) {
      this.register("github-signature", new GitHubSignatureValidator(env.GITHUB_WEBHOOK_SECRET));
    }
    if (env.TWILIO_AUTH_TOKEN) {
      this.register("twilio-signature", new TwilioSignatureValidator(env.TWILIO_AUTH_TOKEN));
    }
  }
}
function createCustomValidatorRegistry(env) {
  const registry2 = new CustomValidatorRegistry();
  registry2.registerBuiltIn(env);
  return registry2;
}
async function timingSafeEqual(a, b) {
  const encoder2 = new TextEncoder();
  const key = await crypto.subtle.importKey(
    "raw",
    encoder2.encode("timing-safe-comparison-key"),
    { name: "HMAC", hash: "SHA-256" },
    false,
    ["sign"]
  );
  const [macA, macB] = await Promise.all([
    crypto.subtle.sign("HMAC", key, encoder2.encode(a)),
    crypto.subtle.sign("HMAC", key, encoder2.encode(b))
  ]);
  const viewA = new Uint8Array(macA);
  const viewB = new Uint8Array(macB);
  let result = 0;
  for (let i = 0; i < viewA.length; i++) {
    result |= viewA[i] ^ viewB[i];
  }
  return result === 0;
}
async function computeHMAC(message2, secret, algorithm = "sha256") {
  const encoder2 = new TextEncoder();
  const keyData = encoder2.encode(secret);
  const messageData = encoder2.encode(message2);
  const algoMap = {
    sha256: "SHA-256",
    sha1: "SHA-1",
    sha384: "SHA-384",
    sha512: "SHA-512"
  };
  const cryptoAlgorithm = algoMap[algorithm.toLowerCase()] || "SHA-256";
  const key = await crypto.subtle.importKey(
    "raw",
    keyData,
    { name: "HMAC", hash: cryptoAlgorithm },
    false,
    ["sign"]
  );
  const signature = await crypto.subtle.sign("HMAC", key, messageData);
  return Array.from(new Uint8Array(signature)).map((b) => b.toString(16).padStart(2, "0")).join("");
}
class SignatureValidator {
  constructor(config) {
    this.config = {
      secret: config.secret,
      algorithm: config.algorithm || "sha256",
      signatureHeader: config.signatureHeader || "x-webhook-signature",
      timestampHeader: config.timestampHeader || "x-webhook-timestamp",
      timestampTolerance: config.timestampTolerance ?? 300,
      signaturePrefix: config.signaturePrefix || "",
      payloadFormat: config.payloadFormat || "timestamp.body",
      customPayloadBuilder: config.customPayloadBuilder
    };
  }
  /**
   * Extract signature from request header
   */
  extractToken(request) {
    const signature = request.headers.get(this.config.signatureHeader);
    if (!signature) {
      return null;
    }
    if (this.config.signaturePrefix && signature.startsWith(this.config.signaturePrefix)) {
      return signature.substring(this.config.signaturePrefix.length);
    }
    return signature;
  }
  /**
   * Validate the webhook signature
   */
  async validate(request, _env) {
    const signature = this.extractToken(request);
    const timestamp2 = request.headers.get(this.config.timestampHeader);
    if (!signature) {
      return {
        valid: false,
        error: "invalid_token",
        message: `Missing signature header: ${this.config.signatureHeader}`
      };
    }
    if (this.config.timestampTolerance > 0) {
      if (!timestamp2) {
        return {
          valid: false,
          error: "invalid_token",
          message: `Missing timestamp header: ${this.config.timestampHeader}`
        };
      }
      const now = Math.floor(Date.now() / 1e3);
      const requestTime = parseInt(timestamp2, 10);
      if (isNaN(requestTime)) {
        return {
          valid: false,
          error: "invalid_token",
          message: "Invalid timestamp format"
        };
      }
      if (Math.abs(now - requestTime) > this.config.timestampTolerance) {
        return {
          valid: false,
          error: "expired",
          message: `Timestamp outside tolerance window (${this.config.timestampTolerance}s)`
        };
      }
    }
    const body = await request.clone().text();
    let payload;
    switch (this.config.payloadFormat) {
      case "timestamp.body":
        payload = `${timestamp2 || ""}.${body}`;
        break;
      case "body":
        payload = body;
        break;
      case "custom":
        if (this.config.customPayloadBuilder) {
          payload = this.config.customPayloadBuilder(timestamp2 || "", body);
        } else {
          payload = body;
        }
        break;
      default:
        payload = body;
    }
    const expectedSignature = await computeHMAC(payload, this.config.secret, this.config.algorithm);
    const signaturesMatch = await timingSafeEqual(
      signature.toLowerCase(),
      expectedSignature.toLowerCase()
    );
    if (!signaturesMatch) {
      return {
        valid: false,
        error: "invalid_token",
        message: "Invalid webhook signature"
      };
    }
    const context = {
      authenticated: true,
      method: "bearer",
      // Use 'bearer' as the generic authenticated method
      custom: {
        signatureVerified: true,
        algorithm: this.config.algorithm,
        timestamp: timestamp2 ? parseInt(timestamp2, 10) : void 0
      }
    };
    return {
      valid: true,
      context
    };
  }
}
function createSignatureValidator(config) {
  return new SignatureValidator(config);
}
const signaturePresets = {
  /**
   * GitHub webhook signature format
   * Header: X-Hub-Signature-256
   * Format: sha256=<signature>
   */
  github: (secret) => ({
    secret,
    algorithm: "sha256",
    signatureHeader: "x-hub-signature-256",
    signaturePrefix: "sha256=",
    payloadFormat: "body",
    timestampTolerance: 0
    // GitHub doesn't use timestamps
  }),
  /**
   * Stripe webhook signature format
   * Header: Stripe-Signature
   * Format: t=<timestamp>,v1=<signature>
   */
  stripe: (secret) => ({
    secret,
    algorithm: "sha256",
    signatureHeader: "stripe-signature",
    timestampHeader: "stripe-signature",
    // Timestamp is in the signature header
    payloadFormat: "custom",
    customPayloadBuilder: (timestamp2, body) => `${timestamp2}.${body}`
    // Note: Stripe parsing requires extracting timestamp from header
    // This is a simplified version - full Stripe support would need custom parsing
  }),
  /**
   * Slack webhook signature format
   * Headers: X-Slack-Signature, X-Slack-Request-Timestamp
   * Format: v0=<signature>
   */
  slack: (secret) => ({
    secret,
    algorithm: "sha256",
    signatureHeader: "x-slack-signature",
    timestampHeader: "x-slack-request-timestamp",
    signaturePrefix: "v0=",
    payloadFormat: "custom",
    customPayloadBuilder: (timestamp2, body) => `v0:${timestamp2}:${body}`,
    timestampTolerance: 300
  }),
  /**
   * Generic/default webhook signature format
   * Used by Conductor and many custom implementations
   */
  default: (secret) => ({
    secret,
    algorithm: "sha256",
    signatureHeader: "x-webhook-signature",
    timestampHeader: "x-webhook-timestamp",
    signaturePrefix: "sha256=",
    payloadFormat: "timestamp.body",
    timestampTolerance: 300
  })
};
function parseCredentials(credential) {
  const colonIndex = credential.indexOf(":");
  if (colonIndex === -1) {
    return null;
  }
  return {
    username: credential.substring(0, colonIndex),
    password: credential.substring(colonIndex + 1)
  };
}
class BasicAuthValidator {
  constructor(config) {
    this.realm = config.realm || "Conductor API";
    const credentialList = Array.isArray(config.credentials) ? config.credentials : [config.credentials];
    this.credentials = credentialList.map(parseCredentials).filter((c) => c !== null);
    if (this.credentials.length === 0) {
      throw new Error(
        'BasicAuthValidator: No valid credentials provided. Format: "username:password"'
      );
    }
  }
  /**
   * Extract base64-encoded credentials from Authorization header
   */
  extractToken(request) {
    const authHeader = request.headers.get("Authorization");
    if (!authHeader?.startsWith("Basic ")) {
      return null;
    }
    return authHeader.substring(6);
  }
  /**
   * Validate basic auth credentials
   */
  async validate(request, _env) {
    const token = this.extractToken(request);
    if (!token) {
      return {
        valid: false,
        error: "invalid_token",
        message: "Missing or invalid Authorization header. Expected: Basic <base64-credentials>"
      };
    }
    let decoded;
    try {
      decoded = atob(token);
    } catch {
      return {
        valid: false,
        error: "invalid_token",
        message: "Invalid base64 encoding in Authorization header"
      };
    }
    const provided = parseCredentials(decoded);
    if (!provided) {
      return {
        valid: false,
        error: "invalid_token",
        message: "Invalid credential format. Expected: username:password"
      };
    }
    let matchedUsername = null;
    for (const valid of this.credentials) {
      const [usernameMatch, passwordMatch] = await Promise.all([
        timingSafeEqual(provided.username, valid.username),
        timingSafeEqual(provided.password, valid.password)
      ]);
      if (usernameMatch && passwordMatch) {
        matchedUsername = valid.username;
        break;
      }
    }
    if (!matchedUsername) {
      return {
        valid: false,
        error: "invalid_token",
        message: "Invalid username or password"
      };
    }
    const context = {
      authenticated: true,
      method: "basic",
      user: {
        id: matchedUsername,
        metadata: {
          authMethod: "basic",
          realm: this.realm
        }
      }
    };
    return {
      valid: true,
      context
    };
  }
  /**
   * Get WWW-Authenticate header value for 401 responses
   */
  getWWWAuthenticateHeader() {
    return `Basic realm="${this.realm}", charset="UTF-8"`;
  }
}
function createBasicValidator(configOrCredentials) {
  if (typeof configOrCredentials === "string" || Array.isArray(configOrCredentials)) {
    return new BasicAuthValidator({ credentials: configOrCredentials });
  }
  return new BasicAuthValidator(configOrCredentials);
}
function createBasicValidatorFromEnv(env) {
  const credentials = env.BASIC_AUTH_CREDENTIALS;
  if (!credentials) {
    return null;
  }
  const credentialList = credentials.includes(",") ? credentials.split(",").map((c) => c.trim()) : [credentials];
  return new BasicAuthValidator({ credentials: credentialList });
}
const logger = createLogger({ serviceName: "trigger-auth" });
class SimpleBearerValidator {
  constructor(secret) {
    this.secret = secret;
  }
  extractToken(request) {
    const authHeader = request.headers.get("Authorization");
    if (!authHeader?.startsWith("Bearer ")) {
      return null;
    }
    return authHeader.substring(7);
  }
  async validate(request, _env) {
    const token = this.extractToken(request);
    if (!token) {
      return {
        valid: false,
        error: "invalid_token",
        message: "Missing or invalid Authorization header. Expected: Bearer <token>"
      };
    }
    const isValid2 = await timingSafeEqual(token, this.secret);
    if (!isValid2) {
      return {
        valid: false,
        error: "invalid_token",
        message: "Invalid bearer token"
      };
    }
    return {
      valid: true,
      context: {
        authenticated: true,
        method: "bearer",
        token
      }
    };
  }
}
function resolveEnvSecret(value, env) {
  if (!value || typeof value !== "string") {
    return value;
  }
  const shorthandMatch = value.match(/^\$env\.(\w+)$/);
  if (shorthandMatch) {
    const varName = shorthandMatch[1];
    const resolved = env?.[varName];
    if (resolved === void 0) {
      logger.warn(`Environment variable '${varName}' not found`, { varName });
    }
    return resolved ?? value;
  }
  const templateMatch = value.match(/^\$\{env\.(\w+)\}$/);
  if (templateMatch) {
    const varName = templateMatch[1];
    const resolved = env?.[varName];
    if (resolved === void 0) {
      logger.warn(`Environment variable '${varName}' not found`, { varName });
    }
    return resolved ?? value;
  }
  return value;
}
async function getValidatorForTrigger(config, env) {
  const resolvedSecret = resolveEnvSecret(config.secret, env);
  switch (config.type) {
    case "bearer":
      if (env.JWT_SECRET) {
        return new BearerValidator({
          secret: env.JWT_SECRET,
          issuer: env.JWT_ISSUER,
          audience: env.JWT_AUDIENCE
        });
      }
      if (!resolvedSecret) {
        throw new Error("Bearer auth requires a secret");
      }
      return new SimpleBearerValidator(resolvedSecret);
    case "signature":
      if (!resolvedSecret) {
        throw new Error("Signature auth requires a secret");
      }
      if (config.preset) {
        const presetConfig = signaturePresets[config.preset](resolvedSecret);
        return createSignatureValidator(presetConfig);
      }
      return createSignatureValidator({
        secret: resolvedSecret,
        algorithm: config.algorithm || "sha256",
        signatureHeader: config.signatureHeader,
        timestampHeader: config.timestampHeader,
        timestampTolerance: config.timestampTolerance
      });
    case "basic":
      if (!resolvedSecret) {
        throw new Error("Basic auth requires credentials (format: username:password)");
      }
      return createBasicValidator({
        credentials: resolvedSecret,
        realm: config.realm
      });
    case "apiKey": {
      const validator = createApiKeyValidator(env);
      if (!validator) {
        throw new Error("API key auth requires API_KEYS KV namespace to be configured");
      }
      return validator;
    }
    case "unkey": {
      const { createUnkeyValidator: createUnkeyValidator2 } = await Promise.resolve().then(() => unkey);
      const validator = createUnkeyValidator2(env);
      if (!validator) {
        throw new Error("Unkey auth requires UNKEY_ROOT_KEY to be configured");
      }
      return validator;
    }
    default: {
      const unknownType2 = config.type;
      throw new Error(`Unknown trigger auth type: ${unknownType2}`);
    }
  }
}
function createTriggerAuthMiddleware(authConfig, env) {
  return async (c, next) => {
    const validator = await getValidatorForTrigger(authConfig, env);
    const request = c.req.raw;
    try {
      const result = await validator.validate(request, env);
      if (!result.valid) {
        const status = result.error === "expired" ? 401 : 401;
        const response = {
          error: result.error || "unauthorized",
          message: result.message || "Authentication failed"
        };
        if (authConfig.type === "basic" && validator instanceof BasicAuthValidator) {
          c.header("WWW-Authenticate", validator.getWWWAuthenticateHeader());
        }
        if (result.ratelimit) {
          c.header("X-RateLimit-Remaining", result.ratelimit.remaining.toString());
          c.header("X-RateLimit-Limit", result.ratelimit.limit.toString());
          c.header("X-RateLimit-Reset", result.ratelimit.reset.toString());
        }
        return c.json(response, status);
      }
      if (result.context) {
        c.set("auth", result.context);
        c.set("authenticated", true);
        if (result.context.user) {
          c.set("user", result.context.user);
          c.set("userId", result.context.user.id);
        }
        if (result.context.custom) {
          c.set("authCustom", result.context.custom);
        }
      }
      await next();
    } catch (error) {
      logger.error("Validation error", error instanceof Error ? error : void 0, {
        authType: authConfig.type
      });
      return c.json(
        {
          error: "auth_error",
          message: error instanceof Error ? error.message : "Authentication error"
        },
        500
      );
    }
  };
}
function validateTriggerAuthConfig(config) {
  const errors = [];
  if (!config.type) {
    errors.push("Auth type is required");
    return errors;
  }
  const validTypes = ["bearer", "signature", "basic", "apiKey", "unkey"];
  if (!validTypes.includes(config.type)) {
    errors.push(`Invalid auth type: ${config.type}. Valid types: ${validTypes.join(", ")}`);
  }
  switch (config.type) {
    case "bearer":
    case "basic":
      if (!config.secret) {
        errors.push(`${config.type} auth requires a secret`);
      }
      break;
    case "signature":
      if (!config.secret) {
        errors.push("signature auth requires a secret");
      }
      if (config.algorithm && !["sha256", "sha1", "sha384", "sha512"].includes(config.algorithm)) {
        errors.push(`Invalid signature algorithm: ${config.algorithm}`);
      }
      if (config.preset && !["github", "stripe", "slack", "default"].includes(config.preset)) {
        errors.push(`Invalid signature preset: ${config.preset}`);
      }
      break;
  }
  return errors;
}
function hasPermission(userPermissions, requiredPermission) {
  if (!requiredPermission) {
    return true;
  }
  if (!userPermissions || userPermissions.length === 0) {
    return false;
  }
  for (const userPerm of userPermissions) {
    if (matchesPermission(userPerm, requiredPermission)) {
      return true;
    }
  }
  return false;
}
function matchesPermission(userPerm, required) {
  if (userPerm === required) {
    return true;
  }
  if (userPerm === "*") {
    return true;
  }
  const userParts = userPerm.split(":");
  const requiredParts = required.split(":");
  if (userParts.length === 2 && userParts[1] === "*") {
    return requiredParts[0] === userParts[0];
  }
  if (userParts.length === 3 && requiredParts.length === 3) {
    const [userResource, userName, userAction] = userParts;
    const [reqResource, reqName, reqAction] = requiredParts;
    if (userResource !== reqResource && userResource !== "*") {
      return false;
    }
    if (userAction !== reqAction && userAction !== "*") {
      return false;
    }
    if (userName === "*") {
      return true;
    }
    if (userName.includes("*")) {
      return matchesGlob(userName, reqName);
    }
    return userName === reqName;
  }
  return false;
}
function matchesGlob(pattern, value) {
  const regexPattern = pattern.replace(/[.+?^${}()|[\]\\]/g, "\\$&").replace(/\*/g, ".*");
  const regex = new RegExp(`^${regexPattern}$`);
  return regex.test(value);
}
function hasAnyPermission(userPermissions, requiredPermissions) {
  return requiredPermissions.some((perm) => hasPermission(userPermissions, perm));
}
function hasAllPermissions(userPermissions, requiredPermissions) {
  return requiredPermissions.every((perm) => hasPermission(userPermissions, perm));
}
function getMissingPermissions(userPermissions, requiredPermissions) {
  return requiredPermissions.filter((perm) => !hasPermission(userPermissions, perm));
}
function normalizePermission(permission) {
  return permission.toLowerCase().trim();
}
function isValidPermissionFormat(permission) {
  if (permission === "*") {
    return true;
  }
  const parts = permission.split(":");
  if (parts.length < 2 || parts.length > 3) {
    return false;
  }
  return parts.every((part) => part.length > 0);
}
function parsePermission(permission) {
  if (permission === "*") {
    return { resource: "*", name: "*", action: "*" };
  }
  const parts = permission.split(":");
  if (parts.length === 2) {
    return { resource: parts[0], name: parts[1], action: "*" };
  }
  if (parts.length === 3) {
    return { resource: parts[0], name: parts[1], action: parts[2] };
  }
  return null;
}
function buildPermission(resource, name, action = "execute") {
  return `${resource}:${name}:${action}`;
}
class UnifiedRouter {
  constructor(config = {}) {
    this.routes = [];
    this.validators = /* @__PURE__ */ new Map();
    this.config = config;
    this.customValidatorRegistry = new CustomValidatorRegistry();
  }
  /**
   * Initialize validators from environment
   */
  async init(env) {
    const bearer = createBearerValidator(env);
    if (bearer) this.validators.set("bearer", bearer);
    const apiKey = createApiKeyValidator(env);
    if (apiKey) this.validators.set("apiKey", apiKey);
    const cookie = createCookieValidator(env);
    if (cookie) this.validators.set("cookie", cookie);
    const unkey2 = createUnkeyValidator(env);
    if (unkey2) this.validators.set("unkey", unkey2);
    this.customValidatorRegistry = createCustomValidatorRegistry(env);
  }
  /**
   * Register a route
   */
  register(options) {
    let pattern = options.pattern;
    let path = options.path || options.pattern;
    if (pattern === "default" || pattern === "auto") {
      if (options.memberPath) {
        pattern = this.resolveDefaultPath(options.memberPath, options.operation);
        path = pattern;
      } else {
        pattern = `/${options.operation}s/${options.agentName}`;
        path = pattern;
      }
    }
    const route = {
      pattern,
      path,
      methods: options.methods,
      operation: options.operation,
      agentName: options.agentName,
      auth: options.auth,
      priority: options.priority,
      handler: options.handler
    };
    this.routes.push(route);
    this.routes.sort((a, b) => {
      const aPrio = a.priority ?? this.getDefaultPriority(a.operation);
      const bPrio = b.priority ?? this.getDefaultPriority(b.operation);
      if (aPrio !== bPrio) return aPrio - bPrio;
      const aStatic = !a.pattern.includes(":") && !a.pattern.includes("*");
      const bStatic = !b.pattern.includes(":") && !b.pattern.includes("*");
      if (aStatic && !bStatic) return -1;
      if (!aStatic && bStatic) return 1;
      return b.pattern.length - a.pattern.length;
    });
  }
  /**
   * Resolve default path from agent directory structure
   */
  resolveDefaultPath(memberPath, operation) {
    let path = memberPath.replace(/\.(yaml|yml|ts|js|tsx|jsx)$/, "").replace(/\/(agent|page|ensemble|form|api)$/, "");
    const prefixes = [
      "/pages/",
      "/agents/",
      "/ensembles/",
      "/forms/",
      "/apis/",
      "/webhooks/",
      "/docs/"
    ];
    for (const prefix of prefixes) {
      if (path.startsWith(prefix)) {
        path = path.substring(prefix.length - 1);
        break;
      }
    }
    if (!path.startsWith("/")) {
      path = "/" + path;
    }
    if (path.endsWith("/index")) {
      path = path.substring(0, path.length - 6) || "/";
    }
    return path;
  }
  /**
   * Get default priority for agent type
   */
  getDefaultPriority(operation) {
    const priorities = {
      static: 1,
      health: 2,
      auth: 3,
      api: 50,
      webhook: 60,
      docs: 70,
      form: 90
    };
    return priorities[operation] || 100;
  }
  /**
   * Match route pattern
   */
  matchPattern(pattern, path) {
    pattern = pattern.replace(/\/+$/, "") || "/";
    path = path.replace(/\/+$/, "") || "/";
    if (pattern.endsWith("*")) {
      const prefix = pattern.slice(0, -1);
      if (path.startsWith(prefix)) {
        return {};
      }
      return null;
    }
    if (!pattern.includes(":")) {
      return pattern === path ? {} : null;
    }
    const patternParts = pattern.split("/");
    const pathParts = path.split("/");
    if (patternParts.length !== pathParts.length) {
      return null;
    }
    const params = {};
    for (let i = 0; i < patternParts.length; i++) {
      const patternPart = patternParts[i];
      const pathPart = pathParts[i];
      if (patternPart.startsWith(":")) {
        const paramName = patternPart.slice(1);
        params[paramName] = decodeURIComponent(pathPart);
      } else if (patternPart !== pathPart) {
        return null;
      }
    }
    return params;
  }
  /**
   * Find matching route
   */
  match(path, method) {
    for (const route of this.routes) {
      if (!route.methods.includes(method) && !route.methods.includes("*")) {
        continue;
      }
      const params = this.matchPattern(route.pattern, path);
      if (params === null) {
        continue;
      }
      const auth = this.resolveAuthConfig(route.pattern, route.operation, route.auth);
      return {
        pattern: route.pattern,
        params,
        auth,
        operation: route.operation,
        priority: route.priority ?? this.getDefaultPriority(route.operation)
      };
    }
    return null;
  }
  /**
   * Resolve auth config by merging defaults and rules
   */
  resolveAuthConfig(path, operation, memberAuth) {
    let resolved = {};
    let source = "global-default";
    if (this.config.routing?.auth?.global) {
      resolved = { ...this.config.routing.auth.global };
    }
    const typeDefaults = this.config.routing?.auth?.defaults;
    if (typeDefaults) {
      const typeKeyMap = {
        api: "api",
        webhook: "webhooks",
        form: "forms",
        docs: "docs",
        static: "api",
        // Use api default for static
        health: "api",
        // Use api default for health
        auth: "api"
        // Use api default for auth
      };
      const typeKey = typeKeyMap[operation];
      if (typeKey && typeDefaults[typeKey]) {
        resolved = { ...resolved, ...typeDefaults[typeKey] };
        source = "type-default";
      }
    }
    const rules = this.config.routing?.auth?.rules || [];
    for (const rule of rules) {
      if (this.matchPattern(rule.pattern, path)) {
        resolved = { ...resolved, ...rule.auth };
        if (rule.rateLimit) {
          resolved.rateLimit = rule.rateLimit;
        }
        source = "rule";
        break;
      }
    }
    if (memberAuth) {
      resolved = { ...resolved, ...memberAuth };
      source = "agent";
    }
    if (!resolved.requirement) {
      resolved.requirement = "required";
    }
    return {
      requirement: resolved.requirement,
      methods: resolved.methods,
      permissions: resolved.permissions,
      roles: resolved.roles,
      serviceAccountOnly: resolved.serviceAccountOnly,
      stealthMode: resolved.stealthMode,
      customValidator: resolved.customValidator,
      onFailure: resolved.onFailure,
      auditLog: resolved.auditLog,
      source,
      rateLimit: resolved.rateLimit
    };
  }
  /**
   * Authenticate request
   */
  async authenticate(request, env, auth) {
    if (auth.requirement === "public") {
      return {
        valid: true,
        context: {
          authenticated: false,
          method: void 0
        }
      };
    }
    const methods = auth.methods || ["bearer", "apiKey", "cookie"];
    if (auth.customValidator) {
      const validator = this.customValidatorRegistry.get(auth.customValidator);
      if (validator) {
        const result = await validator.validate(request, env);
        if (result.valid) return result;
      }
    }
    for (const method of methods) {
      const validator = this.validators.get(method);
      if (!validator) continue;
      const result = await validator.validate(request, env);
      if (result.valid) {
        if (auth.serviceAccountOnly && result.context?.unkey?.isServiceAccount !== true) {
          continue;
        }
        if (auth.permissions && auth.permissions.length > 0) {
          const userPerms = result.context?.user?.permissions || [];
          const hasPerms = auth.permissions.every((p) => userPerms.includes(p));
          if (!hasPerms) {
            return {
              valid: false,
              error: "insufficient_permissions",
              message: "Insufficient permissions"
            };
          }
        }
        if (auth.roles && auth.roles.length > 0) {
          const userRoles = result.context?.user?.roles || [];
          const hasRoles = auth.roles.some((r) => userRoles.includes(r));
          if (!hasRoles) {
            return {
              valid: false,
              error: "insufficient_permissions",
              message: "Insufficient role"
            };
          }
        }
        return result;
      }
    }
    if (auth.requirement === "optional") {
      return {
        valid: true,
        context: {
          authenticated: false,
          method: void 0
        }
      };
    }
    return {
      valid: false,
      error: "invalid_token",
      message: "Authentication required"
    };
  }
  /**
   * Handle request
   */
  async handle(request, env, ctx) {
    const url = new URL(request.url);
    const path = url.pathname;
    const method = request.method;
    const match = this.match(path, method);
    if (!match) {
      return null;
    }
    const authResult = await this.authenticate(request, env, match.auth);
    if (!authResult.valid) {
      return this.handleAuthFailure(authResult, match.auth);
    }
    const route = this.routes.find((r) => r.pattern === match.pattern);
    if (!route?.handler) {
      return null;
    }
    return await route.handler(request, env, ctx, authResult.context);
  }
  /**
   * Handle auth failure
   */
  handleAuthFailure(authResult, auth) {
    if (auth.stealthMode) {
      return new Response("Not Found", { status: 404 });
    }
    if (auth.onFailure) {
      if (auth.onFailure.action === "redirect") {
        const location = auth.onFailure.redirectTo || "/login";
        return Response.redirect(location, 302);
      }
    }
    const status = authResult.error === "insufficient_permissions" ? 403 : 401;
    return new Response(
      JSON.stringify({
        error: authResult.error,
        message: authResult.message
      }),
      {
        status,
        headers: { "Content-Type": "application/json" }
      }
    );
  }
}
class BuildManager {
  constructor(logger2) {
    this.ensembles = /* @__PURE__ */ new Map();
    this.logger = logger2 || createLogger({ serviceName: "build-manager" });
  }
  /**
   * Register ensemble with build triggers
   */
  register(ensemble) {
    const buildTriggers = ensemble.trigger?.filter((t) => t.type === "build") || [];
    if (buildTriggers.length === 0) {
      return;
    }
    this.ensembles.set(ensemble.name, ensemble);
  }
  /**
   * Register multiple ensembles at once
   */
  registerAll(ensembles) {
    for (const ensemble of ensembles) {
      this.register(ensemble);
    }
  }
  /**
   * Run all build triggers
   * Called during `conductor build` or deploy
   */
  async runBuildTriggers(env, ctx, options) {
    const results = [];
    let ensemblesToRun = Array.from(this.ensembles.values());
    if (options?.filter && options.filter.length > 0) {
      ensemblesToRun = ensemblesToRun.filter((e) => options.filter.includes(e.name));
    }
    if (ensemblesToRun.length === 0) {
      this.logger.info("No build triggers to run");
      return results;
    }
    this.logger.info(`Running ${ensemblesToRun.length} build trigger(s)`, {
      ensembles: ensemblesToRun.map((e) => e.name),
      dryRun: options?.dryRun
    });
    const executor = new Executor({ env, ctx });
    for (const ensemble of ensemblesToRun) {
      const buildTriggers = ensemble.trigger?.filter((t) => t.type === "build") || [];
      for (const trigger of buildTriggers) {
        if (trigger.enabled === false) {
          this.logger.debug(`Skipping disabled build trigger for ${ensemble.name}`);
          continue;
        }
        if (options?.dryRun) {
          this.logger.info(`[DRY RUN] Would run build trigger for ${ensemble.name}`, {
            output: trigger.output,
            input: trigger.input
          });
          results.push({
            ensemble: ensemble.name,
            success: true,
            duration: 0,
            outputPath: trigger.output
          });
          continue;
        }
        const startTime = Date.now();
        try {
          const input = {
            ...trigger.input || {},
            _build: {
              triggeredAt: Date.now(),
              output: trigger.output,
              metadata: trigger.metadata
            }
          };
          const result = await executor.executeEnsemble(ensemble, input);
          const duration = Date.now() - startTime;
          if (result.success) {
            this.logger.info(`Build trigger completed for ${ensemble.name}`, {
              durationMs: duration,
              outputPath: trigger.output
            });
            results.push({
              ensemble: ensemble.name,
              success: true,
              duration,
              output: result.value?.output,
              outputPath: trigger.output
            });
          } else {
            this.logger.error(`Build trigger failed for ${ensemble.name}`, void 0, {
              durationMs: duration,
              error: result.error?.message
            });
            results.push({
              ensemble: ensemble.name,
              success: false,
              duration,
              error: result.error?.message || "Unknown error",
              outputPath: trigger.output
            });
          }
        } catch (error) {
          const duration = Date.now() - startTime;
          const errorMessage = error instanceof Error ? error.message : "Unknown error";
          this.logger.error(
            `Build trigger error for ${ensemble.name}`,
            error instanceof Error ? error : void 0,
            { durationMs: duration }
          );
          results.push({
            ensemble: ensemble.name,
            success: false,
            duration,
            error: errorMessage,
            outputPath: trigger.output
          });
        }
      }
    }
    const successful = results.filter((r) => r.success).length;
    const failed = results.filter((r) => !r.success).length;
    this.logger.info("Build triggers completed", {
      total: results.length,
      successful,
      failed
    });
    return results;
  }
  /**
   * List all ensembles with build triggers
   */
  listBuildEnsembles() {
    const buildEnsembles = [];
    for (const ensemble of this.ensembles.values()) {
      const buildTriggers = ensemble.trigger?.filter((t) => t.type === "build") || [];
      if (buildTriggers.length > 0) {
        buildEnsembles.push({
          ensembleName: ensemble.name,
          triggers: buildTriggers
        });
      }
    }
    return buildEnsembles;
  }
  /**
   * Get count of registered ensembles with build triggers
   */
  getBuildCount() {
    return this.ensembles.size;
  }
  /**
   * Clear all registered ensembles
   */
  clear() {
    this.ensembles.clear();
  }
}
let globalBuildManager = null;
function getBuildManager() {
  if (!globalBuildManager) {
    globalBuildManager = new BuildManager();
  }
  return globalBuildManager;
}
function resetBuildManager() {
  globalBuildManager = null;
}
class CLIManager {
  constructor(logger2) {
    this.commands = /* @__PURE__ */ new Map();
    this.logger = logger2 || createLogger({ serviceName: "cli-manager" });
  }
  /**
   * Register ensemble with CLI triggers
   */
  register(ensemble) {
    const cliTriggers = ensemble.trigger?.filter((t) => t.type === "cli") || [];
    for (const trigger of cliTriggers) {
      if (trigger.enabled === false) continue;
      if (this.commands.has(trigger.command)) {
        this.logger.warn(`CLI command "${trigger.command}" already registered, overwriting`);
      }
      this.commands.set(trigger.command, { ensemble, trigger });
      this.logger.debug(`Registered CLI command: ${trigger.command}  ${ensemble.name}`);
    }
  }
  /**
   * Register multiple ensembles at once
   */
  registerAll(ensembles) {
    for (const ensemble of ensembles) {
      this.register(ensemble);
    }
  }
  /**
   * Check if a command is registered
   */
  hasCommand(command) {
    return this.commands.has(command);
  }
  /**
   * Get command metadata
   */
  getCommandMetadata(command) {
    const entry = this.commands.get(command);
    if (!entry) return null;
    return {
      command: entry.trigger.command,
      description: entry.trigger.description,
      options: entry.trigger.options || [],
      ensembleName: entry.ensemble.name
    };
  }
  /**
   * Run a CLI command
   */
  async runCommand(command, options, env, ctx) {
    const entry = this.commands.get(command);
    if (!entry) {
      return {
        command,
        ensemble: "",
        success: false,
        duration: 0,
        error: `Command not found: ${command}`
      };
    }
    const { ensemble, trigger } = entry;
    const startTime = Date.now();
    this.logger.info(`Running CLI command: ${command}`, {
      ensemble: ensemble.name,
      options
    });
    try {
      const parsedOptions = this.parseOptions(trigger.options || [], options);
      const input = {
        ...parsedOptions,
        _cli: {
          command,
          triggeredAt: Date.now(),
          options: parsedOptions
        }
      };
      const executor = new Executor({ env, ctx });
      const result = await executor.executeEnsemble(ensemble, input);
      const duration = Date.now() - startTime;
      if (result.success) {
        this.logger.info(`CLI command completed: ${command}`, {
          durationMs: duration
        });
        return {
          command,
          ensemble: ensemble.name,
          success: true,
          duration,
          output: result.value?.output
        };
      } else {
        this.logger.error(`CLI command failed: ${command}`, void 0, {
          durationMs: duration,
          error: result.error?.message
        });
        return {
          command,
          ensemble: ensemble.name,
          success: false,
          duration,
          error: result.error?.message || "Unknown error"
        };
      }
    } catch (error) {
      const duration = Date.now() - startTime;
      const errorMessage = error instanceof Error ? error.message : "Unknown error";
      this.logger.error(
        `CLI command error: ${command}`,
        error instanceof Error ? error : void 0,
        { durationMs: duration }
      );
      return {
        command,
        ensemble: ensemble.name,
        success: false,
        duration,
        error: errorMessage
      };
    }
  }
  /**
   * Parse and validate command options
   */
  parseOptions(definitions, provided) {
    const result = {};
    for (const def of definitions) {
      const value = provided[def.name];
      if (value === void 0) {
        if (def.required) {
          throw new Error(`Missing required option: --${def.name}`);
        }
        if (def.default !== void 0) {
          result[def.name] = def.default;
        }
        continue;
      }
      switch (def.type) {
        case "number":
          const num = Number(value);
          if (isNaN(num)) {
            throw new Error(`Option --${def.name} must be a number`);
          }
          result[def.name] = num;
          break;
        case "boolean":
          result[def.name] = value === true || value === "true" || value === "1" || value === "yes";
          break;
        default:
          result[def.name] = String(value);
      }
    }
    for (const [key, value] of Object.entries(provided)) {
      if (!(key in result)) {
        result[key] = value;
      }
    }
    return result;
  }
  /**
   * List all registered CLI commands
   */
  listCommands() {
    const commands = [];
    for (const [command, entry] of this.commands) {
      commands.push({
        command,
        description: entry.trigger.description,
        options: entry.trigger.options || [],
        ensembleName: entry.ensemble.name
      });
    }
    return commands.sort((a, b) => a.command.localeCompare(b.command));
  }
  /**
   * Get count of registered commands
   */
  getCommandCount() {
    return this.commands.size;
  }
  /**
   * Clear all registered commands
   */
  clear() {
    this.commands.clear();
  }
}
let globalCLIManager = null;
function getCLIManager() {
  if (!globalCLIManager) {
    globalCLIManager = new CLIManager();
  }
  return globalCLIManager;
}
function resetCLIManager() {
  globalCLIManager = null;
}
function isLifecyclePlugin(plugin) {
  return typeof plugin === "object" && "initialize" in plugin;
}
function isFunctionalPlugin(plugin) {
  return typeof plugin === "function";
}
function buildPlugin(factory) {
  return factory;
}
class DocsManager {
  constructor(config = {}) {
    this.cache = /* @__PURE__ */ new Map();
    this.config = {
      cacheEnabled: config.cacheEnabled ?? true,
      handlebarsEnabled: config.handlebarsEnabled ?? true
    };
    this.handlebars = new HandlebarsTemplateEngine();
  }
  /**
   * Register a docs template in cache
   */
  register(template2) {
    const key = template2.name;
    this.cache.set(key, template2);
  }
  /**
   * Get a docs template from cache
   */
  get(name) {
    return this.cache.get(name) || null;
  }
  /**
   * Check if docs template exists in cache
   */
  has(name) {
    return this.cache.has(name);
  }
  /**
   * List all cached docs templates
   */
  list() {
    return Array.from(this.cache.values()).map((template2) => ({
      name: template2.name,
      title: template2.metadata?.title
    }));
  }
  /**
   * Clear cache
   */
  clearCache() {
    this.cache.clear();
  }
  /**
   * Render markdown with Handlebars
   */
  async render(template2, options) {
    let content = template2.content;
    if (this.config.handlebarsEnabled && !options?.skipHandlebars) {
      const variables = options?.variables || {};
      content = await this.handlebars.render(content, variables);
    }
    return {
      content,
      metadata: template2.metadata
    };
  }
  /**
   * Render docs by name from cache
   */
  async renderByName(name, options) {
    const template2 = this.get(name);
    if (!template2) {
      throw new Error(`Docs template not found: ${name}`);
    }
    return this.render(template2, options);
  }
  /**
   * Load docs from markdown string
   *
   * Supports optional YAML frontmatter:
   * ---
   * title: Getting Started
   * description: Quick start guide
   * ---
   * # Content here
   */
  loadFromMarkdown(markdown, name) {
    const { content, metadata } = this.parseFrontmatter(markdown);
    const template2 = {
      name,
      content,
      metadata
    };
    if (this.config.cacheEnabled) {
      this.register(template2);
    }
    return template2;
  }
  /**
   * Parse YAML frontmatter from markdown
   */
  parseFrontmatter(markdown) {
    const frontmatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/;
    const match = markdown.match(frontmatterRegex);
    if (!match) {
      return { content: markdown };
    }
    const [, frontmatterYaml, content] = match;
    try {
      const metadata = {};
      const lines = frontmatterYaml.split("\n");
      for (const line of lines) {
        const colonIndex = line.indexOf(":");
        if (colonIndex === -1) continue;
        const key = line.substring(0, colonIndex).trim();
        const value = line.substring(colonIndex + 1).trim();
        metadata[key] = value.replace(/^["']|["']$/g, "");
      }
      return { content, metadata };
    } catch (error) {
      console.warn("Failed to parse frontmatter, using raw markdown:", error);
      return { content: markdown };
    }
  }
  /**
   * Register a custom Handlebars helper
   */
  registerHelper(name, fn) {
    this.handlebars.registerHelper(name, fn);
  }
  /**
   * Register a Handlebars partial
   */
  registerPartial(name, template2) {
    this.handlebars.registerPartial(name, template2);
  }
}
let globalManager = null;
function getGlobalDocsManager(config) {
  if (!globalManager) {
    globalManager = new DocsManager(config);
  }
  return globalManager;
}
createLogger({ serviceName: "docs-loader" });
function step(name, options = {}) {
  const {
    operation,
    script,
    config,
    input,
    condition,
    when,
    id,
    depends_on,
    retry,
    timeout,
    onTimeout,
    cache: cache2,
    scoring,
    state
  } = options;
  const agentStep2 = {
    agent: name
  };
  if (id !== void 0) agentStep2.id = id;
  if (input !== void 0) agentStep2.input = input;
  if (condition !== void 0) agentStep2.condition = condition;
  if (when !== void 0) agentStep2.when = when;
  if (depends_on !== void 0) agentStep2.depends_on = depends_on;
  if (retry !== void 0) agentStep2.retry = retry;
  if (timeout !== void 0) agentStep2.timeout = timeout;
  if (onTimeout !== void 0) agentStep2.onTimeout = onTimeout;
  if (cache2 !== void 0) agentStep2.cache = cache2;
  if (scoring !== void 0) agentStep2.scoring = scoring;
  if (state !== void 0) agentStep2.state = state;
  if (operation !== void 0 || script !== void 0 || config !== void 0) {
    agentStep2.operation = operation;
    agentStep2.script = script;
    agentStep2.config = config;
  }
  return agentStep2;
}
function sequence(...steps) {
  return steps;
}
function scriptStep(name, scriptPath, options = {}) {
  return step(name, {
    ...options,
    operation: "code",
    script: scriptPath
  });
}
function httpStep(name, url, options = {}) {
  const { method, headers, body, ...stepOptions } = options;
  const config = {
    url,
    method: method ?? "GET"
  };
  if (headers) config.headers = headers;
  if (body !== void 0) config.body = body;
  return step(name, {
    ...stepOptions,
    operation: "http",
    config
  });
}
function thinkStep(name, prompt2, options = {}) {
  const { model, provider, temperature, maxTokens, systemPrompt, ...stepOptions } = options;
  return step(name, {
    ...stepOptions,
    operation: "think",
    config: {
      prompt: prompt2,
      ...model && { model },
      ...provider && { provider },
      ...temperature !== void 0 && { temperature },
      ...maxTokens && { maxTokens },
      ...systemPrompt && { systemPrompt }
    }
  });
}
function storageStep(name, action, options = { binding: "" }) {
  const { binding, type, key, value, prefix, ...stepOptions } = options;
  return step(name, {
    ...stepOptions,
    operation: "storage",
    config: {
      action,
      binding,
      ...type && { type },
      ...key && { key },
      ...value !== void 0 && { value },
      ...prefix && { prefix }
    }
  });
}
function dataStep(name, query, options = { binding: "" }) {
  const { binding, type, params, ...stepOptions } = options;
  return step(name, {
    ...stepOptions,
    operation: "data",
    config: {
      query,
      binding,
      ...type && { type },
      ...params && { params }
    }
  });
}
function emailStep(name, options) {
  const { to, subject, body, from, template: template2, ...stepOptions } = options;
  return step(name, {
    ...stepOptions,
    operation: "email",
    config: {
      to,
      ...subject && { subject },
      ...body && { body },
      ...from && { from },
      ...template2 && { template: template2 }
    }
  });
}
function agentStep(agentName, options = {}) {
  return step(agentName, options);
}
function parallel(steps, options = {}) {
  return {
    type: "parallel",
    steps,
    waitFor: options.waitFor ?? "all"
  };
}
function branch(condition, options) {
  return {
    type: "branch",
    condition,
    then: options.then,
    ...options.else && { else: options.else }
  };
}
function ifThen(condition, steps) {
  return branch(condition, { then: steps });
}
function ifThenElse(condition, thenSteps, elseSteps) {
  return branch(condition, { then: thenSteps, else: elseSteps });
}
function foreach(items, stepToExecute, options = {}) {
  return {
    type: "foreach",
    items,
    step: stepToExecute,
    ...options.maxConcurrency && { maxConcurrency: options.maxConcurrency },
    ...options.breakWhen !== void 0 && { breakWhen: options.breakWhen }
  };
}
function tryStep(steps, options = {}) {
  return {
    type: "try",
    steps,
    ...options.catch && { catch: options.catch },
    ...options.finally && { finally: options.finally }
  };
}
function switchStep(value, cases, defaultCase) {
  return {
    type: "switch",
    value,
    cases,
    ...defaultCase && { default: defaultCase }
  };
}
function whileStep(condition, steps, options = {}) {
  return {
    type: "while",
    condition,
    steps,
    maxIterations: options.maxIterations ?? 100
    // Default safety limit
  };
}
function doWhile(steps, condition, options = {}) {
  return [
    ...steps,
    // Execute once
    whileStep(condition, steps, options)
    // Then loop if condition is true
  ];
}
function doUntil(steps, condition, options = {}) {
  const negatedCondition = typeof condition === "string" ? `!(${condition})` : { $not: condition };
  return [...steps, whileStep(negatedCondition, steps, options)];
}
function mapReduce(items, mapStep, reduceStep, options = {}) {
  return {
    type: "map-reduce",
    items,
    map: mapStep,
    reduce: reduceStep,
    ...options.maxConcurrency && { maxConcurrency: options.maxConcurrency }
  };
}
function map(items, stepToExecute, options = {}) {
  return foreach(items, stepToExecute, options);
}
function repeat(count, steps) {
  return {
    type: "foreach",
    items: `\${Array.from({length: ${count}}, (_, i) => i)}`,
    step: steps.length === 1 ? steps[0] : { type: "parallel", steps, waitFor: "all" }
  };
}
function race(steps) {
  return parallel(steps, { waitFor: "first" });
}
function fallback(steps) {
  if (steps.length === 0) {
    throw new Error("fallback requires at least one step");
  }
  if (steps.length === 1) {
    return steps[0];
  }
  let result = steps[steps.length - 1];
  for (let i = steps.length - 2; i >= 0; i--) {
    result = tryStep([steps[i]], { catch: [result] });
  }
  return result;
}
class Tool {
  constructor(config) {
    this.config = config;
    if (config.type === "custom" || config.type === "http") {
      this.name = config.definition.name;
      this.description = config.definition.description;
      this.parameters = config.definition.parameters;
      this.metadata = config.definition.metadata;
    } else if (config.type === "mcp") {
      this.name = config.name ?? "mcp-server";
      this.description = `MCP Server: ${config.url ?? config.name}`;
    } else if (config.type === "skill") {
      this.name = config.tool ?? config.skill;
      this.description = `Skill: ${config.skill}`;
    } else {
      this.name = "unknown";
      this.description = "Unknown tool type";
    }
  }
  /**
   * Check if this is an MCP server tool
   */
  isMCP() {
    return this.config.type === "mcp";
  }
  /**
   * Check if this is a custom tool
   */
  isCustom() {
    return this.config.type === "custom";
  }
  /**
   * Check if this is an HTTP tool
   */
  isHTTP() {
    return this.config.type === "http";
  }
  /**
   * Check if this is a skill reference
   */
  isSkill() {
    return this.config.type === "skill";
  }
  /**
   * Convert to plain config object
   */
  toConfig() {
    return this.config;
  }
}
function mcpTool(config) {
  return new Tool({ type: "mcp", ...config });
}
function customTool(options) {
  return new Tool({
    type: "custom",
    definition: {
      name: options.name,
      description: options.description,
      parameters: options.parameters,
      metadata: options.metadata
    },
    handler: options.handler,
    execute: options.execute
  });
}
function httpTool(options) {
  return new Tool({
    type: "http",
    definition: {
      name: options.name,
      description: options.description,
      parameters: options.parameters,
      metadata: options.metadata
    },
    url: options.url,
    method: options.method,
    headers: options.headers,
    auth: options.auth
  });
}
function skillTool(options) {
  return new Tool({
    type: "skill",
    skill: options.skill,
    tool: options.tool,
    config: options.config
  });
}
function createTool(config) {
  return new Tool(config);
}
function toolCollection(options) {
  return {
    name: options.name,
    tools: options.tools.map((t) => t instanceof Tool ? t.toConfig() : t),
    timeout: options.timeout,
    maxConcurrent: options.maxConcurrent,
    retry: options.retry
  };
}
function isTool(value) {
  return value instanceof Tool;
}
function isToolConfig(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const config = value;
  return ["mcp", "custom", "http", "skill"].includes(config.type);
}
class Instruction {
  constructor(config) {
    this.name = config.name;
    this.source = config.source;
    this.role = config.role ?? "system";
    this.priority = config.priority ?? 0;
    this.when = config.when;
    this.variables = config.variables;
    this.cache = config.cache ?? false;
  }
  /**
   * Check if this is an inline instruction
   */
  isInline() {
    return this.source.type === "inline";
  }
  /**
   * Check if this is a file-based instruction
   */
  isFile() {
    return this.source.type === "file";
  }
  /**
   * Check if this is a template instruction
   */
  isTemplate() {
    return this.source.type === "template";
  }
  /**
   * Check if this is a dynamic instruction
   */
  isDynamic() {
    return this.source.type === "dynamic";
  }
  /**
   * Get the raw content (for inline instructions)
   */
  getContent() {
    if (this.source.type === "inline") {
      return this.source.content;
    }
    return void 0;
  }
  /**
   * Get the file path (for file instructions)
   */
  getFilePath() {
    if (this.source.type === "file") {
      return this.source.path;
    }
    return void 0;
  }
  /**
   * Convert to plain config object
   */
  toConfig() {
    return {
      name: this.name,
      source: this.source,
      role: this.role,
      priority: this.priority,
      when: typeof this.when === "string" ? this.when : void 0,
      variables: this.variables,
      cache: this.cache
    };
  }
}
function instruction(content, options) {
  return new Instruction({
    ...options,
    source: { type: "inline", content }
  });
}
function systemInstruction(content, options) {
  return new Instruction({
    ...options,
    source: { type: "inline", content },
    role: "system"
  });
}
function userInstruction(content, options) {
  return new Instruction({
    ...options,
    source: { type: "inline", content },
    role: "user"
  });
}
function assistantInstruction(content, options) {
  return new Instruction({
    ...options,
    source: { type: "inline", content },
    role: "assistant"
  });
}
function fileInstruction(path, options) {
  return new Instruction({
    ...options,
    source: { type: "file", path }
  });
}
function templateInstruction(name, variables, options) {
  return new Instruction({
    ...options,
    source: { type: "template", name, variables }
  });
}
function dynamicInstruction(generator, options) {
  return new Instruction({
    ...options,
    source: { type: "dynamic", generator }
  });
}
function conditionalInstruction(condition, content, options) {
  return new Instruction({
    ...options,
    source: { type: "inline", content },
    when: condition
  });
}
function combineInstructions(instructions) {
  return [...instructions].sort((a, b) => b.priority - a.priority);
}
function prompt(config) {
  const instructions = [];
  if (config.system) {
    if (typeof config.system === "string") {
      instructions.push(systemInstruction(config.system, { priority: 100 }));
    } else {
      instructions.push(config.system);
    }
  }
  if (config.examples) {
    config.examples.forEach((example, index) => {
      instructions.push(userInstruction(example.user, { priority: 50 - index }));
      instructions.push(assistantInstruction(example.assistant, { priority: 50 - index }));
    });
  }
  if (config.user) {
    if (typeof config.user === "string") {
      instructions.push(userInstruction(config.user, { priority: 0 }));
    } else {
      instructions.push(config.user);
    }
  }
  if (config.additional) {
    instructions.push(...config.additional);
  }
  return combineInstructions(instructions);
}
function isInstruction(value) {
  return value instanceof Instruction;
}
function isInstructionConfig(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const config = value;
  return typeof config.source === "object" && config.source !== null;
}
class Memory {
  constructor(config) {
    this.provider = config.provider;
    this.scope = config.scope ?? "agent";
    this.maxEntries = config.maxEntries;
    this.evictionPolicy = config.evictionPolicy ?? "lru";
    this.defaultTTL = config.defaultTTL;
    this.summarize = config.summarize ?? false;
    this.summarizeThreshold = config.summarizeThreshold ?? 100;
  }
  /**
   * Check if using KV storage
   */
  isKV() {
    return this.provider.type === "kv";
  }
  /**
   * Check if using R2 storage
   */
  isR2() {
    return this.provider.type === "r2";
  }
  /**
   * Check if using D1 storage
   */
  isD1() {
    return this.provider.type === "d1";
  }
  /**
   * Check if using Vectorize
   */
  isVectorize() {
    return this.provider.type === "vectorize";
  }
  /**
   * Check if using Durable Objects
   */
  isDurableObject() {
    return this.provider.type === "durable-object";
  }
  /**
   * Convert to plain config object
   */
  toConfig() {
    return {
      provider: this.provider,
      scope: this.scope,
      maxEntries: this.maxEntries,
      evictionPolicy: this.evictionPolicy,
      defaultTTL: this.defaultTTL,
      summarize: this.summarize,
      summarizeThreshold: this.summarizeThreshold
    };
  }
}
function memory(config) {
  return new Memory(config);
}
function kvMemory(config, options) {
  return new Memory({
    ...options,
    provider: { type: "kv", ...config }
  });
}
function r2Memory(config, options) {
  return new Memory({
    ...options,
    provider: { type: "r2", ...config }
  });
}
function d1Memory(config, options) {
  return new Memory({
    ...options,
    provider: { type: "d1", ...config }
  });
}
function vectorMemory(config, options) {
  return new Memory({
    ...options,
    provider: { type: "vectorize", ...config }
  });
}
function durableMemory(config, options) {
  return new Memory({
    ...options,
    provider: { type: "durable-object", ...config }
  });
}
function customMemory(config, options) {
  return new Memory({
    ...options,
    provider: { type: "custom", ...config }
  });
}
function isMemory(value) {
  return value instanceof Memory;
}
function isMemoryConfig(value) {
  if (typeof value !== "object" || value === null) {
    return false;
  }
  const config = value;
  return typeof config.provider === "object" && config.provider !== null;
}
function conversationMemory(options) {
  return kvMemory(
    {
      binding: options.binding,
      prefix: "conversation/",
      defaultTTL: options.ttl
    },
    {
      scope: "session",
      maxEntries: options.maxMessages,
      evictionPolicy: "fifo",
      summarize: options.summarizeAfter !== void 0,
      summarizeThreshold: options.summarizeAfter
    }
  );
}
function knowledgeBase(options) {
  return vectorMemory({
    binding: options.vectorBinding,
    model: options.model ?? "@cf/baai/bge-base-en-v1.5",
    dimensions: options.dimensions ?? 768,
    metric: "cosine"
  });
}
class Reference {
  constructor(source, path, options) {
    this.__isReference = true;
    this.source = source;
    this.path = path;
    this.defaultValue = options?.default;
    this.transform = options?.transform;
    this.required = options?.required ?? false;
    this.type = options?.type;
  }
  /**
   * Get the full reference path (source.path)
   */
  getFullPath() {
    return `${this.source}.${this.path}`;
  }
  /**
   * Convert to string expression for YAML/serialization
   */
  toExpression() {
    return `\${${this.getFullPath()}}`;
  }
  /**
   * Convert to plain config object
   */
  toConfig() {
    const config = {
      ref: this.getFullPath()
    };
    if (this.defaultValue !== void 0) {
      config.default = this.defaultValue;
    }
    if (this.required) {
      config.required = true;
    }
    if (this.type) {
      config.type = this.type;
    }
    return config;
  }
}
function ref(path, options) {
  const parts = path.split(".");
  const source = parts[0];
  const restPath = parts.slice(1).join(".");
  const validSources = ["input", "state", "env", "steps", "context", "output"];
  if (!validSources.includes(source)) {
    throw new Error(
      `Invalid reference source: ${source}. Must be one of: ${validSources.join(", ")}`
    );
  }
  return new Reference(source, restPath, options);
}
function inputRef(path, options) {
  return new Reference("input", path, options);
}
function stateRef(path, options) {
  return new Reference("state", path, options);
}
function envRef(path, options) {
  return new Reference("env", path, options);
}
function stepRef(stepName, path, options) {
  const fullPath = path ? `${stepName}.${path}` : stepName;
  return new Reference("steps", fullPath, options);
}
function contextRef(path, options) {
  return new Reference("context", path, options);
}
function outputRef(path, options) {
  return new Reference("output", path, options);
}
function isReference(value) {
  return value instanceof Reference || typeof value === "object" && value !== null && "__isReference" in value;
}
function computed(refs, compute) {
  return {
    refs,
    compute,
    __isComputed: true
  };
}
function isComputed(value) {
  return typeof value === "object" && value !== null && "__isComputed" in value;
}
function template(strings, ...values) {
  const refs = [];
  let result = strings[0];
  values.forEach((value, i) => {
    if (isReference(value)) {
      refs.push(value);
      result += value.toExpression();
    } else {
      result += String(value);
    }
    result += strings[i + 1];
  });
  return {
    template: result,
    refs,
    __isTemplate: true
  };
}
function isTemplate(value) {
  return typeof value === "object" && value !== null && "__isTemplate" in value;
}
function parseRef(expression) {
  const match = expression.match(/^\$\{(.+)\}$/);
  if (!match) {
    return null;
  }
  try {
    return ref(match[1]);
  } catch {
    return null;
  }
}
function isRefExpression(value) {
  return typeof value === "string" && /^\$\{.+\}$/.test(value);
}
function refMap(paths, defaultOptions2) {
  const result = {};
  for (const [key, path] of Object.entries(paths)) {
    result[key] = ref(path, defaultOptions2);
  }
  return result;
}
function suspend(config) {
  return {
    type: "suspend",
    reason: config.reason,
    message: config.message,
    data: config.data,
    timeout: config.timeout,
    onResume: config.onResume,
    onTimeout: config.onTimeout
  };
}
function sleep(duration, options) {
  return {
    type: "sleep",
    duration,
    durable: options?.durable,
    reason: options?.reason
  };
}
function sleepSeconds(seconds, options) {
  return sleep(seconds * 1e3, options);
}
function sleepMinutes(minutes, options) {
  return sleep(minutes * 60 * 1e3, options);
}
function sleepUntil(time, options) {
  const targetTime = typeof time === "string" ? new Date(time) : time;
  const now = /* @__PURE__ */ new Date();
  const duration = Math.max(0, targetTime.getTime() - now.getTime());
  return {
    type: "sleep",
    duration,
    durable: options?.durable ?? true,
    // Default to durable for absolute times
    reason: options?.reason ?? `Waiting until ${targetTime.toISOString()}`
  };
}
function schedule(config) {
  return {
    type: "schedule",
    at: config.at,
    cron: config.cron,
    timezone: config.timezone,
    steps: config.steps
  };
}
function approval(config) {
  return {
    type: "approval",
    config: {
      message: config.message,
      approvers: config.approvers,
      timeout: config.timeout,
      timeoutAction: config.timeoutAction,
      data: config.data,
      options: config.options
    },
    onApprove: config.onApprove,
    onReject: config.onReject,
    onTimeout: config.onTimeout
  };
}
function waitForWebhook(config) {
  return {
    type: "suspend",
    reason: "external",
    message: `Waiting for webhook event: ${config.event ?? "any"}`,
    data: {
      webhookConfig: {
        path: config.path,
        event: config.event,
        schema: config.schema,
        secret: config.secret
      }
    },
    timeout: config.timeout,
    onResume: config.onReceive,
    onTimeout: config.onTimeout
  };
}
function waitForInput(config) {
  return {
    type: "suspend",
    reason: "input",
    message: config.message,
    data: {
      inputConfig: {
        fields: config.fields
      }
    },
    timeout: config.timeout,
    onResume: config.onInput,
    onTimeout: config.onTimeout
  };
}
function checkpoint(config) {
  return {
    type: "suspend",
    reason: "manual",
    message: `Checkpoint: ${config.name}`,
    data: {
      checkpoint: config.name,
      ...config.data
    }
  };
}
function isSuspendStep(step2) {
  return typeof step2 === "object" && step2 !== null && step2.type === "suspend";
}
function isSleepStep(step2) {
  return typeof step2 === "object" && step2 !== null && step2.type === "sleep";
}
function isScheduleStep(step2) {
  return typeof step2 === "object" && step2 !== null && step2.type === "schedule";
}
function isApprovalStep(step2) {
  return typeof step2 === "object" && step2 !== null && step2.type === "approval";
}
function isAsyncStep(step2) {
  return isSuspendStep(step2) || isSleepStep(step2) || isScheduleStep(step2) || isApprovalStep(step2);
}
function createConductorHandler(config) {
  return {
    async fetch(request, env, ctx) {
      return new Response("Conductor initialized - handler implementation coming soon", {
        headers: { "content-type": "text/plain" }
      });
    }
  };
}
const workerEntry = {};
export {
  thinkStep as $,
  APIAgent as A,
  BaseAgent as B,
  CLIManager as C,
  DataAgent as D,
  Executor as E,
  FunctionAgent as F,
  GraphExecutor as G,
  HttpMiddlewareRegistry as H,
  ResumeToken as I,
  CacheKey as J,
  isLifecyclePlugin as K,
  isFunctionalPlugin as L,
  MemberLoader as M,
  buildPlugin as N,
  OperationRegistry as O,
  Parser$1 as P,
  DocsManager as Q,
  Result as R,
  StateManager as S,
  TriggerRegistry as T,
  UnifiedRouter as U,
  VersionString as V,
  getGlobalDocsManager as W,
  step as X,
  sequence as Y,
  scriptStep as Z,
  httpStep as _,
  createConductorHandler as a,
  outputRef as a$,
  storageStep as a0,
  dataStep as a1,
  emailStep as a2,
  agentStep as a3,
  parallel as a4,
  race as a5,
  branch as a6,
  ifThen as a7,
  ifThenElse as a8,
  switchStep as a9,
  fileInstruction as aA,
  templateInstruction as aB,
  dynamicInstruction as aC,
  conditionalInstruction as aD,
  combineInstructions as aE,
  prompt as aF,
  Instruction as aG,
  isInstruction as aH,
  isInstructionConfig as aI,
  memory as aJ,
  kvMemory as aK,
  r2Memory as aL,
  d1Memory as aM,
  vectorMemory as aN,
  durableMemory as aO,
  customMemory as aP,
  conversationMemory as aQ,
  knowledgeBase as aR,
  Memory as aS,
  isMemory as aT,
  isMemoryConfig as aU,
  ref as aV,
  inputRef as aW,
  stateRef as aX,
  envRef as aY,
  stepRef as aZ,
  contextRef as a_,
  foreach as aa,
  map as ab,
  repeat as ac,
  whileStep as ad,
  doWhile as ae,
  doUntil as af,
  tryStep as ag,
  fallback as ah,
  mapReduce as ai,
  createEnsemble as aj,
  Ensemble as ak,
  isEnsemble as al,
  ensembleFromConfig as am,
  createTool as an,
  mcpTool as ao,
  customTool as ap,
  httpTool as aq,
  skillTool as ar,
  toolCollection as as,
  Tool as at,
  isTool as au,
  isToolConfig as av,
  instruction as aw,
  systemInstruction as ax,
  userInstruction as ay,
  assistantInstruction as az,
  PluginRegistry as b,
  buildPermission as b$,
  computed as b0,
  template as b1,
  parseRef as b2,
  refMap as b3,
  Reference as b4,
  isReference as b5,
  isComputed as b6,
  isTemplate as b7,
  isRefExpression as b8,
  suspend as b9,
  ApiKeyValidator as bA,
  createApiKeyValidator as bB,
  CookieValidator as bC,
  createCookieValidator as bD,
  UnkeyValidator as bE,
  createUnkeyValidator as bF,
  StripeSignatureValidator as bG,
  GitHubSignatureValidator as bH,
  TwilioSignatureValidator as bI,
  CustomValidatorRegistry as bJ,
  createCustomValidatorRegistry as bK,
  SignatureValidator as bL,
  createSignatureValidator as bM,
  signaturePresets as bN,
  BasicAuthValidator as bO,
  createBasicValidator as bP,
  createBasicValidatorFromEnv as bQ,
  getValidatorForTrigger as bR,
  createTriggerAuthMiddleware as bS,
  validateTriggerAuthConfig as bT,
  hasPermission as bU,
  hasAnyPermission as bV,
  hasAllPermissions as bW,
  getMissingPermissions as bX,
  normalizePermission as bY,
  isValidPermissionFormat as bZ,
  parsePermission as b_,
  checkpoint as ba,
  sleep as bb,
  sleepSeconds as bc,
  sleepMinutes as bd,
  sleepUntil as be,
  schedule as bf,
  approval as bg,
  waitForWebhook as bh,
  waitForInput as bi,
  isSuspendStep as bj,
  isSleepStep as bk,
  isScheduleStep as bl,
  isApprovalStep as bm,
  isAsyncStep as bn,
  isParallelStep as bo,
  isAgentStep$1 as bp,
  isBranchStep as bq,
  isForeachStep as br,
  isTryStep as bs,
  isSwitchStep as bt,
  isWhileStep as bu,
  isMapReduceStep as bv,
  isFlowControlStep as bw,
  isControlFlowStep as bx,
  BearerValidator as by,
  createBearerValidator as bz,
  createLogger as c,
  getOperationRegistry as d,
  getTriggerRegistry as e,
  getHttpMiddlewareRegistry as f,
  getPluginRegistry as g,
  hasControlFlowSteps as h,
  ThinkAgent as i,
  createLoader as j,
  EnsembleLoader as k,
  createEnsembleLoader as l,
  BuildManager as m,
  getBuildManager as n,
  getCLIManager as o,
  resetCLIManager as p,
  ModelId as q,
  resetBuildManager as r,
  AgentName as s,
  EnsembleName as t,
  ProviderId as u,
  PlatformName as v,
  workerEntry as w,
  BindingName as x,
  ExecutionId as y,
  RequestId as z
};
//# sourceMappingURL=worker-entry-CSZwFgwd.js.map
