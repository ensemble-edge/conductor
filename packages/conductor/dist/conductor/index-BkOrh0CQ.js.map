{"version":3,"file":"index-BkOrh0CQ.js","sources":["../../src/agents/built-in/validate/evaluators/base-evaluator.ts","../../src/agents/built-in/validate/evaluators/rule-evaluator.ts","../../src/agents/built-in/validate/evaluators/judge-evaluator.ts","../../src/agents/built-in/validate/evaluators/nlp-evaluator.ts","../../src/agents/built-in/validate/evaluators/embedding-evaluator.ts","../../src/agents/built-in/validate/validate-agent.ts"],"sourcesContent":["/**\n * Base Evaluator - Abstract class for all evaluators\n */\n\nimport type { EvaluationScore, ValidateConfig } from '../types.js'\n\nexport abstract class BaseEvaluator {\n  /**\n   * Evaluate content and return scores\n   */\n  abstract evaluate(content: string, config: ValidateConfig): Promise<EvaluationScore>\n\n  /**\n   * Normalize score to 0-1 range\n   */\n  protected normalizeScore(score: number, min: number = 0, max: number = 1): number {\n    return Math.max(min, Math.min(max, score))\n  }\n\n  /**\n   * Calculate weighted average of scores\n   */\n  protected calculateWeightedAverage(\n    scores: Record<string, number>,\n    weights: Record<string, number>\n  ): number {\n    let totalWeight = 0\n    let weightedSum = 0\n\n    for (const [key, score] of Object.entries(scores)) {\n      const weight = weights[key] || 1\n      weightedSum += score * weight\n      totalWeight += weight\n    }\n\n    return totalWeight > 0 ? weightedSum / totalWeight : 0\n  }\n}\n","/**\n * Rule Evaluator - Custom rule-based validation\n *\n * Executes JavaScript expressions as validation rules\n */\n\nimport { BaseEvaluator } from './base-evaluator.js'\nimport type { EvaluationScore, Rule, ValidateConfig } from '../types.js'\n\nexport class RuleEvaluator extends BaseEvaluator {\n  async evaluate(content: string, config: ValidateConfig): Promise<EvaluationScore> {\n    const rules: Rule[] = config.rules || []\n\n    if (rules.length === 0) {\n      throw new Error('Rule evaluator requires at least one rule in config')\n    }\n\n    const breakdown: Record<string, number> = {}\n    const weights: Record<string, number> = {}\n    const details: Record<string, unknown> = {}\n\n    for (const rule of rules) {\n      try {\n        // Create a safe evaluation context\n        const context = {\n          content,\n          length: content.length,\n          wordCount: content.split(/\\s+/).length,\n          lineCount: content.split('\\n').length,\n        }\n\n        // Evaluate the rule (safe evaluation)\n        const result = this.evaluateRule(rule.check, context)\n        const score = result ? 1 : 0\n\n        breakdown[rule.name] = score\n        weights[rule.name] = rule.weight\n        details[rule.name] = {\n          passed: result,\n          rule: rule.check,\n          description: rule.description,\n        }\n      } catch (error) {\n        breakdown[rule.name] = 0\n        weights[rule.name] = rule.weight\n        details[rule.name] = {\n          passed: false,\n          error: error instanceof Error ? error.message : 'Unknown error',\n        }\n      }\n    }\n\n    const average = this.calculateWeightedAverage(breakdown, weights)\n\n    return {\n      average,\n      breakdown,\n      details,\n    }\n  }\n\n  /**\n   * Safely evaluate a rule expression\n   */\n  private evaluateRule(\n    expression: string,\n    context: { content: string; length: number; wordCount: number; lineCount: number }\n  ): boolean {\n    // Simple expression evaluation\n    // Replace content references with actual values\n    let evalExpression = expression\n\n    // Replace context variables\n    evalExpression = evalExpression.replace(/content\\.length/g, String(context.content.length))\n    evalExpression = evalExpression.replace(/content\\.wordCount/g, String(context.wordCount))\n    evalExpression = evalExpression.replace(/content\\.lineCount/g, String(context.lineCount))\n    evalExpression = evalExpression.replace(\n      /content\\.includes\\(['\"]([^'\"]+)['\"]\\)/g,\n      (match, keyword) => {\n        return String(context.content.toLowerCase().includes(keyword.toLowerCase()))\n      }\n    )\n\n    // Evaluate the expression using Function constructor (safer than eval)\n    try {\n      // Use Function constructor instead of eval to avoid bundler warnings\n      // This is still a simplified evaluation - in production, use a proper expression parser\n      const fn = new Function('return (' + evalExpression + ')')\n      return Boolean(fn())\n    } catch (error) {\n      return false\n    }\n  }\n}\n","/**\n * Judge Evaluator - LLM-based evaluation\n *\n * Uses an LLM to evaluate content quality based on criteria\n */\n\nimport { BaseEvaluator } from './base-evaluator.js'\nimport type { EvaluationScore, Criterion, ValidateConfig } from '../types.js'\n\nexport class JudgeEvaluator extends BaseEvaluator {\n  async evaluate(content: string, config: ValidateConfig): Promise<EvaluationScore> {\n    const criteria: Criterion[] = config.criteria || []\n    const model = config.model || 'claude-3-5-haiku-20241022'\n\n    if (criteria.length === 0) {\n      throw new Error('Judge evaluator requires at least one criterion in config')\n    }\n\n    // TODO: Integrate with AI provider for LLM-based evaluation\n    // For now, return placeholder scores\n    const breakdown: Record<string, number> = {}\n    const weights: Record<string, number> = {}\n\n    for (const criterion of criteria) {\n      // Placeholder: Random score between 0.5 and 1.0\n      breakdown[criterion.name] = 0.75\n      weights[criterion.name] = criterion.weight\n    }\n\n    const average = this.calculateWeightedAverage(breakdown, weights)\n\n    return {\n      average,\n      breakdown,\n      details: {\n        model,\n        criteria: criteria.map((c) => c.name),\n        note: 'LLM-based evaluation not yet implemented',\n      },\n    }\n  }\n}\n","/**\n * NLP Evaluator - Statistical NLP metrics\n *\n * Calculates BLEU, ROUGE, and other NLP metrics\n */\n\nimport { BaseEvaluator } from './base-evaluator.js'\nimport type { EvaluationScore, ValidateConfig } from '../types.js'\n\nexport class NLPEvaluator extends BaseEvaluator {\n  async evaluate(content: string, config: ValidateConfig): Promise<EvaluationScore> {\n    const reference = config.reference\n\n    if (!reference) {\n      throw new Error('NLP evaluator requires \"reference\" text in config')\n    }\n\n    const metrics = config.metrics || ['bleu', 'rouge']\n    const breakdown: Record<string, number> = {}\n\n    // Calculate each metric\n    for (const metric of metrics) {\n      switch (metric.toLowerCase()) {\n        case 'bleu':\n          breakdown.bleu = this.calculateBLEU(content, reference)\n          break\n        case 'rouge':\n          breakdown.rouge = this.calculateROUGE(content, reference)\n          break\n        case 'length-ratio':\n          breakdown.lengthRatio = this.calculateLengthRatio(content, reference)\n          break\n        default:\n          breakdown[metric] = 0\n      }\n    }\n\n    // Calculate average (all metrics have equal weight)\n    const average =\n      Object.values(breakdown).reduce((sum, score) => sum + score, 0) /\n      Object.keys(breakdown).length\n\n    return {\n      average,\n      breakdown,\n      details: {\n        reference: reference.substring(0, 100) + '...',\n        contentLength: content.length,\n        referenceLength: reference.length,\n      },\n    }\n  }\n\n  /**\n   * Calculate BLEU score (simplified unigram)\n   */\n  private calculateBLEU(candidate: string, reference: string): number {\n    const candidateWords = candidate.toLowerCase().split(/\\s+/)\n    const referenceWords = reference.toLowerCase().split(/\\s+/)\n\n    const referenceSet = new Set(referenceWords)\n    let matches = 0\n\n    for (const word of candidateWords) {\n      if (referenceSet.has(word)) {\n        matches++\n      }\n    }\n\n    const precision = candidateWords.length > 0 ? matches / candidateWords.length : 0\n    return this.normalizeScore(precision)\n  }\n\n  /**\n   * Calculate ROUGE-L score (longest common subsequence)\n   */\n  private calculateROUGE(candidate: string, reference: string): number {\n    const candidateWords = candidate.toLowerCase().split(/\\s+/)\n    const referenceWords = reference.toLowerCase().split(/\\s+/)\n\n    const lcs = this.longestCommonSubsequence(candidateWords, referenceWords)\n    const recall = referenceWords.length > 0 ? lcs / referenceWords.length : 0\n    const precision = candidateWords.length > 0 ? lcs / candidateWords.length : 0\n\n    // F1 score\n    const f1 = recall + precision > 0 ? (2 * recall * precision) / (recall + precision) : 0\n    return this.normalizeScore(f1)\n  }\n\n  /**\n   * Calculate length ratio (how close the lengths are)\n   */\n  private calculateLengthRatio(candidate: string, reference: string): number {\n    const ratio =\n      Math.min(candidate.length, reference.length) / Math.max(candidate.length, reference.length)\n    return this.normalizeScore(ratio)\n  }\n\n  /**\n   * Calculate longest common subsequence length\n   */\n  private longestCommonSubsequence(arr1: string[], arr2: string[]): number {\n    const m = arr1.length\n    const n = arr2.length\n    const dp: number[][] = Array(m + 1)\n      .fill(null)\n      .map(() => Array(n + 1).fill(0))\n\n    for (let i = 1; i <= m; i++) {\n      for (let j = 1; j <= n; j++) {\n        if (arr1[i - 1] === arr2[j - 1]) {\n          dp[i][j] = dp[i - 1][j - 1] + 1\n        } else {\n          dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])\n        }\n      }\n    }\n\n    return dp[m][n]\n  }\n}\n","/**\n * Embedding Evaluator - Semantic similarity using embeddings\n *\n * Uses Cloudflare AI embeddings to calculate semantic similarity\n */\n\nimport { BaseEvaluator } from './base-evaluator.js'\nimport type { EvaluationScore, ValidateConfig } from '../types.js'\n\nexport class EmbeddingEvaluator extends BaseEvaluator {\n  async evaluate(content: string, config: ValidateConfig): Promise<EvaluationScore> {\n    const reference = config.reference\n\n    if (!reference) {\n      throw new Error('Embedding evaluator requires \"reference\" text in config')\n    }\n\n    const model = config.model || '@cf/baai/bge-base-en-v1.5'\n\n    // TODO: Integrate with Cloudflare AI embeddings\n    // For now, return placeholder score based on simple text similarity\n    const similarity = this.calculateSimpleTextSimilarity(content, reference)\n\n    return {\n      average: similarity,\n      breakdown: {\n        semanticSimilarity: similarity,\n      },\n      details: {\n        model,\n        note: 'Using simple text similarity as placeholder for embedding-based similarity',\n      },\n    }\n  }\n\n  /**\n   * Calculate simple text similarity (placeholder for actual embeddings)\n   */\n  private calculateSimpleTextSimilarity(text1: string, text2: string): number {\n    const words1 = new Set(text1.toLowerCase().split(/\\s+/))\n    const words2 = new Set(text2.toLowerCase().split(/\\s+/))\n\n    const intersection = new Set([...words1].filter((x) => words2.has(x)))\n    const union = new Set([...words1, ...words2])\n\n    // Jaccard similarity\n    return union.size > 0 ? intersection.size / union.size : 0\n  }\n\n  /**\n   * Calculate cosine similarity between two vectors\n   */\n  private cosineSimilarity(vec1: number[], vec2: number[]): number {\n    if (vec1.length !== vec2.length) {\n      throw new Error('Vectors must have the same length')\n    }\n\n    let dotProduct = 0\n    let norm1 = 0\n    let norm2 = 0\n\n    for (let i = 0; i < vec1.length; i++) {\n      dotProduct += vec1[i] * vec2[i]\n      norm1 += vec1[i] * vec1[i]\n      norm2 += vec2[i] * vec2[i]\n    }\n\n    norm1 = Math.sqrt(norm1)\n    norm2 = Math.sqrt(norm2)\n\n    if (norm1 === 0 || norm2 === 0) {\n      return 0\n    }\n\n    return dotProduct / (norm1 * norm2)\n  }\n}\n","/**\n * Validate Agent - Validation and Evaluation Framework\n *\n * Pluggable evaluators:\n * - Rule: Custom rule-based validation\n * - Judge: LLM-based quality assessment\n * - NLP: Statistical NLP metrics (BLEU, ROUGE)\n * - Embedding: Semantic similarity via embeddings\n */\n\nimport { BaseAgent, type AgentExecutionContext } from '../../base-agent.js'\nimport type { AgentConfig } from '../../../runtime/parser.js'\nimport type { ValidateConfig, ValidateInput, ValidationResult, EvalType } from './types.js'\nimport { BaseEvaluator } from './evaluators/base-evaluator.js'\nimport { RuleEvaluator } from './evaluators/rule-evaluator.js'\nimport { JudgeEvaluator } from './evaluators/judge-evaluator.js'\nimport { NLPEvaluator } from './evaluators/nlp-evaluator.js'\nimport { EmbeddingEvaluator } from './evaluators/embedding-evaluator.js'\n\nexport class ValidateMember extends BaseAgent {\n  private validateConfig: ValidateConfig\n\n  constructor(\n    config: AgentConfig,\n    private readonly env: Env\n  ) {\n    super(config)\n\n    const cfg = config.config as ValidateConfig | undefined\n\n    this.validateConfig = {\n      evalType: cfg?.evalType || 'rule',\n      threshold: cfg?.threshold !== undefined ? cfg.threshold : 0.7,\n      rules: cfg?.rules,\n      criteria: cfg?.criteria,\n      metrics: cfg?.metrics,\n      reference: cfg?.reference,\n      model: cfg?.model,\n    }\n  }\n\n  protected async run(context: AgentExecutionContext): Promise<ValidationResult> {\n    const input = context.input as ValidateInput\n\n    if (!input.content) {\n      throw new Error('Validate agent requires \"content\" in input')\n    }\n\n    const evalType = this.validateConfig.evalType!\n    const evaluator = this.getEvaluator(evalType)\n\n    // Merge config with input reference if provided\n    const evalConfig = {\n      ...this.validateConfig,\n      reference: input.reference || this.validateConfig.reference,\n    }\n\n    // Evaluate\n    const scores = await evaluator.evaluate(input.content, evalConfig)\n\n    // Check if passed threshold\n    const threshold = this.validateConfig.threshold!\n    const passed = scores.average >= threshold\n\n    return {\n      passed,\n      score: scores.average,\n      scores: scores.breakdown,\n      details: scores.details || {},\n      evalType,\n    }\n  }\n\n  /**\n   * Get the appropriate evaluator based on type\n   */\n  private getEvaluator(type: EvalType): BaseEvaluator {\n    switch (type) {\n      case 'rule':\n        return new RuleEvaluator()\n      case 'judge':\n        return new JudgeEvaluator()\n      case 'nlp':\n        return new NLPEvaluator()\n      case 'embedding':\n        return new EmbeddingEvaluator()\n      default:\n        throw new Error(`Unknown evaluator type: ${type}`)\n    }\n  }\n}\n"],"names":[],"mappings":"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"}