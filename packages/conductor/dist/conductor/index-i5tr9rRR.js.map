{"version":3,"file":"index-i5tr9rRR.js","sources":["../../src/agents/built-in/queries/queries-agent.ts"],"sourcesContent":["/**\n * Queries Agent\n *\n * Execute SQL queries across Hyperdrive-connected databases.\n * Queries can be loaded from catalog (like prompts) or executed inline.\n */\n\nimport { BaseAgent, type AgentExecutionContext } from '../../base-agent.js'\nimport type { AgentConfig } from '../../../runtime/parser.js'\nimport type { ConductorEnv } from '../../../types/env.js'\n\n/**\n * Query input - either from catalog or inline SQL\n */\nexport interface QueriesInput {\n  /**\n   * Query name from catalog (mutually exclusive with sql)\n   */\n  queryName?: string\n\n  /**\n   * Inline SQL query (mutually exclusive with queryName)\n   */\n  sql?: string\n\n  /**\n   * Query parameters (named or positional)\n   */\n  input?: Record<string, unknown> | unknown[]\n\n  /**\n   * Database alias (overrides default)\n   */\n  database?: string\n}\n\n/**\n * Queries configuration\n */\nexport interface QueriesConfig {\n  /**\n   * Default database alias\n   */\n  defaultDatabase?: string\n\n  /**\n   * Cache TTL for query results (seconds)\n   */\n  cacheTTL?: number\n\n  /**\n   * Max rows to return\n   */\n  maxRows?: number\n\n  /**\n   * Query timeout (ms)\n   */\n  timeout?: number\n\n  /**\n   * Read-only mode (prevent writes)\n   */\n  readOnly?: boolean\n\n  /**\n   * Transform column names\n   */\n  transform?: 'none' | 'camelCase' | 'snakeCase'\n\n  /**\n   * Return metadata with results\n   */\n  includeMetadata?: boolean\n}\n\n/**\n * Queries output\n */\nexport interface QueriesOutput {\n  /**\n   * Query results\n   */\n  rows: unknown[]\n\n  /**\n   * Row count\n   */\n  count: number\n\n  /**\n   * Execution metadata\n   */\n  metadata: {\n    /**\n     * Columns returned\n     */\n    columns: string[]\n\n    /**\n     * Execution time (ms)\n     */\n    executionTime: number\n\n    /**\n     * Cache hit?\n     */\n    cached: boolean\n\n    /**\n     * Database used\n     */\n    database: string\n\n    /**\n     * Query that was executed\n     */\n    query?: string\n  }\n}\n\n/**\n * Catalog query definition\n */\ninterface CatalogQuery {\n  name: string\n  sql: string\n  description?: string\n  database?: string\n  params?: Record<string, unknown>\n}\n\n/**\n * Queries Agent - SQL Query Execution\n *\n * Executes SQL queries across Hyperdrive-connected databases.\n * Queries can be stored in catalog like prompts or executed inline.\n */\nexport class QueriesMember extends BaseAgent {\n  private queriesConfig: QueriesConfig\n\n  constructor(\n    config: AgentConfig,\n    private readonly env: ConductorEnv\n  ) {\n    super(config)\n\n    const cfg = config.config as QueriesConfig | undefined\n\n    // Extract queries-specific config\n    this.queriesConfig = {\n      defaultDatabase: cfg?.defaultDatabase,\n      cacheTTL: cfg?.cacheTTL,\n      maxRows: cfg?.maxRows,\n      timeout: cfg?.timeout,\n      readOnly: cfg?.readOnly !== undefined ? cfg.readOnly : false,\n      transform: cfg?.transform || 'none',\n      includeMetadata: cfg?.includeMetadata !== undefined ? cfg.includeMetadata : true,\n    }\n  }\n\n  protected async run(context: AgentExecutionContext): Promise<QueriesOutput> {\n    const input = context.input as QueriesInput\n\n    // 1. Validate input\n    if (!input.queryName && !input.sql) {\n      throw new Error('Either queryName or sql must be provided')\n    }\n\n    if (input.queryName && input.sql) {\n      throw new Error('Cannot specify both queryName and sql')\n    }\n\n    // 2. Resolve query (from catalog or inline)\n    const query = input.queryName\n      ? await this.loadQueryFromCatalog(input.queryName)\n      : { sql: input.sql!, params: {}, database: input.database }\n\n    // 3. Determine database\n    const database = input.database || query.database || this.queriesConfig.defaultDatabase\n    if (!database) {\n      throw new Error('No database specified and no default database configured')\n    }\n\n    // 4. Get Hyperdrive binding (it's actually a D1Database)\n    const hyperdrive = (this.env as unknown as Record<string, unknown>)[database] as D1Database\n    if (!hyperdrive) {\n      throw new Error(`Hyperdrive binding not found: ${database}`)\n    }\n\n    // 5. Validate read-only mode\n    if (this.queriesConfig.readOnly && this.isWriteQuery(query.sql)) {\n      throw new Error('Write operations not allowed in read-only mode')\n    }\n\n    // 6. Prepare parameters\n    const { sql, params } = this.prepareQuery(query.sql, input.input || query.params || {})\n\n    // 7. Execute query\n    const startTime = Date.now()\n    const result = await this.executeQuery(hyperdrive, sql, params)\n    const executionTime = Date.now() - startTime\n\n    // 8. Transform results\n    let rows = result.rows\n    if (this.queriesConfig.transform === 'camelCase') {\n      rows = this.toCamelCase(rows)\n    } else if (this.queriesConfig.transform === 'snakeCase') {\n      rows = this.toSnakeCase(rows)\n    }\n\n    // 9. Apply row limit\n    if (this.queriesConfig.maxRows && rows.length > this.queriesConfig.maxRows) {\n      rows = rows.slice(0, this.queriesConfig.maxRows)\n    }\n\n    // 10. Return result\n    const output: QueriesOutput = {\n      rows,\n      count: rows.length,\n      metadata: {\n        columns: result.columns || [],\n        executionTime,\n        cached: false, // TODO: Implement caching\n        database,\n        ...(this.queriesConfig.includeMetadata && { query: sql }),\n      },\n    }\n\n    return output\n  }\n\n  /**\n   * Load query from catalog\n   */\n  private async loadQueryFromCatalog(queryName: string): Promise<CatalogQuery> {\n    // TODO: Implement catalog integration\n    // For now, throw error - this will be implemented when catalog system is ready\n    throw new Error(\n      `Query catalog not yet implemented. Use inline SQL with 'sql' parameter instead of 'queryName'.`\n    )\n  }\n\n  /**\n   * Prepare query with parameters\n   */\n  private prepareQuery(\n    sql: string,\n    input: Record<string, unknown> | unknown[]\n  ): { sql: string; params: unknown[] } {\n    // If input is an array, assume positional parameters\n    if (Array.isArray(input)) {\n      return { sql, params: input }\n    }\n\n    // Convert named parameters to positional\n    const params: unknown[] = []\n    let paramIndex = 1\n\n    const convertedSql = sql.replace(/:(\\w+)/g, (match, paramName) => {\n      if (!(paramName in input)) {\n        throw new Error(`Missing parameter: ${paramName}`)\n      }\n\n      params.push(input[paramName])\n      return `$${paramIndex++}`\n    })\n\n    return { sql: convertedSql, params }\n  }\n\n  /**\n   * Execute query via Hyperdrive/D1\n   */\n  private async executeQuery(\n    hyperdrive: D1Database,\n    sql: string,\n    params: unknown[]\n  ): Promise<{ rows: unknown[]; columns?: string[] }> {\n    // Prepare statement\n    let stmt = hyperdrive.prepare(sql)\n    if (params.length > 0) {\n      stmt = stmt.bind(...params)\n    }\n\n    // Execute with timeout if configured\n    const executePromise = stmt.all()\n    const result = this.queriesConfig.timeout\n      ? await Promise.race([\n          executePromise,\n          new Promise<never>((_, reject) =>\n            setTimeout(() => reject(new Error('Query timeout')), this.queriesConfig.timeout)\n          ),\n        ])\n      : await executePromise\n\n    // Extract columns from result\n    const columns =\n      result.results.length > 0\n        ? Object.keys(result.results[0])\n        : result.meta?.columns\n          ? (result.meta.columns as Array<{ name: string }>).map((c) => c.name)\n          : []\n\n    return {\n      rows: result.results,\n      columns,\n    }\n  }\n\n  /**\n   * Check if query is a write operation\n   */\n  private isWriteQuery(sql: string): boolean {\n    const upperSQL = sql.trim().toUpperCase()\n    return /^(INSERT|UPDATE|DELETE|DROP|CREATE|ALTER|TRUNCATE|REPLACE)/i.test(upperSQL)\n  }\n\n  /**\n   * Transform object keys to camelCase\n   */\n  private toCamelCase(rows: unknown[]): unknown[] {\n    return rows.map((row) => {\n      const transformed: Record<string, unknown> = {}\n      for (const [key, value] of Object.entries(row as Record<string, unknown>)) {\n        const camelKey = key.replace(/_([a-z])/g, (_, letter) => letter.toUpperCase())\n        transformed[camelKey] = value\n      }\n      return transformed\n    })\n  }\n\n  /**\n   * Transform object keys to snake_case\n   */\n  private toSnakeCase(rows: unknown[]): unknown[] {\n    return rows.map((row) => {\n      const transformed: Record<string, unknown> = {}\n      for (const [key, value] of Object.entries(row as Record<string, unknown>)) {\n        const snakeKey = key.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`)\n        transformed[snakeKey] = value\n      }\n      return transformed\n    })\n  }\n}\n"],"names":[],"mappings":"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"}