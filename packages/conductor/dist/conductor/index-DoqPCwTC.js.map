{"version":3,"file":"index-DoqPCwTC.js","sources":["../../src/agents/built-in/fetch/fetch-agent.ts"],"sourcesContent":["/**\n * Fetch Agent - HTTP Client with Retry Logic\n *\n * Features:\n * - Configurable retry attempts with exponential backoff\n * - Timeout handling\n * - Custom headers support\n * - Multiple HTTP methods\n */\n\nimport { BaseAgent, type AgentExecutionContext } from '../../base-agent.js'\nimport type { AgentConfig } from '../../../runtime/parser.js'\nimport type { FetchConfig, FetchInput, FetchResult } from './types.js'\n\nexport class FetchMember extends BaseAgent {\n  private fetchConfig: FetchConfig\n\n  constructor(\n    config: AgentConfig,\n    private readonly env: Env\n  ) {\n    super(config)\n\n    const cfg = config.config as FetchConfig | undefined\n    this.fetchConfig = {\n      method: cfg?.method || 'GET',\n      headers: cfg?.headers || {},\n      retry: cfg?.retry !== undefined ? cfg.retry : 3,\n      timeout: cfg?.timeout || 30000,\n      retryDelay: cfg?.retryDelay || 1000,\n    }\n  }\n\n  protected async run(context: AgentExecutionContext): Promise<FetchResult> {\n    const input = context.input as FetchInput\n\n    if (!input.url) {\n      throw new Error('Fetch agent requires \"url\" in input')\n    }\n\n    const startTime = Date.now()\n    const maxRetries = this.fetchConfig.retry || 0\n\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n      try {\n        const result = await this.executeRequest(input, attempt)\n        return {\n          ...result,\n          duration: Date.now() - startTime,\n          attempt: attempt + 1,\n        }\n      } catch (error) {\n        // If this is the last attempt, throw the error\n        if (attempt === maxRetries) {\n          throw new Error(\n            `Fetch failed after ${attempt + 1} attempts: ${\n              error instanceof Error ? error.message : 'Unknown error'\n            }`\n          )\n        }\n\n        // Otherwise, wait and retry with exponential backoff\n        const delay = this.fetchConfig.retryDelay! * Math.pow(2, attempt)\n        await this.sleep(delay)\n      }\n    }\n\n    throw new Error('Fetch failed: Maximum retries exceeded')\n  }\n\n  private async executeRequest(\n    input: FetchInput,\n    attempt: number\n  ): Promise<Omit<FetchResult, 'duration' | 'attempt'>> {\n    const url = input.url\n    const method = this.fetchConfig.method || 'GET'\n    const headers = {\n      ...this.fetchConfig.headers,\n      ...input.headers,\n    }\n\n    // Build request options\n    const options: RequestInit = {\n      method,\n      headers,\n      signal: AbortSignal.timeout(this.fetchConfig.timeout!),\n    }\n\n    // Add body for POST/PUT/PATCH\n    if (input.body && ['POST', 'PUT', 'PATCH'].includes(method)) {\n      if (typeof input.body === 'object') {\n        options.body = JSON.stringify(input.body)\n        if (!headers['Content-Type']) {\n          headers['Content-Type'] = 'application/json'\n        }\n      } else {\n        options.body = input.body as string\n      }\n    }\n\n    // Execute request\n    const response = await fetch(url, options)\n\n    // Parse response body\n    const contentType = response.headers.get('content-type') || ''\n    let body: unknown\n\n    if (contentType.includes('application/json')) {\n      body = await response.json()\n    } else if (contentType.includes('text/')) {\n      body = await response.text()\n    } else {\n      body = await response.text() // Default to text\n    }\n\n    // Check for HTTP errors\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`)\n    }\n\n    return {\n      status: response.status,\n      statusText: response.statusText,\n      headers: Object.fromEntries(response.headers.entries()),\n      body,\n    }\n  }\n\n  private sleep(ms: number): Promise<void> {\n    return new Promise((resolve) => setTimeout(resolve, ms))\n  }\n}\n"],"names":[],"mappings":";AAcO,MAAM,oBAAoB,UAAU;AAAA,EAGzC,YACE,QACiB,KACjB;AACA,UAAM,MAAM;AAFK,SAAA,MAAA;AAIjB,UAAM,MAAM,OAAO;AACnB,SAAK,cAAc;AAAA,MACjB,QAAQ,KAAK,UAAU;AAAA,MACvB,SAAS,KAAK,WAAW,CAAA;AAAA,MACzB,OAAO,KAAK,UAAU,SAAY,IAAI,QAAQ;AAAA,MAC9C,SAAS,KAAK,WAAW;AAAA,MACzB,YAAY,KAAK,cAAc;AAAA,IAAA;AAAA,EAEnC;AAAA,EAEA,MAAgB,IAAI,SAAsD;AACxE,UAAM,QAAQ,QAAQ;AAEtB,QAAI,CAAC,MAAM,KAAK;AACd,YAAM,IAAI,MAAM,qCAAqC;AAAA,IACvD;AAEA,UAAM,YAAY,KAAK,IAAA;AACvB,UAAM,aAAa,KAAK,YAAY,SAAS;AAE7C,aAAS,UAAU,GAAG,WAAW,YAAY,WAAW;AACtD,UAAI;AACF,cAAM,SAAS,MAAM,KAAK,eAAe,OAAO,OAAO;AACvD,eAAO;AAAA,UACL,GAAG;AAAA,UACH,UAAU,KAAK,IAAA,IAAQ;AAAA,UACvB,SAAS,UAAU;AAAA,QAAA;AAAA,MAEvB,SAAS,OAAO;AAEd,YAAI,YAAY,YAAY;AAC1B,gBAAM,IAAI;AAAA,YACR,sBAAsB,UAAU,CAAC,cAC/B,iBAAiB,QAAQ,MAAM,UAAU,eAC3C;AAAA,UAAA;AAAA,QAEJ;AAGA,cAAM,QAAQ,KAAK,YAAY,aAAc,KAAK,IAAI,GAAG,OAAO;AAChE,cAAM,KAAK,MAAM,KAAK;AAAA,MACxB;AAAA,IACF;AAEA,UAAM,IAAI,MAAM,wCAAwC;AAAA,EAC1D;AAAA,EAEA,MAAc,eACZ,OACA,SACoD;AACpD,UAAM,MAAM,MAAM;AAClB,UAAM,SAAS,KAAK,YAAY,UAAU;AAC1C,UAAM,UAAU;AAAA,MACd,GAAG,KAAK,YAAY;AAAA,MACpB,GAAG,MAAM;AAAA,IAAA;AAIX,UAAM,UAAuB;AAAA,MAC3B;AAAA,MACA;AAAA,MACA,QAAQ,YAAY,QAAQ,KAAK,YAAY,OAAQ;AAAA,IAAA;AAIvD,QAAI,MAAM,QAAQ,CAAC,QAAQ,OAAO,OAAO,EAAE,SAAS,MAAM,GAAG;AAC3D,UAAI,OAAO,MAAM,SAAS,UAAU;AAClC,gBAAQ,OAAO,KAAK,UAAU,MAAM,IAAI;AACxC,YAAI,CAAC,QAAQ,cAAc,GAAG;AAC5B,kBAAQ,cAAc,IAAI;AAAA,QAC5B;AAAA,MACF,OAAO;AACL,gBAAQ,OAAO,MAAM;AAAA,MACvB;AAAA,IACF;AAGA,UAAM,WAAW,MAAM,MAAM,KAAK,OAAO;AAGzC,UAAM,cAAc,SAAS,QAAQ,IAAI,cAAc,KAAK;AAC5D,QAAI;AAEJ,QAAI,YAAY,SAAS,kBAAkB,GAAG;AAC5C,aAAO,MAAM,SAAS,KAAA;AAAA,IACxB,WAAW,YAAY,SAAS,OAAO,GAAG;AACxC,aAAO,MAAM,SAAS,KAAA;AAAA,IACxB,OAAO;AACL,aAAO,MAAM,SAAS,KAAA;AAAA,IACxB;AAGA,QAAI,CAAC,SAAS,IAAI;AAChB,YAAM,IAAI,MAAM,QAAQ,SAAS,MAAM,KAAK,SAAS,UAAU,EAAE;AAAA,IACnE;AAEA,WAAO;AAAA,MACL,QAAQ,SAAS;AAAA,MACjB,YAAY,SAAS;AAAA,MACrB,SAAS,OAAO,YAAY,SAAS,QAAQ,SAAS;AAAA,MACtD;AAAA,IAAA;AAAA,EAEJ;AAAA,EAEQ,MAAM,IAA2B;AACvC,WAAO,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,EAAE,CAAC;AAAA,EACzD;AACF;"}