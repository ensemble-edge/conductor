{"version":3,"file":"index-Cz8tX4wD.js","sources":["../../src/agents/built-in/hitl/hitl-agent.ts"],"sourcesContent":["/**\n * HITL Agent - Human-in-the-Loop Workflows\n *\n * Features:\n * - Suspend workflow execution for manual approval\n * - Resume execution after approval/rejection\n * - Notification system (Slack, email, webhook)\n * - Timeout handling with auto-expiry\n * - State persistence via Durable Objects\n */\n\nimport { BaseAgent, type AgentExecutionContext } from '../../base-agent.js'\nimport type { AgentConfig } from '../../../runtime/parser.js'\nimport { createLogger } from '../../../observability/index.js'\nimport type {\n  HITLConfig,\n  HITLInput,\n  HITLSuspendInput,\n  HITLResumeInput,\n  HITLResult,\n  HITLSuspendResult,\n  HITLResumeResult,\n  ApprovalState,\n} from './types.js'\n\nconst logger = createLogger({ serviceName: 'hitl-agent' })\n\nexport class HITLMember extends BaseAgent {\n  private hitlConfig: HITLConfig\n\n  constructor(\n    config: AgentConfig,\n    private readonly env: Env\n  ) {\n    super(config)\n\n    const cfg = config.config as HITLConfig | undefined\n\n    this.hitlConfig = {\n      action: cfg?.action || 'suspend',\n      timeout: cfg?.timeout || 86400000, // 24 hours\n      notificationChannel: cfg?.notificationChannel,\n      notificationConfig: cfg?.notificationConfig,\n    }\n  }\n\n  protected async run(context: AgentExecutionContext): Promise<HITLResult> {\n    const action = this.hitlConfig.action!\n\n    switch (action) {\n      case 'suspend':\n        return await this.suspendForApproval(context)\n      case 'resume':\n        return await this.resumeExecution(context)\n      case 'approve':\n        return await this.approveExecution(context)\n      case 'reject':\n        return await this.rejectExecution(context)\n      default:\n        throw new Error(`Unknown HITL action: ${action}`)\n    }\n  }\n\n  /**\n   * Suspend execution and wait for approval\n   */\n  private async suspendForApproval(context: AgentExecutionContext): Promise<HITLSuspendResult> {\n    const input = context.input as HITLSuspendInput\n\n    if (!input.approvalData) {\n      throw new Error('Suspend action requires \"approvalData\" in input')\n    }\n\n    // Generate execution ID\n    const executionId = this.generateExecutionId()\n    const expiresAt = Date.now() + this.hitlConfig.timeout!\n\n    // Store approval state (placeholder - TODO: integrate with Durable Objects)\n    const approvalState: ApprovalState = {\n      executionId,\n      state: context.state || {},\n      suspendedAt: Date.now(),\n      expiresAt,\n      approvalData: input.approvalData,\n      status: 'suspended',\n    }\n\n    // TODO: Store in Durable Object\n    // const approvalDO = this.getApprovalDO(executionId);\n    // await approvalDO.suspend(approvalState);\n\n    // Send notification\n    if (this.hitlConfig.notificationChannel) {\n      await this.sendNotification(executionId, input.approvalData)\n    }\n\n    // Generate callback URL (placeholder - user should configure their base URL)\n    // Default endpoint: POST /callback/:token with { approved: true/false }\n    // Base path is configurable via APIConfig.hitl.resumeBasePath\n    const approvalUrl = `https://your-worker.workers.dev/callback/${executionId}`\n\n    return {\n      status: 'suspended',\n      executionId,\n      approvalUrl,\n      expiresAt,\n    }\n  }\n\n  /**\n   * Resume execution after approval/rejection\n   */\n  private async resumeExecution(context: AgentExecutionContext): Promise<HITLResumeResult> {\n    const input = context.input as HITLResumeInput\n\n    if (!input.executionId) {\n      throw new Error('Resume action requires \"executionId\" in input')\n    }\n\n    // Get approval state (placeholder - TODO: integrate with Durable Objects)\n    // const approvalDO = this.getApprovalDO(input.executionId);\n    // const approvalState = await approvalDO.getState();\n\n    // Placeholder\n    const approvalState: ApprovalState = {\n      executionId: input.executionId,\n      state: {},\n      suspendedAt: Date.now() - 1000,\n      expiresAt: Date.now() + 86400000,\n      approvalData: {},\n      status: input.approved ? 'approved' : 'rejected',\n      comments: input.comments,\n    }\n\n    // Check if expired\n    if (Date.now() > approvalState.expiresAt) {\n      return {\n        status: 'expired',\n        executionId: input.executionId,\n        comments: 'Approval request expired',\n      }\n    }\n\n    // Update state\n    // await approvalDO.resume(input.approved, input.comments);\n\n    return {\n      status: approvalState.status,\n      executionId: input.executionId,\n      state: approvalState.state,\n      comments: input.comments,\n    }\n  }\n\n  /**\n   * Approve execution (shorthand for resume with approved=true)\n   */\n  private async approveExecution(context: AgentExecutionContext): Promise<HITLResumeResult> {\n    const input = context.input as HITLResumeInput\n    return await this.resumeExecution({\n      ...context,\n      input: { ...input, approved: true },\n    })\n  }\n\n  /**\n   * Reject execution (shorthand for resume with approved=false)\n   */\n  private async rejectExecution(context: AgentExecutionContext): Promise<HITLResumeResult> {\n    const input = context.input as HITLResumeInput\n    return await this.resumeExecution({\n      ...context,\n      input: { ...input, approved: false },\n    })\n  }\n\n  /**\n   * Send notification to configured channel\n   */\n  private async sendNotification(\n    executionId: string,\n    approvalData: Record<string, unknown>\n  ): Promise<void> {\n    const channel = this.hitlConfig.notificationChannel\n    const config = this.hitlConfig.notificationConfig || {}\n\n    switch (channel) {\n      case 'slack':\n        await this.sendSlackNotification(executionId, approvalData, config)\n        break\n      case 'email':\n        await this.sendEmailNotification(executionId, approvalData, config)\n        break\n      case 'webhook':\n        await this.sendWebhookNotification(executionId, approvalData, config)\n        break\n    }\n  }\n\n  /**\n   * Send Slack notification\n   */\n  private async sendSlackNotification(\n    executionId: string,\n    approvalData: Record<string, unknown>,\n    config: Record<string, unknown>\n  ): Promise<void> {\n    const webhookUrl = config.webhookUrl\n\n    if (!webhookUrl || typeof webhookUrl !== 'string') {\n      throw new Error('Slack notification requires webhookUrl in notificationConfig')\n    }\n\n    const message = {\n      text: `ðŸ”” Approval Required`,\n      blocks: [\n        {\n          type: 'header',\n          text: {\n            type: 'plain_text',\n            text: 'ðŸ”” Approval Required',\n          },\n        },\n        {\n          type: 'section',\n          text: {\n            type: 'mrkdwn',\n            text: `*Execution ID:* ${executionId}\\n*Data:* ${JSON.stringify(approvalData, null, 2)}`,\n          },\n        },\n        {\n          type: 'actions',\n          elements: [\n            {\n              type: 'button',\n              text: {\n                type: 'plain_text',\n                text: 'Approve',\n              },\n              style: 'primary',\n              // POST /callback/:token with { approved: true }\n              url: `https://your-worker.workers.dev/callback/${executionId}`,\n            },\n            {\n              type: 'button',\n              text: {\n                type: 'plain_text',\n                text: 'Reject',\n              },\n              style: 'danger',\n              // POST /callback/:token with { approved: false }\n              url: `https://your-worker.workers.dev/callback/${executionId}`,\n            },\n          ],\n        },\n      ],\n    }\n\n    await fetch(webhookUrl, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(message),\n    })\n  }\n\n  /**\n   * Send email notification\n   */\n  private async sendEmailNotification(\n    executionId: string,\n    approvalData: Record<string, unknown>,\n    config: Record<string, unknown>\n  ): Promise<void> {\n    // TODO: Implement email notification via Cloudflare Email Workers\n    logger.debug('Email notification not yet implemented', {\n      executionId,\n    })\n  }\n\n  /**\n   * Send webhook notification\n   */\n  private async sendWebhookNotification(\n    executionId: string,\n    approvalData: Record<string, unknown>,\n    config: Record<string, unknown>\n  ): Promise<void> {\n    const webhookUrl = config.webhookUrl\n\n    if (!webhookUrl || typeof webhookUrl !== 'string') {\n      throw new Error('Webhook notification requires webhookUrl in notificationConfig')\n    }\n\n    await fetch(webhookUrl, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({\n        executionId,\n        approvalData,\n        // POST /callback/:token with { approved: true/false }\n        // Base path configurable via APIConfig.hitl.resumeBasePath\n        callbackUrl: `https://your-worker.workers.dev/callback/${executionId}`,\n        expiresAt: Date.now() + this.hitlConfig.timeout!,\n      }),\n    })\n  }\n\n  /**\n   * Generate a cryptographically secure unique execution ID\n   */\n  private generateExecutionId(): string {\n    return `exec_${crypto.randomUUID()}`\n  }\n\n  /**\n   * Get Durable Object for approval state\n   */\n  private getApprovalDO(executionId: string): unknown {\n    // TODO: Integrate with Durable Objects\n    // const doId = this.env.APPROVAL_MANAGER.idFromName(executionId);\n    // return this.env.APPROVAL_MANAGER.get(doId);\n    return null\n  }\n}\n"],"names":[],"mappings":"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"}