{"version":3,"file":"error-types-GY-n8ams.js","names":["values: T[]","errors: E[]","memberName: string","reason: string","cause?: Error","errors: string[]","providerId: string","statusCode: number","response: string","timeoutMs: number","retryAfter?: number","platformName: string","bindingName: string","hint?: string","modelId: string","reason?: string","replacement?: string","eolDate: string","ensembleName: string","step: string","cause: Error","key: string","storageType: string","operation: string"],"sources":["../../src/types/result.ts","../../src/errors/error-types.ts"],"sourcesContent":["/**\n * Result Type for Explicit Error Handling\n *\n * A Result type represents the outcome of an operation that may fail.\n * It forces explicit error handling at compile time, making it impossible\n * to forget to handle errors.\n *\n * @example\n * ```typescript\n * // Function that may fail\n * function findUser(id: string): Result<User, UserNotFoundError> {\n *   const user = database.find(id);\n *   if (!user) {\n *     return Result.err(new UserNotFoundError(id));\n *   }\n *   return Result.ok(user);\n * }\n *\n * // Error handling is explicit and checked\n * const result = findUser('123');\n * if (!result.success) {\n *   console.error('Error:', result.error.message);\n *   return;\n * }\n * const user = result.value; // Type-safe access\n * ```\n */\n\n/**\n * Result type - either success with a value or failure with an error\n */\nexport type Result<T, E = Error> = { success: true; value: T } | { success: false; error: E }\n\n/**\n * Result utilities and constructors\n */\nexport const Result = {\n  /**\n   * Create a successful Result\n   */\n  ok<T>(value: T): Result<T, never> {\n    return { success: true, value }\n  },\n\n  /**\n   * Create a failed Result\n   */\n  err<E>(error: E): Result<never, E> {\n    return { success: false, error }\n  },\n\n  /**\n   * Wrap a Promise to catch errors and return a Result\n   * @example\n   * ```typescript\n   * const result = await Result.fromPromise(\n   *   fetch('https://api.example.com/data')\n   * );\n   * ```\n   */\n  async fromPromise<T>(promise: Promise<T>): Promise<Result<T, Error>> {\n    try {\n      const value = await promise\n      return Result.ok(value)\n    } catch (error) {\n      return Result.err(error instanceof Error ? error : new Error(String(error)))\n    }\n  },\n\n  /**\n   * Wrap a synchronous function to catch errors and return a Result\n   * @example\n   * ```typescript\n   * const result = Result.fromThrowable(() => JSON.parse(input));\n   * ```\n   */\n  fromThrowable<T>(fn: () => T): Result<T, Error> {\n    try {\n      return Result.ok(fn())\n    } catch (error) {\n      return Result.err(error instanceof Error ? error : new Error(String(error)))\n    }\n  },\n\n  /**\n   * Transform the value inside a successful Result\n   * Leaves error Results unchanged\n   * @example\n   * ```typescript\n   * const result = Result.ok(5);\n   * const doubled = Result.map(result, x => x * 2);\n   * // doubled = { success: true, value: 10 }\n   * ```\n   */\n  map<T, U, E>(result: Result<T, E>, fn: (value: T) => U): Result<U, E> {\n    if (result.success) {\n      return Result.ok(fn(result.value))\n    }\n    return result\n  },\n\n  /**\n   * Async version of map\n   */\n  async mapAsync<T, U, E>(\n    result: Result<T, E>,\n    fn: (value: T) => Promise<U>\n  ): Promise<Result<U, E>> {\n    if (result.success) {\n      return Result.ok(await fn(result.value))\n    }\n    return result\n  },\n\n  /**\n   * Transform the error inside a failed Result\n   * Leaves success Results unchanged\n   * @example\n   * ```typescript\n   * const result = Result.err(new Error('failed'));\n   * const wrapped = Result.mapErr(result, e => new CustomError(e));\n   * ```\n   */\n  mapErr<T, E, F>(result: Result<T, E>, fn: (error: E) => F): Result<T, F> {\n    if (result.success) {\n      return result\n    }\n    return Result.err(fn(result.error))\n  },\n\n  /**\n   * Chain Results together (flatMap/bind)\n   * If the first Result is an error, returns it without calling fn\n   * If the first Result is success, calls fn with the value\n   * @example\n   * ```typescript\n   * const result = Result.ok(5);\n   * const chained = Result.flatMap(result, x => {\n   *   if (x > 10) return Result.ok(x);\n   *   return Result.err(new Error('too small'));\n   * });\n   * ```\n   */\n  flatMap<T, U, E>(result: Result<T, E>, fn: (value: T) => Result<U, E>): Result<U, E> {\n    if (result.success) {\n      return fn(result.value)\n    }\n    return result\n  },\n\n  /**\n   * Async version of flatMap\n   */\n  async flatMapAsync<T, U, E>(\n    result: Result<T, E>,\n    fn: (value: T) => Promise<Result<U, E>>\n  ): Promise<Result<U, E>> {\n    if (result.success) {\n      return await fn(result.value)\n    }\n    return result\n  },\n\n  /**\n   * Unwrap a Result, throwing if it's an error\n   * Use sparingly - prefer explicit error handling\n   * @throws The error if Result is failed\n   * @example\n   * ```typescript\n   * const value = Result.unwrap(result); // Throws if error\n   * ```\n   */\n  unwrap<T, E>(result: Result<T, E>): T {\n    if (result.success) {\n      return result.value\n    }\n    throw result.error\n  },\n\n  /**\n   * Unwrap a Result, returning a default value if it's an error\n   * @example\n   * ```typescript\n   * const value = Result.unwrapOr(result, 'default');\n   * ```\n   */\n  unwrapOr<T, E>(result: Result<T, E>, defaultValue: T): T {\n    return result.success ? result.value : defaultValue\n  },\n\n  /**\n   * Unwrap a Result, computing a default value from the error\n   * @example\n   * ```typescript\n   * const value = Result.unwrapOrElse(result, error => {\n   *   console.error('Failed:', error);\n   *   return 'fallback';\n   * });\n   * ```\n   */\n  unwrapOrElse<T, E>(result: Result<T, E>, fn: (error: E) => T): T {\n    return result.success ? result.value : fn(result.error)\n  },\n\n  /**\n   * Check if Result is success\n   */\n  isOk<T, E>(result: Result<T, E>): result is { success: true; value: T } {\n    return result.success === true\n  },\n\n  /**\n   * Check if Result is error\n   */\n  isErr<T, E>(result: Result<T, E>): result is { success: false; error: E } {\n    return result.success === false\n  },\n\n  /**\n   * Combine multiple Results into one\n   * Returns first error, or all values if all succeed\n   * @example\n   * ```typescript\n   * const results = [Result.ok(1), Result.ok(2), Result.ok(3)];\n   * const combined = Result.all(results);\n   * // combined = { success: true, value: [1, 2, 3] }\n   * ```\n   */\n  all<T, E>(results: Result<T, E>[]): Result<T[], E> {\n    const values: T[] = []\n\n    for (const result of results) {\n      if (!result.success) {\n        return result\n      }\n      values.push(result.value)\n    }\n\n    return Result.ok(values)\n  },\n\n  /**\n   * Combine multiple Results, collecting all errors or all values\n   * Unlike `all`, this doesn't short-circuit on first error\n   * @example\n   * ```typescript\n   * const results = [\n   *   Result.ok(1),\n   *   Result.err(new Error('e1')),\n   *   Result.err(new Error('e2'))\n   * ];\n   * const combined = Result.partition(results);\n   * // combined = { success: false, error: [Error('e1'), Error('e2')] }\n   * ```\n   */\n  partition<T, E>(results: Result<T, E>[]): Result<T[], E[]> {\n    const values: T[] = []\n    const errors: E[] = []\n\n    for (const result of results) {\n      if (result.success) {\n        values.push(result.value)\n      } else {\n        errors.push(result.error)\n      }\n    }\n\n    if (errors.length > 0) {\n      return Result.err(errors)\n    }\n\n    return Result.ok(values)\n  },\n\n  /**\n   * Sequence async operations, short-circuiting on first error\n   * @example\n   * ```typescript\n   * const result = await Result.sequence([\n   *   () => validateInput(data),\n   *   () => fetchUser(data.userId),\n   *   () => updateUser(user)\n   * ]);\n   * ```\n   */\n  async sequence<T, E>(operations: Array<() => Promise<Result<T, E>>>): Promise<Result<T[], E>> {\n    const values: T[] = []\n\n    for (const operation of operations) {\n      const result = await operation()\n      if (!result.success) {\n        return result\n      }\n      values.push(result.value)\n    }\n\n    return Result.ok(values)\n  },\n\n  /**\n   * Match on a Result, providing handlers for both cases\n   * @example\n   * ```typescript\n   * const message = Result.match(result, {\n   *   ok: user => `Welcome ${user.name}`,\n   *   err: error => `Error: ${error.message}`\n   * });\n   * ```\n   */\n  match<T, E, R>(\n    result: Result<T, E>,\n    handlers: {\n      ok: (value: T) => R\n      err: (error: E) => R\n    }\n  ): R {\n    if (result.success) {\n      return handlers.ok(result.value)\n    }\n    return handlers.err(result.error)\n  },\n\n  /**\n   * Perform a side effect on success, returning the original Result\n   * @example\n   * ```typescript\n   * const result = Result.ok(user)\n   *   .pipe(Result.tap(u => console.log('Found user:', u.name)));\n   * ```\n   */\n  tap<T, E>(result: Result<T, E>, fn: (value: T) => void): Result<T, E> {\n    if (result.success) {\n      fn(result.value)\n    }\n    return result\n  },\n\n  /**\n   * Perform a side effect on error, returning the original Result\n   * @example\n   * ```typescript\n   * const result = operation()\n   *   .pipe(Result.tapErr(e => console.error('Operation failed:', e)));\n   * ```\n   */\n  tapErr<T, E>(result: Result<T, E>, fn: (error: E) => void): Result<T, E> {\n    if (!result.success) {\n      fn(result.error)\n    }\n    return result\n  },\n}\n\n/**\n * Async Result for operations that return promises\n */\nexport type AsyncResult<T, E = Error> = Promise<Result<T, E>>\n\n/**\n * Helper for creating async results\n */\nexport const AsyncResult = {\n  /**\n   * Create a successful async Result\n   */\n  ok<T>(value: T): AsyncResult<T, never> {\n    return Promise.resolve(Result.ok(value))\n  },\n\n  /**\n   * Create a failed async Result\n   */\n  err<E>(error: E): AsyncResult<never, E> {\n    return Promise.resolve(Result.err(error))\n  },\n\n  /**\n   * Chain async operations\n   */\n  async flatMap<T, U, E>(\n    result: AsyncResult<T, E>,\n    fn: (value: T) => AsyncResult<U, E>\n  ): AsyncResult<U, E> {\n    const resolved = await result\n    return Result.flatMapAsync(resolved, fn)\n  },\n}\n","/**\n * Error Type Hierarchy\n *\n * Strongly-typed errors for the Conductor framework.\n * All errors extend ConductorError for consistent handling.\n */\n\nimport type { MemberName, ModelId, ProviderId, EnsembleName } from '../types/branded.js'\n\n/**\n * Error codes for categorizing errors\n */\nexport enum ErrorCode {\n  // Member errors (1xxx)\n  MEMBER_NOT_FOUND = 'MEMBER_NOT_FOUND',\n  MEMBER_INVALID_CONFIG = 'MEMBER_INVALID_CONFIG',\n  MEMBER_EXECUTION_FAILED = 'MEMBER_EXECUTION_FAILED',\n  MEMBER_VALIDATION_FAILED = 'MEMBER_VALIDATION_FAILED',\n\n  // Provider errors (2xxx)\n  PROVIDER_NOT_FOUND = 'PROVIDER_NOT_FOUND',\n  PROVIDER_AUTH_FAILED = 'PROVIDER_AUTH_FAILED',\n  PROVIDER_API_ERROR = 'PROVIDER_API_ERROR',\n  PROVIDER_TIMEOUT = 'PROVIDER_TIMEOUT',\n  PROVIDER_RATE_LIMIT = 'PROVIDER_RATE_LIMIT',\n\n  // Platform errors (3xxx)\n  PLATFORM_UNSUPPORTED = 'PLATFORM_UNSUPPORTED',\n  PLATFORM_BINDING_MISSING = 'PLATFORM_BINDING_MISSING',\n  PLATFORM_VALIDATION_FAILED = 'PLATFORM_VALIDATION_FAILED',\n\n  // Model errors (4xxx)\n  MODEL_NOT_FOUND = 'MODEL_NOT_FOUND',\n  MODEL_DEPRECATED = 'MODEL_DEPRECATED',\n  MODEL_EOL = 'MODEL_EOL',\n\n  // Ensemble errors (5xxx)\n  ENSEMBLE_NOT_FOUND = 'ENSEMBLE_NOT_FOUND',\n  ENSEMBLE_PARSE_FAILED = 'ENSEMBLE_PARSE_FAILED',\n  ENSEMBLE_VALIDATION_FAILED = 'ENSEMBLE_VALIDATION_FAILED',\n  ENSEMBLE_EXECUTION_FAILED = 'ENSEMBLE_EXECUTION_FAILED',\n\n  // State errors (6xxx)\n  STATE_ACCESS_DENIED = 'STATE_ACCESS_DENIED',\n  STATE_INVALID_KEY = 'STATE_INVALID_KEY',\n\n  // Storage errors (7xxx)\n  STORAGE_NOT_FOUND = 'STORAGE_NOT_FOUND',\n  STORAGE_ACCESS_DENIED = 'STORAGE_ACCESS_DENIED',\n  STORAGE_OPERATION_FAILED = 'STORAGE_OPERATION_FAILED',\n\n  // Generic errors (9xxx)\n  VALIDATION_FAILED = 'VALIDATION_FAILED',\n  CONFIGURATION_ERROR = 'CONFIGURATION_ERROR',\n  INTERNAL_ERROR = 'INTERNAL_ERROR',\n}\n\n/**\n * Base error class for all Conductor errors\n */\nexport abstract class ConductorError extends Error {\n  abstract readonly code: ErrorCode\n  abstract readonly isOperational: boolean\n  readonly details?: Record<string, unknown>\n\n  constructor(message: string, details?: Record<string, unknown>) {\n    super(message)\n    this.name = this.constructor.name\n    this.details = details\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if ((Error as any).captureStackTrace) {\n      ;(Error as any).captureStackTrace(this, this.constructor)\n    }\n  }\n\n  /**\n   * Convert error to JSON for logging/serialization\n   */\n  toJSON(): ErrorJSON {\n    return {\n      name: this.name,\n      code: this.code,\n      message: this.message,\n      isOperational: this.isOperational,\n      stack: this.stack,\n    }\n  }\n\n  /**\n   * Convert error to user-friendly message\n   */\n  abstract toUserMessage(): string\n}\n\n/**\n * Error JSON representation\n */\nexport interface ErrorJSON {\n  name: string\n  code: ErrorCode\n  message: string\n  isOperational: boolean\n  stack?: string\n}\n\n// ============================================================================\n// Member Errors\n// ============================================================================\n\n/**\n * Member not found in registry\n */\nexport class MemberNotFoundError extends ConductorError {\n  readonly code = ErrorCode.MEMBER_NOT_FOUND\n  readonly isOperational = true\n\n  constructor(public readonly memberName: string) {\n    super(`Member \"${memberName}\" not found in registry`)\n  }\n\n  toUserMessage(): string {\n    return `The member \"${this.memberName}\" does not exist. Check your ensemble configuration.`\n  }\n}\n\n/**\n * Member configuration is invalid\n */\nexport class MemberConfigurationError extends ConductorError {\n  readonly code = ErrorCode.MEMBER_INVALID_CONFIG\n  readonly isOperational = true\n\n  constructor(\n    public readonly memberName: string,\n    public readonly reason: string\n  ) {\n    super(`Invalid configuration for member \"${memberName}\": ${reason}`)\n  }\n\n  toUserMessage(): string {\n    return `Configuration error in member \"${this.memberName}\": ${this.reason}`\n  }\n}\n\n/**\n * Member execution failed\n */\nexport class MemberExecutionError extends ConductorError {\n  readonly code = ErrorCode.MEMBER_EXECUTION_FAILED\n  readonly isOperational = true\n\n  constructor(\n    public readonly memberName: string,\n    public readonly reason: string,\n    public readonly cause?: Error\n  ) {\n    super(`Member \"${memberName}\" execution failed: ${reason}`)\n  }\n\n  toUserMessage(): string {\n    return `Execution failed for member \"${this.memberName}\": ${this.reason}`\n  }\n}\n\n/**\n * Member validation failed\n */\nexport class MemberValidationError extends ConductorError {\n  readonly code = ErrorCode.MEMBER_VALIDATION_FAILED\n  readonly isOperational = true\n\n  constructor(\n    public readonly memberName: string,\n    public readonly errors: string[]\n  ) {\n    super(`Validation failed for member \"${memberName}\": ${errors.join(', ')}`)\n  }\n\n  toUserMessage(): string {\n    return `Member \"${this.memberName}\" has validation errors:\\n${this.errors.map((e) => `  - ${e}`).join('\\n')}`\n  }\n}\n\n// ============================================================================\n// Provider Errors\n// ============================================================================\n\n/**\n * AI provider not found\n */\nexport class ProviderNotFoundError extends ConductorError {\n  readonly code = ErrorCode.PROVIDER_NOT_FOUND\n  readonly isOperational = true\n\n  constructor(public readonly providerId: string) {\n    super(`AI provider \"${providerId}\" not found`)\n  }\n\n  toUserMessage(): string {\n    return `The AI provider \"${this.providerId}\" is not available. Check your provider configuration.`\n  }\n}\n\n/**\n * Provider authentication failed\n */\nexport class ProviderAuthError extends ConductorError {\n  readonly code = ErrorCode.PROVIDER_AUTH_FAILED\n  readonly isOperational = true\n\n  constructor(\n    public readonly providerId: string,\n    public readonly reason: string\n  ) {\n    super(`Authentication failed for provider \"${providerId}\": ${reason}`)\n  }\n\n  toUserMessage(): string {\n    return `Authentication error with \"${this.providerId}\": ${this.reason}. Check your API keys.`\n  }\n}\n\n/**\n * Provider API error\n */\nexport class ProviderAPIError extends ConductorError {\n  readonly code = ErrorCode.PROVIDER_API_ERROR\n  readonly isOperational = true\n\n  constructor(\n    public readonly providerId: string,\n    public readonly statusCode: number,\n    public readonly response: string\n  ) {\n    super(`API error from provider \"${providerId}\": ${statusCode} - ${response}`)\n  }\n\n  toUserMessage(): string {\n    return `API error from \"${this.providerId}\" (HTTP ${this.statusCode}): ${this.response}`\n  }\n}\n\n/**\n * Provider request timeout\n */\nexport class ProviderTimeoutError extends ConductorError {\n  readonly code = ErrorCode.PROVIDER_TIMEOUT\n  readonly isOperational = true\n\n  constructor(\n    public readonly providerId: string,\n    public readonly timeoutMs: number\n  ) {\n    super(`Request to provider \"${providerId}\" timed out after ${timeoutMs}ms`)\n  }\n\n  toUserMessage(): string {\n    return `Request to \"${this.providerId}\" timed out. The service may be slow or unavailable.`\n  }\n}\n\n/**\n * Provider rate limit exceeded\n */\nexport class ProviderRateLimitError extends ConductorError {\n  readonly code = ErrorCode.PROVIDER_RATE_LIMIT\n  readonly isOperational = true\n\n  constructor(\n    public readonly providerId: string,\n    public readonly retryAfter?: number\n  ) {\n    super(\n      `Rate limit exceeded for provider \"${providerId}\"` +\n        (retryAfter ? ` (retry after ${retryAfter}s)` : '')\n    )\n  }\n\n  toUserMessage(): string {\n    const retryMsg = this.retryAfter ? ` Please retry after ${this.retryAfter} seconds.` : ''\n    return `Rate limit exceeded for \"${this.providerId}\".${retryMsg}`\n  }\n}\n\n// ============================================================================\n// Platform Errors\n// ============================================================================\n\n/**\n * Platform not supported\n */\nexport class PlatformUnsupportedError extends ConductorError {\n  readonly code = ErrorCode.PLATFORM_UNSUPPORTED\n  readonly isOperational = true\n\n  constructor(public readonly platformName: string) {\n    super(`Platform \"${platformName}\" is not supported`)\n  }\n\n  toUserMessage(): string {\n    return `The platform \"${this.platformName}\" is not supported.`\n  }\n}\n\n/**\n * Platform binding missing\n */\nexport class PlatformBindingMissingError extends ConductorError {\n  readonly code = ErrorCode.PLATFORM_BINDING_MISSING\n  readonly isOperational = true\n\n  constructor(\n    public readonly bindingName: string,\n    public readonly hint?: string\n  ) {\n    super(`Binding \"${bindingName}\" not found` + (hint ? `: ${hint}` : ''))\n  }\n\n  toUserMessage(): string {\n    return `Required binding \"${this.bindingName}\" is not configured. ${this.hint || 'Add it to wrangler.toml'}`\n  }\n}\n\n// ============================================================================\n// Model Errors\n// ============================================================================\n\n/**\n * Model not found\n */\nexport class ModelNotFoundError extends ConductorError {\n  readonly code = ErrorCode.MODEL_NOT_FOUND\n  readonly isOperational = true\n\n  constructor(public readonly modelId: string) {\n    super(`Model \"${modelId}\" not found in platform data`)\n  }\n\n  toUserMessage(): string {\n    return `The model \"${this.modelId}\" is not available. Check the model ID or use a different model.`\n  }\n}\n\n/**\n * Model is deprecated\n */\nexport class ModelDeprecatedError extends ConductorError {\n  readonly code = ErrorCode.MODEL_DEPRECATED\n  readonly isOperational = true\n\n  constructor(\n    public readonly modelId: string,\n    public readonly reason?: string,\n    public readonly replacement?: string\n  ) {\n    super(\n      `Model \"${modelId}\" is deprecated` +\n        (reason ? `: ${reason}` : '') +\n        (replacement ? `. Use \"${replacement}\" instead` : '')\n    )\n  }\n\n  toUserMessage(): string {\n    let msg = `The model \"${this.modelId}\" is deprecated`\n    if (this.reason) msg += `: ${this.reason}`\n    if (this.replacement) msg += `. Please migrate to \"${this.replacement}\"`\n    return msg\n  }\n}\n\n/**\n * Model has reached end of life\n */\nexport class ModelEOLError extends ConductorError {\n  readonly code = ErrorCode.MODEL_EOL\n  readonly isOperational = true\n\n  constructor(\n    public readonly modelId: string,\n    public readonly eolDate: string,\n    public readonly replacement?: string\n  ) {\n    super(\n      `Model \"${modelId}\" reached end of life on ${eolDate}` +\n        (replacement ? `. Use \"${replacement}\" instead` : '')\n    )\n  }\n\n  toUserMessage(): string {\n    let msg = `The model \"${this.modelId}\" is no longer available (EOL: ${this.eolDate})`\n    if (this.replacement) msg += `. Please use \"${this.replacement}\" instead`\n    return msg\n  }\n}\n\n// ============================================================================\n// Ensemble Errors\n// ============================================================================\n\n/**\n * Ensemble not found\n */\nexport class EnsembleNotFoundError extends ConductorError {\n  readonly code = ErrorCode.ENSEMBLE_NOT_FOUND\n  readonly isOperational = true\n\n  constructor(public readonly ensembleName: string) {\n    super(`Ensemble \"${ensembleName}\" not found`)\n  }\n\n  toUserMessage(): string {\n    return `The ensemble \"${this.ensembleName}\" does not exist.`\n  }\n}\n\n/**\n * Ensemble parse error\n */\nexport class EnsembleParseError extends ConductorError {\n  readonly code = ErrorCode.ENSEMBLE_PARSE_FAILED\n  readonly isOperational = true\n\n  constructor(\n    public readonly ensembleName: string,\n    public readonly reason: string\n  ) {\n    super(`Failed to parse ensemble \"${ensembleName}\": ${reason}`)\n  }\n\n  toUserMessage(): string {\n    return `Syntax error in ensemble \"${this.ensembleName}\": ${this.reason}`\n  }\n}\n\n/**\n * Ensemble validation error\n */\nexport class EnsembleValidationError extends ConductorError {\n  readonly code = ErrorCode.ENSEMBLE_VALIDATION_FAILED\n  readonly isOperational = true\n\n  constructor(\n    public readonly ensembleName: string,\n    public readonly errors: string[]\n  ) {\n    super(`Validation failed for ensemble \"${ensembleName}\": ${errors.join(', ')}`)\n  }\n\n  toUserMessage(): string {\n    return `Ensemble \"${this.ensembleName}\" has validation errors:\\n${this.errors.map((e) => `  - ${e}`).join('\\n')}`\n  }\n}\n\n/**\n * Ensemble execution error\n */\nexport class EnsembleExecutionError extends ConductorError {\n  readonly code = ErrorCode.ENSEMBLE_EXECUTION_FAILED\n  readonly isOperational = true\n\n  constructor(\n    public readonly ensembleName: string,\n    public readonly step: string,\n    public readonly cause: Error\n  ) {\n    super(`Ensemble \"${ensembleName}\" failed at step \"${step}\": ${cause.message}`)\n  }\n\n  toUserMessage(): string {\n    return `Execution failed in ensemble \"${this.ensembleName}\" at step \"${this.step}\": ${this.cause.message}`\n  }\n}\n\n// ============================================================================\n// Storage Errors\n// ============================================================================\n\n/**\n * Storage key not found\n */\nexport class StorageKeyNotFoundError extends ConductorError {\n  readonly code = ErrorCode.STORAGE_NOT_FOUND\n  readonly isOperational = true\n\n  constructor(\n    public readonly key: string,\n    public readonly storageType: string\n  ) {\n    super(`Key \"${key}\" not found in ${storageType}`)\n  }\n\n  toUserMessage(): string {\n    return `The key \"${this.key}\" does not exist in ${this.storageType} storage.`\n  }\n}\n\n/**\n * Storage operation failed\n */\nexport class StorageOperationError extends ConductorError {\n  readonly code = ErrorCode.STORAGE_OPERATION_FAILED\n  readonly isOperational = true\n\n  constructor(\n    public readonly operation: string,\n    public readonly key: string,\n    public readonly cause: Error\n  ) {\n    super(`Storage operation \"${operation}\" failed for key \"${key}\": ${cause.message}`)\n  }\n\n  toUserMessage(): string {\n    return `Storage operation failed: ${this.operation} on \"${this.key}\"`\n  }\n}\n\n// ============================================================================\n// Generic Errors\n// ============================================================================\n\n/**\n * Configuration error\n */\nexport class ConfigurationError extends ConductorError {\n  readonly code = ErrorCode.CONFIGURATION_ERROR\n  readonly isOperational = true\n\n  constructor(public readonly reason: string) {\n    super(`Configuration error: ${reason}`)\n  }\n\n  toUserMessage(): string {\n    return `Configuration error: ${this.reason}`\n  }\n}\n\n/**\n * Internal error (should not happen in production)\n */\nexport class InternalError extends ConductorError {\n  readonly code = ErrorCode.INTERNAL_ERROR\n  readonly isOperational = false // Non-operational - indicates a bug\n\n  constructor(\n    public readonly reason: string,\n    public readonly cause?: Error\n  ) {\n    super(`Internal error: ${reason}`)\n  }\n\n  toUserMessage(): string {\n    return `An unexpected error occurred. Please contact support.`\n  }\n}\n\n/**\n * Error factory for common error scenarios\n */\nexport const Errors = {\n  memberNotFound: (name: string) => new MemberNotFoundError(name),\n  memberConfig: (name: string, reason: string) => new MemberConfigurationError(name, reason),\n  memberExecution: (name: string, reason: string, cause?: Error) =>\n    new MemberExecutionError(name, reason, cause),\n\n  providerNotFound: (id: string) => new ProviderNotFoundError(id),\n  providerAuth: (id: string, reason: string) => new ProviderAuthError(id, reason),\n  providerAPI: (id: string, status: number, response: string) =>\n    new ProviderAPIError(id, status, response),\n  providerTimeout: (id: string, timeout: number) => new ProviderTimeoutError(id, timeout),\n\n  modelNotFound: (id: string) => new ModelNotFoundError(id),\n  modelDeprecated: (id: string, reason?: string, replacement?: string) =>\n    new ModelDeprecatedError(id, reason, replacement),\n  modelEOL: (id: string, eolDate: string, replacement?: string) =>\n    new ModelEOLError(id, eolDate, replacement),\n\n  ensembleNotFound: (name: string) => new EnsembleNotFoundError(name),\n  ensembleParse: (name: string, reason: string) => new EnsembleParseError(name, reason),\n  ensembleExecution: (name: string, step: string, cause: Error) =>\n    new EnsembleExecutionError(name, step, cause),\n\n  bindingMissing: (name: string, hint?: string) => new PlatformBindingMissingError(name, hint),\n\n  storageNotFound: (key: string, storageType: string) =>\n    new StorageKeyNotFoundError(key, storageType),\n\n  config: (reason: string) => new ConfigurationError(reason),\n  internal: (reason: string, cause?: Error) => new InternalError(reason, cause),\n}\n"],"mappings":"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"}