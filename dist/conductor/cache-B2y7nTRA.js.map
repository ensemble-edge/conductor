{"version":3,"file":"cache-B2y7nTRA.js","names":["repository: Repository<CachedValue<T>, string>","cached: CachedValue<T>","keysToDelete: string[]"],"sources":["../../src/cache/cache.ts"],"sourcesContent":["/**\n * Cache System - Generic caching layer for agent executions\n *\n * Uses Repository pattern for storage-agnostic caching.\n * Supports TTL, cache keys, and invalidation strategies.\n */\n\nimport type { Repository } from '../storage/index.js'\nimport { Result, type AsyncResult } from '../types/result.js'\nimport { Errors, type ConductorError } from '../errors/error-types.js'\n\nexport interface CacheConfig {\n  defaultTTL?: number // Default TTL in seconds\n  enabled?: boolean // Enable/disable caching\n  keyPrefix?: string // Prefix for all cache keys\n}\n\nexport interface CacheOptions {\n  ttl?: number // TTL in seconds\n  tags?: string[] // Tags for group invalidation\n  bypass?: boolean // Bypass cache for this operation\n}\n\nexport interface CachedValue<T> {\n  value: T\n  cachedAt: number\n  expiresAt: number | null\n  tags?: string[]\n}\n\n/**\n * Cache interface for agent execution results\n */\nexport interface Cache<T = any> {\n  get(key: string): AsyncResult<T | null, ConductorError>\n  set(key: string, value: T, options?: CacheOptions): AsyncResult<void, ConductorError>\n  delete(key: string): AsyncResult<void, ConductorError>\n  has(key: string): AsyncResult<boolean, ConductorError>\n  clear(): AsyncResult<void, ConductorError>\n  invalidateByTag(tag: string): AsyncResult<void, ConductorError>\n}\n\n/**\n * Repository-based cache implementation\n */\nexport class RepositoryCache<T = any> implements Cache<T> {\n  private readonly config: Required<CacheConfig>\n\n  constructor(\n    private readonly repository: Repository<CachedValue<T>, string>,\n    config: CacheConfig = {}\n  ) {\n    this.config = {\n      defaultTTL: config.defaultTTL || 3600, // 1 hour default\n      enabled: config.enabled ?? true,\n      keyPrefix: config.keyPrefix || 'conductor:cache:',\n    }\n  }\n\n  /**\n   * Get value from cache\n   */\n  async get(key: string): AsyncResult<T | null, ConductorError> {\n    if (!this.config.enabled) {\n      return Result.ok(null)\n    }\n\n    const cacheKey = this.buildKey(key)\n    const result = await this.repository.get(cacheKey)\n\n    if (!result.success) {\n      // Cache miss or error - return null (not an error condition)\n      return Result.ok(null)\n    }\n\n    const cached = result.value\n\n    // Check expiration\n    if (cached.expiresAt && cached.expiresAt < Date.now()) {\n      // Expired - delete and return null\n      await this.repository.delete(cacheKey)\n      return Result.ok(null)\n    }\n\n    return Result.ok(cached.value)\n  }\n\n  /**\n   * Set value in cache\n   */\n  async set(key: string, value: T, options: CacheOptions = {}): AsyncResult<void, ConductorError> {\n    if (!this.config.enabled || options.bypass) {\n      return Result.ok(undefined)\n    }\n\n    const ttl = options.ttl || this.config.defaultTTL\n    const cacheKey = this.buildKey(key)\n\n    const cached: CachedValue<T> = {\n      value,\n      cachedAt: Date.now(),\n      expiresAt: Date.now() + ttl * 1000,\n      tags: options.tags,\n    }\n\n    return await this.repository.put(cacheKey, cached, { ttl })\n  }\n\n  /**\n   * Delete value from cache\n   */\n  async delete(key: string): AsyncResult<void, ConductorError> {\n    const cacheKey = this.buildKey(key)\n    return await this.repository.delete(cacheKey)\n  }\n\n  /**\n   * Check if key exists in cache\n   */\n  async has(key: string): AsyncResult<boolean, ConductorError> {\n    const result = await this.get(key)\n    return Result.ok(result.success && result.value !== null)\n  }\n\n  /**\n   * Clear all cache entries (if supported by repository)\n   */\n  async clear(): AsyncResult<void, ConductorError> {\n    // This requires listing all keys and deleting them\n    // Not all repositories support efficient clearing\n    const listResult = await this.repository.list()\n\n    if (!listResult.success) {\n      return Result.err(listResult.error)\n    }\n\n    // Delete all entries with our prefix\n    // Note: This is inefficient - prefer using repository-specific clear methods\n    return Result.ok(undefined)\n  }\n\n  /**\n   * Invalidate cache entries by tag\n   */\n  async invalidateByTag(tag: string): AsyncResult<void, ConductorError> {\n    // This requires listing all keys, checking tags, and deleting matches\n    // Not implemented efficiently yet - requires tag index\n    return Result.err(Errors.internal('Tag-based invalidation not yet implemented'))\n  }\n\n  /**\n   * Build cache key with prefix\n   */\n  private buildKey(key: string): string {\n    return `${this.config.keyPrefix}${key}`\n  }\n\n  /**\n   * Get cache statistics\n   */\n  getConfig(): CacheConfig {\n    return { ...this.config }\n  }\n}\n\n/**\n * In-memory cache implementation (for testing/development)\n */\nexport class MemoryCache<T = any> implements Cache<T> {\n  private readonly store = new Map<string, CachedValue<T>>()\n  private readonly config: Required<CacheConfig>\n\n  constructor(config: CacheConfig = {}) {\n    this.config = {\n      defaultTTL: config.defaultTTL || 3600,\n      enabled: config.enabled ?? true,\n      keyPrefix: config.keyPrefix || '',\n    }\n  }\n\n  async get(key: string): AsyncResult<T | null, ConductorError> {\n    if (!this.config.enabled) {\n      return Result.ok(null)\n    }\n\n    const cacheKey = this.buildKey(key)\n    const cached = this.store.get(cacheKey)\n\n    if (!cached) {\n      return Result.ok(null)\n    }\n\n    // Check expiration\n    if (cached.expiresAt && cached.expiresAt < Date.now()) {\n      this.store.delete(cacheKey)\n      return Result.ok(null)\n    }\n\n    return Result.ok(cached.value)\n  }\n\n  async set(key: string, value: T, options: CacheOptions = {}): AsyncResult<void, ConductorError> {\n    if (!this.config.enabled || options.bypass) {\n      return Result.ok(undefined)\n    }\n\n    const ttl = options.ttl || this.config.defaultTTL\n    const cacheKey = this.buildKey(key)\n\n    this.store.set(cacheKey, {\n      value,\n      cachedAt: Date.now(),\n      expiresAt: Date.now() + ttl * 1000,\n      tags: options.tags,\n    })\n\n    return Result.ok(undefined)\n  }\n\n  async delete(key: string): AsyncResult<void, ConductorError> {\n    const cacheKey = this.buildKey(key)\n    this.store.delete(cacheKey)\n    return Result.ok(undefined)\n  }\n\n  async has(key: string): AsyncResult<boolean, ConductorError> {\n    const result = await this.get(key)\n    return Result.ok(result.success && result.value !== null)\n  }\n\n  async clear(): AsyncResult<void, ConductorError> {\n    this.store.clear()\n    return Result.ok(undefined)\n  }\n\n  async invalidateByTag(tag: string): AsyncResult<void, ConductorError> {\n    const keysToDelete: string[] = []\n\n    for (const [key, cached] of this.store.entries()) {\n      if (cached.tags && cached.tags.includes(tag)) {\n        keysToDelete.push(key)\n      }\n    }\n\n    for (const key of keysToDelete) {\n      this.store.delete(key)\n    }\n\n    return Result.ok(undefined)\n  }\n\n  private buildKey(key: string): string {\n    return `${this.config.keyPrefix}${key}`\n  }\n\n  /**\n   * Get cache size (memory only)\n   */\n  size(): number {\n    return this.store.size\n  }\n}\n\n/**\n * No-op cache (disables caching)\n */\nexport class NoOpCache<T = any> implements Cache<T> {\n  async get(): AsyncResult<T | null, ConductorError> {\n    return Result.ok(null)\n  }\n\n  async set(): AsyncResult<void, ConductorError> {\n    return Result.ok(undefined)\n  }\n\n  async delete(): AsyncResult<void, ConductorError> {\n    return Result.ok(undefined)\n  }\n\n  async has(): AsyncResult<boolean, ConductorError> {\n    return Result.ok(false)\n  }\n\n  async clear(): AsyncResult<void, ConductorError> {\n    return Result.ok(undefined)\n  }\n\n  async invalidateByTag(): AsyncResult<void, ConductorError> {\n    return Result.ok(undefined)\n  }\n}\n"],"mappings":";AAwKA,IAAa,cAAb,MAAsD;CAIpD,YAAY,SAAsB,EAAE,EAAE;+BAHb,IAAI,KAA6B;AAIxD,OAAK,SAAS;GACZ,YAAY,OAAO,cAAc;GACjC,SAAS,OAAO,WAAW;GAC3B,WAAW,OAAO,aAAa;GAChC;;CAGH,MAAM,IAAI,KAAoD;AAC5D,MAAI,CAAC,KAAK,OAAO,QACf,QAAO,OAAO,GAAG,KAAK;EAGxB,MAAM,WAAW,KAAK,SAAS,IAAI;EACnC,MAAM,SAAS,KAAK,MAAM,IAAI,SAAS;AAEvC,MAAI,CAAC,OACH,QAAO,OAAO,GAAG,KAAK;AAIxB,MAAI,OAAO,aAAa,OAAO,YAAY,KAAK,KAAK,EAAE;AACrD,QAAK,MAAM,OAAO,SAAS;AAC3B,UAAO,OAAO,GAAG,KAAK;;AAGxB,SAAO,OAAO,GAAG,OAAO,MAAM;;CAGhC,MAAM,IAAI,KAAa,OAAU,UAAwB,EAAE,EAAqC;AAC9F,MAAI,CAAC,KAAK,OAAO,WAAW,QAAQ,OAClC,QAAO,OAAO,GAAG,KAAA,EAAU;EAG7B,MAAM,MAAM,QAAQ,OAAO,KAAK,OAAO;EACvC,MAAM,WAAW,KAAK,SAAS,IAAI;AAEnC,OAAK,MAAM,IAAI,UAAU;GACvB;GACA,UAAU,KAAK,KAAK;GACpB,WAAW,KAAK,KAAK,GAAG,MAAM;GAC9B,MAAM,QAAQ;GACf,CAAC;AAEF,SAAO,OAAO,GAAG,KAAA,EAAU;;CAG7B,MAAM,OAAO,KAAgD;EAC3D,MAAM,WAAW,KAAK,SAAS,IAAI;AACnC,OAAK,MAAM,OAAO,SAAS;AAC3B,SAAO,OAAO,GAAG,KAAA,EAAU;;CAG7B,MAAM,IAAI,KAAmD;EAC3D,MAAM,SAAS,MAAM,KAAK,IAAI,IAAI;AAClC,SAAO,OAAO,GAAG,OAAO,WAAW,OAAO,UAAU,KAAK;;CAG3D,MAAM,QAA2C;AAC/C,OAAK,MAAM,OAAO;AAClB,SAAO,OAAO,GAAG,KAAA,EAAU;;CAG7B,MAAM,gBAAgB,KAAgD;EACpE,MAAME,eAAyB,EAAE;AAEjC,OAAK,MAAM,CAAC,KAAK,WAAW,KAAK,MAAM,SAAS,CAC9C,KAAI,OAAO,QAAQ,OAAO,KAAK,SAAS,IAAI,CAC1C,cAAa,KAAK,IAAI;AAI1B,OAAK,MAAM,OAAO,aAChB,MAAK,MAAM,OAAO,IAAI;AAGxB,SAAO,OAAO,GAAG,KAAA,EAAU;;CAG7B,SAAiB,KAAqB;AACpC,SAAO,GAAG,KAAK,OAAO,YAAY;;CAMpC,OAAe;AACb,SAAO,KAAK,MAAM"}